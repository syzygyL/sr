<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>集群篇</title>
    <url>/sr/post/2020-04-30-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1-2020-04-30-%E9%9B%86%E7%BE%A4%E7%AF%87/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><p><strong>搭建时注意点</strong></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#是否将该实例信息注册到其他eureka server上；如果设置为false，那么该server无法被其他server发现，但是仍然可以发现其他server</span></span><br><span class="line"><span class="meta">eureka.client.register-with-eureka</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#是否允许该客户端从eureka server上获取注册信息</span></span><br><span class="line"><span class="meta">eureka.client.fetch-registry</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>最后查看 Eureka 控制台，available-replicas里面有相邻节点信息则成功，否则集群搭建失败</p><p>total-avail-memory : 总共可用的内存<br>environment : 环境名称，默认test<br>num-of-cpus : CPU的个数<br>current-memory-usage : 当前已经使用内存的百分比<br>server-uptime : 服务启动时间<br>registered-replicas : 相邻集群复制节点<br>unavailable-replicas ：不可用的集群复制节点，如何确定不可用？ 主要是server1 向 server2和server3发送接口查询自身的注册信息，如果查询不到，则默认为不可用，也就是说如果Eureka Server自身不作为客户端注册到上面去，则相邻节点都会显示为不可用。<br>available-replicas ：可用的相邻集群复制节点</p><!-- more --><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式追踪</title>
    <url>/sr/post/2020-04-29-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1-2020-04-29-%E5%88%86%E5%B8%83%E5%BC%8F%E8%BF%BD%E8%B8%AA/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><p>SpringCloud Sleuth + Zipkin DashBoard</p><p>todo</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK</title>
    <url>/sr/post/2020-04-29-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1-2020-04-29-ELK/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>ELK: Elasticsearch + LogStash + Kibana</p><p>概念（应用场景）: 当传统单体巨石架构的弊端逐渐显露出来时，微服务架构应运而生，而微服务的集群分布式部署将单机日志的问题定位又提高了一个难度等级，此时一个分布式日志监控系统显得至关重要，<code>ELK</code>通过<code>Logstash</code>去收集每台服务器日志文件，然后按定义的正则模板过滤后传输到<code>mq/redis</code>，然后由另一个<code>Logstash</code>从mq/redis监听并存储到<code>Elasticsearch</code>中，最后通过<code>Kibana</code>负责日志的呈现。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>定律篇</title>
    <url>/sr/post/2020-04-28-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1-2020-04-29-%E5%AE%9A%E5%BE%8B%E7%AF%87/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="康威定律"><a href="#康威定律" class="headerlink" title="康威定律"></a>康威定律</h2><p>康威定律是马尔文·康威1967提出的：“设计系统的架构受制于产生这些设计的组织的沟通结构。”通俗的来讲：产品必然是其（人员）组织沟通结构的缩影。跨部门沟通是非常难的，系统各个模块的接口也反映了它们之间的信息流动和合作方式。</p><p>康威定律可谓软件架构设计中的第一定律，起初只是在杂志上的发表，后经过《人月神话》这本软件界圣经的引用，并命名为康威定律（Conway’s law），因此得以推广。</p><a id="more"></a><p>只通过简单的描述可能无法理解康威定律的精髓所在，原文中康威定律可总结为四个定律：</p><p>第一定律 组织沟通方式会通过系统设计表达出来。<br>第二定律 时间再多一件事情也不可能做的完美，但总有时间做完一件事情。<br>第三定律 线型系统和线型组织架构间有潜在的异质同态特性。<br>第四定律 大的系统组织总是比小系统更倾向于分解。</p><!-- more --><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>MyCat</title>
    <url>/sr/post/2020-04-27-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF-2020-04-27-MyCat/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><h3 id="什么是-MyCat？"><a href="#什么是-MyCat？" class="headerlink" title="什么是 MyCat？"></a>什么是 MyCat？</h3><p>MyCat 是目前最流行的基于 java 语言编写的数据库中间件，是一个实现了 MySQL 协议的服务器，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用 MySQL 原生协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是<strong>分库分表。配合数据库的主从模式还可实现读写分离</strong>。</p><a id="more"></a><!-- more --><p>MyCat 是基于阿里开源的 Cobar 产品而研发，Cobar 的稳定性、可靠性、优秀的架构和性能以及众多成熟的使用案例使得 MyCat 变得非常的强大。<br>其目标是<strong>低成本</strong>的将现有的<strong>单机数据库</strong>和<strong>应用</strong>平滑<strong>迁移到“云”端</strong>，解决<strong>数据存储</strong>和<strong>业务规模</strong>迅速增长情况下的<strong>数据瓶颈</strong>问题</p><h3 id="为什么要用-MyCat？"><a href="#为什么要用-MyCat？" class="headerlink" title="为什么要用 MyCat？"></a>为什么要用 MyCat？</h3><p>当我们项目庞大到需要分库甚至分表时，这个时候就出现很多个库和表，管理维护起来非常麻烦，这个时候就需要对数据库层做一个抽象，来帮我们更好地管理这些数据库，而上层应用只需要面对一个数据库层的抽象或者说数据库中间件就好了，这就是Mycat的核心作用。</p><p>使用的弊端：单点故障、跨节点join</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>支持 SQL 92标准</li><li>支持Mysql集群，可以作为Proxy使用</li><li>支持JDBC连接ORACLE、DB2、SQL Server，将其模拟为MySQL Server使用</li><li>支持galera for mysql集群，percona-cluster或者mariadb cluster，提供高可用性数据分片集群</li><li>自动故障切换，高可用性</li><li>支持读写分离，支持Mysql双主多从，以及一主多从的模式</li><li>支持全局表，数据自动分片到多个节点，用于高效表关联查询</li><li>支持独有的基于E-R 关系的分片策略，实现了高效的表关联查询</li><li>多平台支持，部署和实施简单</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>中间件技术</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈赋能</title>
    <url>/sr/post/2020-04-27-%E6%9D%82%E9%A1%B9-%E8%AF%BB%E5%90%8E%E6%84%9F-2020-04-27-%E6%B5%85%E8%B0%88%E8%B5%8B%E8%83%BD/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><p>出于偶然在网上看到了这么一个名词，原来这个“赋能”这个新的管理名词，在近年来，由于马云和马化腾的表述，已经是很多管理人员最喜欢的表述名词了。它源自于《赋能——打造应对不确定性的敏捷团队》作者是斯坦利 . 麦克利斯特尔，美国陆军四星级上将。书中用真实的战斗案例告诉大家，面对互联网信息化时代错综复杂的环境，一个组织应该如何重新创造自己，如何改变组织基因，涅槃重生。</p><blockquote><p>未来组织最重要的功能已经越来越清楚，那就是赋能，而不再是管理或激励。</p></blockquote><p>著名的管理学家陈春花老师也说，<strong>未来的组织管理中最核心的价值其实就是我们怎么去赋能和激活人</strong>。</p><p>“赋能”顾名思义，就是给谁赋予某种能力和能量，通俗来讲就是，你本身不能，但我使你能。它最早是心理学中的词汇，旨在通过言行、态度、环境的改变给予他人正能量。</p><p>在赋能这个词用在管理学中，是指是企业由上而下地释放权力，尤其是员工们自主工作的权力，<strong>从而通过去中心化的方式驱动企业组织扁平化，最大限度发挥个人才智和潜能</strong>。</p><p>本文转载自: <a href="https://www.sohu.com/a/242903558_722904" target="_blank" rel="noopener">https://www.sohu.com/a/242903558_722904</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/sr/post/2020-04-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2020-04-26-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><h2 id="GOF23种设计模式"><a href="#GOF23种设计模式" class="headerlink" title="GOF23种设计模式"></a>GOF23种设计模式</h2><p>（1）<strong>创建型模式</strong>，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>（2）<strong>结构型模式</strong>，共七种：<strong>适配器模式、装饰器模式、代理模式</strong>、外观模式、桥接模式、组合模式、享元模式。</p><p>（3）<strong>行为型模式</strong>，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><h2 id="面向对象设计模式"><a href="#面向对象设计模式" class="headerlink" title="面向对象设计模式"></a>面向对象设计模式</h2><p>不属于GOF之内的</p><p>委派模式（Delegate）<br>应用场景：不属于23 种设计模式之一，是面向对象设计模式中常用的一种模式。这种模式的原理为类B和类A 是两个互相没有任何关系的类，B 具有和A 一模一样的方法和属性；并且调用B 中的方法，属性就是调用A 中同名的方法和属性。B 好像就是一个受A 授权委托的中介。第三方的代码不需要知道A 的存在，也不需要和A 发生直接的联系，通过B 就可以直接使用A 的功能，这样既能够使用到A 的各种功能，又能够很好的将A 保护起来了，一举两得。</p><p>1、 Spring中的应用<br>IoC:在doRegisterBeanDefinitions()即BeanDefinition进行注册的过程中，会设置BeanDefinitionParserDelegate类型的Delegate对象传给this.delegate，并将这个对象作为一个参数传给：parseBeanDefinitions(root, this.delegate)中，然后主要的解析的工作就是通过delegate作为主要角色来完成的</p><p>2、SpringMVC中应用</p><p>前端控制器: 类DispatcherServlet，就是：用于HTTP请求处理程序/控制器的中央调度程序，针对通过WEB UI输入的url请求，委派给DispatcherServlet处理，从委派者的角度来看，关注结果即可</p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则-SRP"><a href="#单一职责原则-SRP" class="headerlink" title="单一职责原则 SRP"></a>单一职责原则 SRP</h3><p>Single Responsibility Principle: <strong>对一个类而言，应该只专注于做一件事和仅有一个引起它变化的原因</strong>。通俗的讲，某个类应该只负责单一功能，当有两个变化会要求修改这个类，那么就要考虑拆分这个类，因为当后来者 b 变化要求修改类时，可能会影响到 a 变化修改后此类的正常运作</p><h3 id="里氏替换原则-LSP"><a href="#里氏替换原则-LSP" class="headerlink" title="里氏替换原则 LSP"></a>里氏替换原则 LSP</h3><p>Liskov Substitution Principle: <strong>里氏替换原则依赖于继承、多态</strong>。只要父类能出现的地方子类就可以出现（因为继承），而且替换为子类也不会产生任何错误或异常，使用者不需要知道是父类还是子类。但是反过来不行，有子类出现的地方，父类未必适应（子类有的方法父类未必有）</p><h3 id="依赖倒置原则-DIP"><a href="#依赖倒置原则-DIP" class="headerlink" title="依赖倒置原则 DIP"></a>依赖倒置原则 DIP</h3><p>Dependence Inversion Principle: <strong>依赖倒置原则依赖于抽象，而不依赖具体实现</strong>。模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口和抽象类产生的</p><p>《敏捷软件开发》：</p><div class="note success"><p>依赖倒置原则<br>a.高层模块不应该依赖于底层模块，二者都应该依赖于抽象。<br>b.抽象不应该依赖于细节，细节应该依赖于抽象。</p></div><h3 id="接口隔离原则-ISP"><a href="#接口隔离原则-ISP" class="headerlink" title="接口隔离原则 ISP"></a>接口隔离原则 ISP</h3><p>Interface Segregation Principles: <strong>客户端不应该依赖它不需要的接口</strong>。通俗的讲，在设计类时，我们需要将各种接口隔离，使用多个专一功能的接口比使用一个的总接口总要好。过于臃肿的接口是对接口的污染，不应该强迫客户依赖于它们不用的方法。</p><h3 id="迪米特原则-LOD"><a href="#迪米特原则-LOD" class="headerlink" title="迪米特原则 LOD"></a>迪米特原则 LOD</h3><p>Law of Demeter: 又称最少知道原则(Demeter Principle)，它指出<strong>类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大</strong>。</p><h3 id="开放封闭原则-OCP"><a href="#开放封闭原则-OCP" class="headerlink" title="开放封闭原则 OCP"></a>开放封闭原则 OCP</h3><p>Open Close Principle: <strong>程序中的对象（类、模块、函数等）应该对于扩展开放，对于修改是封闭的</strong></p><p>单一职责原则告诉我们实现类要职责单一；<br>里氏替换原则告诉我们不要破坏继承体系；<br>依赖倒置原则告诉我们要面向接口编程；<br>接口隔离原则告诉我们在设计接口的时候要精简单一；<br>迪米特法则告诉我们要降低耦合；<br>而开放封闭原则是总纲领，他告诉我们要对扩展开放，对修改关闭。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/sr/post/2020-04-23-%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%8E%E5%BE%AE%E6%9C%8D%E5%8A%A1-2020-04-23-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><p>随着组织规模不断扩大，业务量不断增长，单机应用和数据库已经不足以支持庞大的业务量和数据量，这个时候需要对应用和数据库进行拆分，就出现了一个应用需要同时访问两个或两个以上的数据库情况。开始我们用分布式事务来保证一致性，也就是我们常说的两阶段提交协议（2PC）。2PC有个致命缺点就是不支持NoSQL，这使得微服务架构不得不摒弃它。</p><h3 id="传统分布式事务模式"><a href="#传统分布式事务模式" class="headerlink" title="传统分布式事务模式"></a>传统分布式事务模式</h3><p>2PC、3PC协议能保证数据的强一致性，但不是分布式系统中一致性保证的最佳实践。原因如下：</p><p>1）分布式系统中各个应用的数据大多是自己私有的，应用之间通过API进行访问，这种方式使得应用之间松耦合，彼此之间很容易进行扩展。若通过传统分布式事务，则将不同应用的数据访问捆绑在一起。</p><p>2）不同应用使用不同数据库，若有的应用使用NOSQL数据库，这些非关系型数据库不支持2PC。</p><h3 id="微服务架构中应满足数据最终一致性原则"><a href="#微服务架构中应满足数据最终一致性原则" class="headerlink" title="微服务架构中应满足数据最终一致性原则"></a>微服务架构中应满足数据最终一致性原则</h3><p>实现的3种模式</p><p>1) 可靠事件模式（事件驱动-异步消息）<br>2) 补偿模式(saga模型-补偿子事务)<br>3) TCC（Try、Confirm、Cancel）</p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。<br>C表示一致性，也就是所有用户看到的数据是一样的。<br>A表示可用性，是指总能找到一个可用的数据副本。<br>P表示分区容错性，能够容忍网络中断等故障。</p><p>以前说CAP理论，说对于一个分布式系统，上面3个，只能同时满足2个。但这个其实不准确，P其实一定存在，是你避免不了的。能做的，其实主要是在C和A之间权衡。</p><p>比如拿Mysql来说，它的C最强，A次之，P最弱。如果你为了A，给数据做冗余，比如重写轻读，那C就很难保证；为了P，给数据做分库分表，那就做不了事务；</p><p>比如Nosql，P最强，可以很好的做数据拆分，但C就不够，做不了事务；</p><p>比如微博系统，对C的要求降低，就可以加很多缓存，提高A；数据分片，提高P；</p><p>而支付，交易转帐，对C的要求很高，就不能简单的用Cache来提高性能</p><p>最终一致性</p><p>前面提到，在分布式系统中，因为数据的分拆，服务的分拆，强一致性就很难保证。这个时候，用的最多的就是“最终一致性“。</p><p>强一致性，弱一致性，最终一致性，是一致性的几个不同的等级。在传统的关系型数据库中，通过事务来保证强一致性。</p><p>但在分布式系统中，通常都会把强一致性折中成最终一致性，从而变相的解决分布式事务问题。最终一致性的实现，通常都需要一个高可靠的消息队列</p><h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写，是对 CAP 中 AP 的一个扩展。</p><p>基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</p><p>软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。</p><p>最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。</p><p>BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。</p><p>BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h3 id="XA-规范"><a href="#XA-规范" class="headerlink" title="XA 规范"></a>XA 规范</h3><p>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。<br>事务协调器要求每个数据库提交数据，或者回滚数据。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。<br>二阶提交协议和三阶提交协议就是根据这一思想衍生出来的。可以说二阶段提交其实就是实现XA分布式事务的关键(确切地说：两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做)</p><h3 id="柔性事务解决方案架构"><a href="#柔性事务解决方案架构" class="headerlink" title="柔性事务解决方案架构"></a>柔性事务解决方案架构</h3><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>seata</p><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><h4 id="TCC-事务补偿型"><a href="#TCC-事务补偿型" class="headerlink" title="TCC 事务补偿型"></a>TCC 事务补偿型</h4><p>TCC（Try-Confirm-Cancel） 事务机制相比于上面介绍的 XA，解决了如下几个缺点：</p><p>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。<br>同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。<br>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性。</p><p>在TCC模式下，先保存草稿（Try）再发送（Confirm），撤销的话直接删除草稿（Cancel）就行了</p><h4 id="最大努力通知型"><a href="#最大努力通知型" class="headerlink" title="最大努力通知型"></a>最大努力通知型</h4><p>实现：业务活动的主动方在完成处理之后向业务活动的被动方发送消息，允许消息丢失。业务活动的被动方根据定时策略，向业务活动的主动方查询，恢复丢失的业务消息。<br>约束：被动方的处理结果不影响主动方的处理结果。<br>成本：业务查询与校对系统的建设成本。<br>使用范围：对业务最终一致性的时间敏感度低。跨企业的业务活动。<br>特点：业务活动的主动方在完成业务处理之后，向业务活动的被动方发送通知消息。主动方可以设置时间阶梯通知规则，在通知失败后按规则重复通知，知道通知N次后不再通知。主动方提供校对查询接口给被动方按需校对查询，用户恢复丢失的业务消息。</p><h3 id="基于可靠消息的最终一致性方案"><a href="#基于可靠消息的最终一致性方案" class="headerlink" title="基于可靠消息的最终一致性方案"></a>基于可靠消息的最终一致性方案</h3><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p><strong>幂等操作</strong>：是其任意多次执行所产生的影响均与一次执行的影响相同（不用担心重复执行会对系统造成改变）</p><p><strong>业务场景</strong>：模拟一个用户下单场景，如果用户端因网络问题引发用户重复点击多次，会生成多个订单号，会造成系统业务问题。</p><p><strong>幂等性解决方案</strong></p><ul><li>数据库表加唯一索引，防止新增脏数据。比如对订单号进行加唯一索引，防止生成重复订单。</li><li>分布式锁，利用redis，在业务系统插入数据或者更新数据，获取分布式锁，然后做操作，之后释放锁</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>分布式与微服务</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>优化相关</title>
    <url>/sr/post/2020-04-22-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98-2020-04-22-%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="mysql执行计划"><a href="#mysql执行计划" class="headerlink" title="mysql执行计划"></a>mysql执行计划</h2><p>在企业的应用场景中，为了知道优化SQL语句的执行，需要查看SQL语句的具体执行过程，以加快SQL语句的执行效率。</p><p>可以使用explain+SQL语句来模拟优化器执行SQL查询语句，从而知道mysql是如何处理sql语句的。</p><p>官网地址： <a href="https://dev.mysql.com/doc/refman/5.5/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/explain-output.html</a></p><h3 id="1、执行计划中包含的信息"><a href="#1、执行计划中包含的信息" class="headerlink" title="1、执行计划中包含的信息"></a>1、执行计划中包含的信息</h3><table><thead><tr><th align="center">Column</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">The <code>SELECT</code> identifier</td></tr><tr><td align="center">select_type</td><td align="center">The <code>SELECT</code> type</td></tr><tr><td align="center">table</td><td align="center">The table for the output row</td></tr><tr><td align="center">partitions</td><td align="center">The matching partitions</td></tr><tr><td align="center">type</td><td align="center">The join type</td></tr><tr><td align="center">possible_keys</td><td align="center">The possible indexes to choose</td></tr><tr><td align="center">key</td><td align="center">The index actually chosen</td></tr><tr><td align="center">key_len</td><td align="center">The length of the chosen key</td></tr><tr><td align="center">ref</td><td align="center">The columns compared to the index</td></tr><tr><td align="center">rows</td><td align="center">Estimate of rows to be examined</td></tr><tr><td align="center">filtered</td><td align="center">Percentage of rows filtered by table condition</td></tr><tr><td align="center">extra</td><td align="center">Additional information</td></tr></tbody></table><p><strong>id</strong></p><p>select查询的序列号，包含一组数字，表示查询中执行select子句或者操作表的顺序</p><p>id号分为三种情况：</p><p>​ 1、如果id相同，那么执行顺序从上到下</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal;</span><br></pre></td></tr></table></figure><p>​ 2、如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p>​ 3、id相同和不同的，同时存在：相同的可以认为是一组，从上往下顺序执行，在所有组中，id值越大，优先级越高，越先执行</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">join</span> dept d <span class="keyword">on</span> e.deptno = d.deptno <span class="keyword">join</span> salgrade sg <span class="keyword">on</span> e.sal <span class="keyword">between</span> sg.losal <span class="keyword">and</span> sg.hisal <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> d.deptno <span class="keyword">from</span> dept d <span class="keyword">where</span> d.dname = <span class="string">'SALES'</span>);</span><br></pre></td></tr></table></figure><p><strong>select_type</strong></p><p>主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p><table><thead><tr><th align="center"><code>select_type</code> Value</th><th align="center">Meaning</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td align="center">Simple SELECT (not using UNION or subqueries)</td></tr><tr><td align="center">PRIMARY</td><td align="center">Outermost SELECT</td></tr><tr><td align="center">UNION</td><td align="center">Second or later SELECT statement in a UNION</td></tr><tr><td align="center">DEPENDENT UNION</td><td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td align="center">UNION RESULT</td><td align="center">Result of a UNION.</td></tr><tr><td align="center">SUBQUERY</td><td align="center">First SELECT in subquery</td></tr><tr><td align="center">DEPENDENT SUBQUERY</td><td align="center">First SELECT in subquery, dependent on outer query</td></tr><tr><td align="center">DERIVED</td><td align="center">Derived table</td></tr><tr><td align="center">UNCACHEABLE SUBQUERY</td><td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td align="center">UNCACHEABLE UNION</td><td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--sample:简单的查询，不包含子查询和union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--primary:查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--union:若第二个select出现在union之后，则被标记为union</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent union:跟union类似，此处的depentent表示union或union all联合而成的结果会受外部表影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.empno  <span class="keyword">in</span> ( <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--union result:从union表获取结果的select</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt;<span class="number">2000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--subquery:在select或者where列表中包含子查询</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> sal &gt; (<span class="keyword">select</span> <span class="keyword">avg</span>(sal) <span class="keyword">from</span> emp) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--dependent subquery:subquery的子查询要受到外部表查询的影响</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"></span><br><span class="line"><span class="comment">--DERIVED: from子句中出现的子查询，也叫做派生类，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> staname,ename supname <span class="keyword">from</span> (<span class="keyword">select</span> ename staname,mgr <span class="keyword">from</span> emp) t <span class="keyword">join</span> emp <span class="keyword">on</span> t.mgr=emp.empno ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UNCACHEABLE SUBQUERY：表示使用子查询的结果不能被缓存</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = (<span class="keyword">select</span> empno <span class="keyword">from</span> emp <span class="keyword">where</span> deptno=@@sort_buffer_size);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--uncacheable union:表示union的查询结果不能被缓存：sql语句未验证</span></span><br></pre></td></tr></table></figure><p><strong>table</strong></p><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集<br>1、如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名</p><p>​ 2、表名是derivedN的形式，表示使用了id为N的查询产生的衍生表</p><p>​ 3、当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id</p><p><strong>type</strong></p><p>type显示的是访问类型，访问类型表示我是以何种方式去访问我们的数据，最容易想的是全表扫描，直接暴力的遍历一张表去寻找需要的数据，效率非常低下，访问的类型有很多，效率从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般情况下，得保证查询至少达到range级别，最好能达到ref</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--all:全表扫描，一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</span></span><br><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> empno <span class="keyword">from</span> emp;</span><br><span class="line"></span><br><span class="line"><span class="comment">--range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符： =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno <span class="keyword">between</span> <span class="number">7000</span> <span class="keyword">and</span> <span class="number">7500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--index_subquery：利用索引来关联子查询，不再扫描全表</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> emp.job <span class="keyword">in</span> (<span class="keyword">select</span> job <span class="keyword">from</span> t_job);</span><br><span class="line"></span><br><span class="line"><span class="comment">--unique_subquery:该连接类型类似与index_subquery,使用的是唯一索引</span></span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span> e.deptno <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> deptno <span class="keyword">from</span> dept);</span><br><span class="line"> </span><br><span class="line"><span class="comment">--index_merge：在查询过程中需要多个索引组合使用，没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e <span class="keyword">where</span>  e.mgr <span class="keyword">is</span> <span class="literal">null</span> <span class="keyword">or</span> e.mgr=<span class="number">7369</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--ref：使用了非唯一性索引进行数据的查找</span></span><br><span class="line"> <span class="keyword">create</span> <span class="keyword">index</span> idx_3 <span class="keyword">on</span> emp(deptno);</span><br><span class="line"> <span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno =d.deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--eq_ref ：使用唯一性索引进行数据查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,emp2 <span class="keyword">where</span> emp.empno = emp2.empno;</span><br><span class="line"></span><br><span class="line"><span class="comment">--const：这个表至多有一个匹配行，</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7369</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">--system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</span></span><br></pre></td></tr></table></figure><p><strong>possible_keys</strong></p><p>​ 显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key</strong></p><p>​ 实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>key_len</strong></p><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp,dept <span class="keyword">where</span> emp.deptno = dept.deptno <span class="keyword">and</span> emp.deptno = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>rows</strong></p><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure><p><strong>extra</strong></p><p>包含额外的信息。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--using filesort:说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">order</span> <span class="keyword">by</span> sal;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using temporary:建立临时表来保存中间结果，查询完成之后把临时表删除</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> ename,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">where</span> deptno = <span class="number">10</span> <span class="keyword">group</span> <span class="keyword">by</span> ename;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using index:这个表示当前的查询时覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> deptno,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> deptno <span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using where:使用where进行条件过滤</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--using join buffer:使用连接缓存，情况没有模拟出来</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--impossible where：where语句的结果总是false</span></span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp <span class="keyword">where</span> empno = <span class="number">7469</span>;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库与缓存</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm</title>
    <url>/sr/post/2020-04-17-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-2020-04-17-jvm/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h3 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h3><h4 id="GC-GC"><a href="#GC-GC" class="headerlink" title="GC/GC"></a>GC/GC</h4><p>Arthas（阿尔萨斯）是阿里巴巴开源的 Java 诊断工具，深受开发者喜爱。</p><p>内存飙高<br>CPU 飙高</p><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>GC目前的问题是，会暂停、阻碍代码的运行，即stop the world。增量式GC处理的就是这个问题。将GC变得可一阶段一阶段进行。</p><p>分阶段运行的思路并不难，但具体要解决的问题其实是分阶段GC后，如何保证下次继续时，中断过程中引用关系的变化不会对GC造成影响。</p><p>三色标记法是一个逻辑上的抽象，将对象分成<strong>白：未搜索，灰：正搜索，黑：已搜索</strong>。</p><h3 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h3><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><hr><h1 id="GC和GC-Tuning"><a href="#GC和GC-Tuning" class="headerlink" title="GC和GC Tuning"></a>GC和GC Tuning</h1><h3 id="GC的基础知识"><a href="#GC的基础知识" class="headerlink" title="GC的基础知识"></a>GC的基础知识</h3><h4 id="1-什么是垃圾"><a href="#1-什么是垃圾" class="headerlink" title="1.什么是垃圾"></a>1.什么是垃圾</h4><blockquote><p>C语言申请内存：malloc free</p><p>C++： new delete</p><p>c/C++ 手动回收内存</p><p>Java: new ？</p><p>自动内存回收，编程上简单，系统不容易出错，手动释放内存，容易出两种类型的问题：</p><ol><li>忘记回收</li><li>多次回收</li></ol></blockquote><p>没有任何引用指向的一个对象或者多个对象（循环引用）</p><h4 id="2-如何定位垃圾"><a href="#2-如何定位垃圾" class="headerlink" title="2.如何定位垃圾"></a>2.如何定位垃圾</h4><ol><li>引用计数（ReferenceCount）</li><li>可达性分析算法(RootSearching-GC Roots)</li></ol><h4 id="3-常见的垃圾回收算法"><a href="#3-常见的垃圾回收算法" class="headerlink" title="3.常见的垃圾回收算法"></a>3.常见的垃圾回收算法</h4><ol><li>标记清除(mark sweep) - 位置不连续 产生碎片 效率偏低（两遍扫描）</li><li>复制算法 (copying) - 没有碎片，浪费空间 效率还行（新生代）</li><li>标记压缩(mark compact) - 没有碎片，效率偏低（两遍扫描，指针需要调整）</li></ol><h4 id="4-JVM内存分代模型（用于分代垃圾回收算法）"><a href="#4-JVM内存分代模型（用于分代垃圾回收算法）" class="headerlink" title="4.JVM内存分代模型（用于分代垃圾回收算法）"></a>4.JVM内存分代模型（用于分代垃圾回收算法）</h4><ol><li><p>部分垃圾回收器使用的模型</p><blockquote><p>除Epsilon ZGC Shenandoah之外的GC都是使用逻辑分代模型</p><p>G1是逻辑分代，物理不分代</p><p>除此之外不仅逻辑分代，而且物理分代</p></blockquote></li><li><p>新生代 + 老年代 + 永久代（1.7）Perm Generation/ 元数据区(1.8) Metaspace</p><ol><li>永久代 元数据 - Class</li><li>永久代必须指定大小限制 ，元数据可以设置，也可以不设置，无上限（受限于物理内存）</li><li>字符串常量 1.7 - 永久代，1.8 - 堆</li><li>MethodArea逻辑概念 - 永久代、元数据</li></ol></li><li><p>新生代 = Eden + 2个suvivor区</p><ol><li>YGC回收之后，大多数的对象会被回收，活着的进入s0</li><li>再次YGC，活着的对象eden + s0 -&gt; s1</li><li>再次YGC，eden + s1 -&gt; s0</li><li>年龄足够 -&gt; 老年代 （15 CMS 6）</li><li>s区装不下 -&gt; 老年代</li></ol></li><li><p>老年代</p><ol><li>顽固分子</li><li>老年代满了FGC Full GC</li></ol></li><li><p>GC Tuning (Generation)</p><ol><li>尽量减少FGC</li><li>MinorGC = YGC</li><li>MajorGC = FGC</li></ol></li></ol><h4 id="5-常见的垃圾回收器"><a href="#5-常见的垃圾回收器" class="headerlink" title="5.常见的垃圾回收器"></a>5.常见的垃圾回收器</h4><ol><li><p>垃圾回收器的发展路线，是随着内存越来越大的过程而演进<br>从分代算法演化到不分代算法<br>Serial算法 几十兆<br>Parallel算法 几个G<br>CMS</p></li><li><p>JDK诞生 Serial追随 提高效率，诞生了PS，为了配合CMS，诞生了PN，CMS是1.4版本后期引入，CMS是里程碑式的GC，它开启了并发回收的过程，但是CMS毛病较多，因此目前任何一个JDK版本默认是CMS<br>并发垃圾回收是因为无法忍受STW</p></li><li><p>Serial 年轻代 串行回收</p></li><li><p>PS 年轻代 并行回收</p></li><li><p>ParNew 年轻代 配合CMS的并行回收</p></li><li><p>SerialOld</p></li><li><p>ParallelOld</p></li><li><p>ConcurrentMarkSweep 老年代 并发的， 垃圾回收和应用程序同时运行，降低STW的时间(200ms)<br>CMS问题比较多，所以现在没有一个版本默认是CMS，只能手工指定<br>CMS既然是MarkSweep，就一定会有碎片化的问题，碎片到达一定程度，CMS的老年代分配对象分配不下的时候，使用SerialOld 进行老年代回收<br>想象一下：<br>PS + PO -&gt; 加内存 换垃圾回收器 -&gt; PN + CMS + SerialOld（几个小时 - 几天的STW）<br>几十个G的内存，单线程回收 -&gt; G1 + FGC 几十个G -&gt; 上T内存的服务器 ZGC<br>算法：三色标记 + Incremental Update</p></li><li><p>G1(200ms - 10ms)<br>算法：三色标记 + SATB</p></li><li><p>ZGC (10ms - 1ms) PK C++<br>算法：ColoredPointers + LoadBarrier</p></li><li><p>Shenandoah<br>算法：ColoredPointers + WriteBarrier</p></li><li><p>Eplison</p></li><li><p>PS 和 PN区别的延伸阅读：<br>▪<a href="https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/13/gctuning/ergonomics.html#GUID-3D0BB91E-9BFF-4EBB-B523-14493A860E73</a></p></li><li><p>垃圾收集器跟内存大小的关系</p><ol><li>Serial 几十兆</li><li>PS 上百兆 - 几个G</li><li>CMS - 20G</li><li>G1 - 上百G</li><li>ZGC - 4T - 16T（JDK13）</li></ol></li></ol><p>1.8默认的垃圾回收：PS + ParallelOld</p><h3 id="常见垃圾回收器组合参数设定：-1-8"><a href="#常见垃圾回收器组合参数设定：-1-8" class="headerlink" title="常见垃圾回收器组合参数设定：(1.8)"></a>常见垃圾回收器组合参数设定：(1.8)</h3><ul><li><p>-XX:+UseSerialGC = Serial New (DefNew) + Serial Old</p><ul><li>小型程序。默认情况下不会是这种选项，HotSpot会根据计算及配置和JDK版本自动选择收集器</li></ul></li><li><p>-XX:+UseParNewGC = ParNew + SerialOld</p><ul><li>这个组合已经很少用（在某些版本中已经废弃）</li><li><a href="https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future" target="_blank" rel="noopener">https://stackoverflow.com/questions/34962257/why-remove-support-for-parnewserialold-anddefnewcms-in-the-future</a></li></ul></li><li><p>-XX:+UseConc<font color="red">(urrent)</font>MarkSweepGC = ParNew + CMS + Serial Old</p></li><li><p>-XX:+UseParallelGC = Parallel Scavenge + Parallel Old (1.8默认) 【PS + SerialOld】</p></li><li><p>-XX:+UseParallelOldGC = Parallel Scavenge + Parallel Old</p></li><li><p>-XX:+UseG1GC = G1</p></li><li><p>Linux中没找到默认GC的查看方法，而windows中会打印UseParallelGC</p><ul><li>java +XX:+PrintCommandLineFlags -version</li><li>通过GC的日志来分辨</li></ul></li><li><p>Linux下1.8版本默认的垃圾回收器到底是什么？</p><ul><li>1.8.0_181 默认（看不出来）Copy MarkCompact</li><li>1.8.0_222 默认 PS + PO</li></ul></li></ul><h3 id="JVM调优第一步，了解JVM常用命令行参数"><a href="#JVM调优第一步，了解JVM常用命令行参数" class="headerlink" title="JVM调优第一步，了解JVM常用命令行参数"></a>JVM调优第一步，了解JVM常用命令行参数</h3><ul><li><p>JVM的命令行参数参考：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></p></li><li><p>HotSpot参数分类</p><blockquote><p>标准： - 开头，所有的HotSpot都支持</p><p>非标准：-X 开头，特定版本HotSpot支持特定命令</p><p>不稳定：-XX 开头，下个版本可能取消</p></blockquote><p>java -version</p><p>java -X</p></li></ul><p>java -XX:+PrintFlagsWithComments //只有debug版本能用</p><p>试验用程序：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">import</span> java.util.List;</span><br><span class="line">  <span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"HelloGC!"</span>);</span><br><span class="line">      List list = <span class="keyword">new</span> LinkedList();</span><br><span class="line">      <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">        list.add(b);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>区分概念：内存泄漏memory leak，内存溢出out of memory</li><li>java -XX:+PrintCommandLineFlags HelloGC</li><li>java -Xmn10M -Xms40M -Xmx60M -XX:+PrintCommandLineFlags -XX:+PrintGC HelloGC<br>PrintGCDetails PrintGCTimeStamps PrintGCCauses</li><li>java -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags HelloGC</li><li>java -XX:+PrintFlagsInitial 默认参数值</li><li>java -XX:+PrintFlagsFinal 最终参数值</li><li>java -XX:+PrintFlagsFinal | grep xxx 找到对应的参数</li><li>java -XX:+PrintFlagsFinal -version |grep GC</li><li>java -XX:+PrintFlagsFinal -version | wc -l<br>共728个参数</li></ol><h3 id="PS-GC日志详解"><a href="#PS-GC日志详解" class="headerlink" title="PS GC日志详解"></a>PS GC日志详解</h3><p>每种垃圾回收器的日志格式是不同的！</p><p>PS日志格式</p><p><img data-src="./GC%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3.png" alt="GC日志详解"></p><p>heap dump部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">eden space <span class="number">5632</span>K, <span class="number">94</span>% used [<span class="number">0x00000000ff980000</span>,<span class="number">0x00000000ffeb3e28</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line">                            后面的内存地址指的是，起始地址，使用空间结束地址，整体空间结束地址</span><br></pre></td></tr></table></figure><p>total = eden + 1个survivor</p><h3 id="调优前的基础概念："><a href="#调优前的基础概念：" class="headerlink" title="调优前的基础概念："></a>调优前的基础概念：</h3><ol><li>吞吐量：用户代码时间 /（用户代码执行时间 + 垃圾回收时间）</li><li>响应时间：STW越短，响应时间越好</li></ol><p>所谓调优，首先确定，追求啥？吞吐量优先，还是响应时间优先？还是在满足一定的响应时间的情况下，要求达到多大的吞吐量…</p><p>问题：</p><p>科学计算，吞吐量。数据挖掘，thrput。吞吐量优先的一般：（PS + PO）</p><p>响应时间：网站 GUI API （1.8 G1）</p><h3 id="什么是调优？"><a href="#什么是调优？" class="headerlink" title="什么是调优？"></a>什么是调优？</h3><ol><li>根据需求进行JVM规划和预调优</li><li>优化运行JVM运行环境（慢，卡顿）</li><li>解决JVM运行过程中出现的各种问题(OOM)</li></ol><h3 id="调优，从规划开始"><a href="#调优，从规划开始" class="headerlink" title="调优，从规划开始"></a>调优，从规划开始</h3><ul><li><p>调优，从业务场景开始，没有业务场景的调优都是耍流氓</p></li><li><p>无监控（压力测试，能看到结果），不调优</p></li><li><p>步骤：</p><ol><li>熟悉业务场景（没有最好的垃圾回收器，只有最合适的垃圾回收器）<ol><li>响应时间、停顿时间 [CMS G1 ZGC] （需要给用户作响应）</li><li>吞吐量 = 用户时间 /( 用户时间 + GC时间) [PS]</li></ol></li><li>选择回收器组合</li><li>计算内存需求（经验值 1.5G 16G）</li><li>选定CPU（越高越好）</li><li>设定年代大小、升级年龄</li><li>设定日志参数<ol><li>-Xloggc:/opt/xxx/logs/xxx-xxx-gc-%t.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=20M -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCCause</li><li>或者每天产生一个日志文件</li></ol></li><li>观察日志情况</li></ol></li><li><p>案例1：垂直电商，最高每日百万订单，处理订单系统需要什么样的服务器配置？</p><blockquote><p>这个问题比较业余，因为很多不同的服务器配置都能支撑(1.5G 16G)</p><p>1小时360000集中时间段， 100个订单/秒，（找一小时内的高峰期，1000订单/秒）</p><p>经验值，</p><p>非要计算：一个订单产生需要多少内存？512K * 1000 500M内存</p><p>专业一点儿问法：要求响应时间100ms</p><p>压测！</p></blockquote></li><li><p>案例2：12306遭遇春节大规模抢票应该如何支撑？</p><blockquote><p>12306应该是中国并发量最大的秒杀网站：</p><p>号称并发量100W最高</p><p>CDN -&gt; LVS -&gt; NGINX -&gt; 业务系统 -&gt; 每台机器1W并发（10K问题） 100台机器</p><p>普通电商订单 -&gt; 下单 -&gt;订单系统（IO）减库存 -&gt;等待用户付款</p><p>12306的一种可能的模型： 下单 -&gt; 减库存 和 订单(redis kafka) 同时异步进行 -&gt;等付款</p><p>减库存最后还会把压力压到一台服务器</p><p>可以做分布式本地库存 + 单独服务器做库存均衡</p><p>大流量的处理方法：分而治之</p></blockquote></li><li><p>怎么得到一个事务会消耗多少内存？</p><blockquote><ol><li><p>弄台机器，看能承受多少TPS？是不是达到目标？扩容或调优，让它达到</p></li><li><p>用压测来确定</p></li></ol></blockquote></li></ul><h3 id="优化环境"><a href="#优化环境" class="headerlink" title="优化环境"></a>优化环境</h3><ol><li>有一个50万PV的资料类网站（从磁盘提取文档到内存）原服务器32位，1.5G<br>的堆，用户反馈网站比较缓慢，因此公司决定升级，新的服务器为64位，16G<br>的堆内存，结果用户反馈卡顿十分严重，反而比以前效率更低了<ol><li>为什么原网站慢?<br>很多用户浏览数据，很多数据load到内存，内存不足，频繁GC，STW长，响应时间变慢</li><li>为什么会更卡顿？<br>内存越大，FGC时间越长</li><li>咋办？<br>PS -&gt; PN + CMS 或者 G1</li></ol></li><li>系统CPU经常100%，如何调优？(面试高频)<br>CPU100%那么一定有线程在占用系统资源，<ol><li>找出哪个进程cpu高（top）</li><li>该进程中的哪个线程cpu高（top -Hp）</li><li>导出该线程的堆栈 (jstack)</li><li>查找哪个方法（栈帧）消耗时间 (jstack)</li><li>工作线程占比高 | 垃圾回收线程占比高</li></ol></li><li>系统内存飙高，如何查找问题？（面试高频）<ol><li>导出堆内存 (jmap)</li><li>分析 (jhat jvisualvm mat jprofiler … )</li></ol></li><li>如何监控JVM<ol><li>jstat jvisualvm jprofiler arthas top…</li></ol></li></ol><h3 id="解决JVM运行中的问题"><a href="#解决JVM运行中的问题" class="headerlink" title="解决JVM运行中的问题"></a>解决JVM运行中的问题</h3><h4 id="一个案例理解常用工具"><a href="#一个案例理解常用工具" class="headerlink" title="一个案例理解常用工具"></a>一个案例理解常用工具</h4><ol><li><p>测试代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mashibing.jvm.gc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中读取信用数据，套用模型，并把结果进行记录和传输</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T15_FullGC_Problem01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CardInfo</span> </span>&#123;</span><br><span class="line">        BigDecimal price = <span class="keyword">new</span> BigDecimal(<span class="number">0.0</span>);</span><br><span class="line">        String name = <span class="string">"张三"</span>;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">5</span>;</span><br><span class="line">        Date birthdate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledThreadPoolExecutor executor = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">50</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        executor.setMaximumPoolSize(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">            modelFit();</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">modelFit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CardInfo&gt; taskList = getAllCardInfo();</span><br><span class="line">        taskList.forEach(info -&gt; &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">                <span class="comment">//do sth with info</span></span><br><span class="line">                info.m();</span><br><span class="line"></span><br><span class="line">            &#125;, <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;CardInfo&gt; <span class="title">getAllCardInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CardInfo&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            CardInfo ci = <span class="keyword">new</span> CardInfo();</span><br><span class="line">            taskList.add(ci);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> taskList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>java -Xms200M -Xmx200M -XX:+PrintGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p></li><li><p>一般是运维团队首先受到报警信息（CPU Memory）</p></li><li><p>top命令观察到问题：内存不断增长 CPU占用率居高不下</p></li><li><p>top -Hp 观察进程中的线程，哪个线程CPU和内存占比高</p></li><li><p>jps定位具体java进程<br>jstack 定位线程状况，重点关注：WAITING BLOCKED<br>eg.<br>waiting on &lt;0x0000000088ca3310&gt; (a java.lang.Object)<br>假如有一个进程中100个线程，很多线程都在waiting on<xx>，一定要找到是哪个线程持有这把锁<br>怎么找？搜索jstack dump的信息，找<xx>，看哪个线程持有这把锁RUNNABLE<br>作业：1：写一个死锁程序，用jstack观察 2 ：写一个程序，一个线程持有锁不释放，其他线程等待</xx></xx></p></li><li><p>为什么阿里规范里规定，线程的名称（尤其是线程池）都要写有意义的名称<br>怎么样自定义线程池里的线程名称？（自定义ThreadFactory）</p></li><li><p>jinfo pid</p></li><li><p>jstat -gc 动态观察gc情况 / 阅读GC日志发现频繁GC / arthas观察 / jconsole/jvisualVM/ Jprofiler（最好用）<br>jstat -gc 4655 500 : 每个500个毫秒打印GC的情况<br>如果面试官问你是怎么定位OOM问题的？如果你回答用图形界面（错误）<br>1：已经上线的系统不用图形界面用什么？（cmdline arthas）<br>2：图形界面到底用在什么地方？测试！测试的时候进行监控！（压测观察）</p></li><li><p>jmap - histo 4655 | head -20，查找有多少对象产生</p></li><li><p>jmap -dump:format=b,file=xxx pid ：</p><p>线上系统，内存特别大，jmap执行期间会对进程产生很大影响，甚至卡顿（电商不适合）<br>1：设定了参数HeapDump，OOM的时候会自动产生堆转储文件（不是很专业，因为多有监控，内存增长就会报警）<br>2：<font color="red">很多服务器备份（高可用），停掉这台服务器对其他服务器不影响</font><br>3：在线定位(一般小点儿公司用不到)</p><p>4：在测试环境中压测（产生类似内存增长问题，在堆还不是很大的时候进行转储）</p></li><li><p>java -Xms20M -Xmx20M -XX:+UseParallelGC -XX:+HeapDumpOnOutOfMemoryError com.mashibing.jvm.gc.T15_FullGC_Problem01</p></li><li><p>使用MAT / jhat /jvisualvm 进行dump文件分析<br><a href="https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html" target="_blank" rel="noopener">https://www.cnblogs.com/baihuitestsoftware/articles/6406271.html</a><br>jhat -J-mx512M xxx.dump<br><a href="http://192.168.17.11:7000" target="_blank" rel="noopener">http://192.168.17.11:7000</a><br>拉到最后：找到对应链接<br>可以使用OQL查找特定问题对象</p></li><li><p>找到代码的问题</p></li></ol><h4 id="jconsole远程连接"><a href="#jconsole远程连接" class="headerlink" title="jconsole远程连接"></a>jconsole远程连接</h4><ol><li><p>程序启动加入参数：</p><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=192.168.17.11 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=11111 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false XXX</span><br></pre></td></tr></table></figure></blockquote></li><li><p>如果遭遇 Local host name unknown：XXX的错误，修改/etc/hosts文件，把XXX加入进去</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">192.168</span><span class="number">.17</span><span class="number">.11</span> basic localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::<span class="number">1</span>         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br></pre></td></tr></table></figure></blockquote></li><li><p>关闭linux防火墙（实战中应该打开对应端口）</p><blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service iptables stop</span><br><span class="line">chkconfig iptables off #永久关闭</span><br></pre></td></tr></table></figure></blockquote></li><li><p>windows上打开 jconsole远程连接 192.168.17.11:11111</p></li></ol><h4 id="jvisualvm远程连接"><a href="#jvisualvm远程连接" class="headerlink" title="jvisualvm远程连接"></a>jvisualvm远程连接</h4><p><a href="https://www.cnblogs.com/liugh/p/7620336.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugh/p/7620336.html</a> （简单做法）</p><h4 id="jprofiler-收费"><a href="#jprofiler-收费" class="headerlink" title="jprofiler (收费)"></a>jprofiler (收费)</h4><h4 id="arthas在线排查工具"><a href="#arthas在线排查工具" class="headerlink" title="arthas在线排查工具"></a>arthas在线排查工具</h4><ul><li>为什么需要在线排查？<br>在生产上我们经常会碰到一些不好排查的问题，例如线程安全问题，用最简单的threaddump或者heapdump不好查到问题原因。为了排查这些问题，有时我们会临时加一些日志，比如在一些关键的函数里打印出入参，然后重新打包发布，如果打了日志还是没找到问题，继续加日志，重新打包发布。对于上线流程复杂而且审核比较严的公司，从改代码到上线需要层层的流转，会大大影响问题排查的进度。</li><li>jvm观察jvm信息</li><li>thread定位线程问题</li><li>dashboard 观察系统情况</li><li>heapdump + jhat分析</li><li>jad反编译<br>动态代理生成类的问题定位<br>第三方的类（观察代码）<br>版本问题（确定自己最新提交的版本是不是被使用）</li><li>redefine 热替换<br>目前有些限制条件：只能改方法实现（方法已经运行完成），不能改方法名， 不能改属性<br>m() -&gt; mm()</li><li>sc - search class</li><li>watch - watch method</li><li>没有包含的功能：jmap</li></ul><h3 id="GC算法的基础概念"><a href="#GC算法的基础概念" class="headerlink" title="GC算法的基础概念"></a>GC算法的基础概念</h3><ul><li>Card Table<br>由于做YGC时，需要扫描整个OLD区，效率非常低，所以JVM设计了CardTable， 如果一个OLD区CardTable中有对象指向Y区，就将它设为Dirty，下次扫描时，只需要扫描Dirty Card<br>在结构上，Card Table用BitMap来实现</li></ul><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><h4 id="CMS的问题"><a href="#CMS的问题" class="headerlink" title="CMS的问题"></a>CMS的问题</h4><ol><li><p>Memory Fragmentation</p><blockquote><p>-XX:+UseCMSCompactAtFullCollection<br>-XX:CMSFullGCsBeforeCompaction 默认为0 指的是经过多少次FGC才进行压缩</p></blockquote></li><li><p>Floating Garbage</p><blockquote><p>Concurrent Mode Failure<br>产生：if the concurrent collector is unable to finish reclaiming the unreachable objects before the tenured generation fills up, or if an allocation cannot be satisfiedwith the available free space blocks in the tenured generation, then theapplication is paused and the collection is completed with all the applicationthreads stopped</p><p>解决方案：降低触发CMS的阈值</p><p>PromotionFailed</p><p>解决方案类似，保持老年代有足够的空间</p><p>–XX:CMSInitiatingOccupancyFraction 92% 可以降低这个值，让CMS保持老年代足够的空间</p></blockquote></li></ol><h4 id="CMS日志分析"><a href="#CMS日志分析" class="headerlink" title="CMS日志分析"></a>CMS日志分析</h4><p>执行命令：java -Xms20M -Xmx20M -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC com.mashibing.jvm.gc.T15_FullGC_Problem01</p><p>[GC (Allocation Failure) [ParNew: 6144K-&gt;640K(6144K), 0.0265885 secs] 6585K-&gt;2770K(19840K), 0.0268035 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</p><blockquote><p>ParNew：年轻代收集器</p><p>6144-&gt;640：收集前后的对比</p><p>（6144）：整个年轻代容量</p><p>6585 -&gt; 2770：整个堆的情况</p><p>（19840）：整个堆大小</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[GC (CMS Initial Mark) [<span class="number">1</span> CMS-initial-mark: <span class="number">8511</span>K(<span class="number">13696</span>K)] <span class="number">9866</span>K(<span class="number">19840</span>K), <span class="number">0.0040321</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//8511 (13696) : 老年代使用（最大）</span></span><br><span class="line">	<span class="comment">//9866 (19840) : 整个堆使用（最大）</span></span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">[CMS-concurrent-mark: <span class="number">0.018</span>/<span class="number">0.018</span> secs] [Times: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs] </span><br><span class="line">	<span class="comment">//这里的时间意义不大，因为是并发执行</span></span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">	<span class="comment">//标记Card为Dirty，也称为Card Marking</span></span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 1597 K (6144 K)][Rescan (parallel) , 0.0008396 secs][weak refs processing, 0.0000138 secs][class unloading, 0.0005404 secs][scrub symbol table, 0.0006169 secs][scrub string table, 0.0004903 secs][1 CMS-remark: 8511K(13696K)] 10108K(19840K), 0.0039567 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">	<span class="comment">//STW阶段，YG occupancy:年轻代占用及容量</span></span><br><span class="line">	<span class="comment">//[Rescan (parallel)：STW下的存活对象标记</span></span><br><span class="line">	<span class="comment">//weak refs processing: 弱引用处理</span></span><br><span class="line">	<span class="comment">//class unloading: 卸载用不到的class</span></span><br><span class="line">	<span class="comment">//scrub symbol(string) table: </span></span><br><span class="line">		<span class="comment">//cleaning up symbol and string tables which hold class-level metadata and </span></span><br><span class="line">		<span class="comment">//internalized string respectively</span></span><br><span class="line">	<span class="comment">//CMS-remark: 8511K(13696K): 阶段过后的老年代占用及容量</span></span><br><span class="line">	<span class="comment">//10108K(19840K): 阶段过后的堆占用及容量</span></span><br><span class="line"></span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: <span class="number">0.005</span>/<span class="number">0.005</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">	<span class="comment">//标记已经完成，进行并发清理</span></span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: <span class="number">0.000</span>/<span class="number">0.000</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">	<span class="comment">//重置内部结构，为下次GC做准备</span></span><br></pre></td></tr></table></figure><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><ol><li>▪<a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html" target="_blank" rel="noopener">https://www.oracle.com/technical-resources/articles/java/g1gc.html</a></li></ol><h4 id="G1日志详解"><a href="#G1日志详解" class="headerlink" title="G1日志详解"></a>G1日志详解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[<span class="function">GC <span class="title">pause</span> <span class="params">(G1 Evacuation Pause)</span> <span class="params">(young)</span> <span class="params">(initial-mark)</span>, 0.0015790 secs]</span></span><br><span class="line"><span class="function"><span class="comment">//young -&gt; 年轻代 Evacuation-&gt; 复制存活对象 </span></span></span><br><span class="line"><span class="function"><span class="comment">//initial-mark 混合回收的阶段，这里是YGC混合老年代回收</span></span></span><br><span class="line"><span class="function">   [Parallel Time: 1.5 ms, GC Workers: 1] <span class="comment">//一个GC线程</span></span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Start</span> <span class="params">(ms)</span>:  92635.7]</span></span><br><span class="line"><span class="function">      [Ext Root <span class="title">Scanning</span> <span class="params">(ms)</span>:  1.1]</span></span><br><span class="line"><span class="function">      [Update <span class="title">RS</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">         [Processed Buffers:  1]</span></span><br><span class="line"><span class="function">      [Scan <span class="title">RS</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [Code Root <span class="title">Scanning</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [Object <span class="title">Copy</span> <span class="params">(ms)</span>:  0.1]</span></span><br><span class="line"><span class="function">      [<span class="title">Termination</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">         [Termination Attempts:  1]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Other</span> <span class="params">(ms)</span>:  0.0]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">Total</span> <span class="params">(ms)</span>:  1.2]</span></span><br><span class="line"><span class="function">      [GC Worker <span class="title">End</span> <span class="params">(ms)</span>:  92636.9]</span></span><br><span class="line"><span class="function">   [Code Root Fixup: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Code Root Purge: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Clear CT: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Other: 0.1 ms]</span></span><br><span class="line"><span class="function">      [Choose CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Proc: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Ref Enq: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Redirty Cards: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Humongous Register: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Humongous Reclaim: 0.0 ms]</span></span><br><span class="line"><span class="function">      [Free CSet: 0.0 ms]</span></span><br><span class="line"><span class="function">   [Eden: 0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>-&gt;18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>]</span></span><br><span class="line"><span class="function"> [Times: user</span>=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line"><span class="comment">//以下是混合回收其他阶段</span></span><br><span class="line">[GC concurrent-root-region-scan-start]</span><br><span class="line">[GC concurrent-root-region-scan-end, <span class="number">0.0000078</span> secs]</span><br><span class="line">[GC concurrent-mark-start]</span><br><span class="line"><span class="comment">//无法evacuation，进行FGC</span></span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Allocation Failure)</span>  18M-&gt;18<span class="title">M</span><span class="params">(<span class="number">20</span>M)</span>, 0.0719656 secs]</span></span><br><span class="line"><span class="function">   [Eden: 0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span>-&gt;0.0<span class="title">B</span><span class="params">(<span class="number">1024.0</span>K)</span> Survivors: 0.0B-&gt;0.0B Heap: 18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>-&gt;18.8<span class="title">M</span><span class="params">(<span class="number">20.0</span>M)</span>], [Metaspace: 38</span></span><br><span class="line"><span class="function">76K-&gt;3876<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>] [Times: user</span>=<span class="number">0.07</span> sys=<span class="number">0.00</span>, real=<span class="number">0.07</span> secs]</span><br></pre></td></tr></table></figure><h3 id="案例汇总"><a href="#案例汇总" class="headerlink" title="案例汇总"></a>案例汇总</h3><p>OOM产生的原因多种多样，有些程序未必产生OOM，不断FGC(CPU飙高，但内存回收特别少) （上面案例）</p><ol><li><p>硬件升级系统反而卡顿的问题（见上）</p></li><li><p>线程池不当运用产生OOM问题（见上）<br>不断的往List里加对象（实在太LOW）</p></li><li><p>smile jira问题<br>实际系统不断重启<br>解决问题 加内存 + 更换垃圾回收器 G1<br>真正问题在哪儿？不知道</p></li><li><p>tomcat http-header-size过大问题（Hector）</p></li><li><p>lambda表达式导致方法区溢出问题(MethodArea / Perm Metaspace)<br>LambdaGC.java -XX:MaxMetaspaceSize=9M -XX:+PrintGCDetails</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">"C:\Program Files\Java\jdk1.8.0_181\bin\java.exe"</span> -XX:MaxMetaspaceSize=<span class="number">9</span>M -XX:+PrintGCDetails <span class="string">"-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\lib\idea_rt.jar=49316:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2019.1\bin"</span> -Dfile.encoding=UTF-<span class="number">8</span> -classpath <span class="string">"C:\Program Files\Java\jdk1.8.0_181\jre\lib\charsets.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\deploy.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\access-bridge-64.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\cldrdata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\dnsns.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jaccess.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\jfxrt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\localedata.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\nashorn.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunec.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunjce_provider.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunmscapi.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\sunpkcs11.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\ext\zipfs.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\javaws.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jce.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfr.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jfxswt.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\jsse.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\management-agent.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\plugin.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\resources.jar;C:\Program Files\Java\jdk1.8.0_181\jre\lib\rt.jar;C:\work\ijprojects\JVM\out\production\JVM;C:\work\ijprojects\ObjectSize\out\artifacts\ObjectSize_jar\ObjectSize.jar"</span> com.mashibing.jvm.gc.LambdaGC</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen: <span class="number">11341</span>K-&gt;<span class="number">1880</span>K(<span class="number">38400</span>K)] <span class="number">11341</span>K-&gt;<span class="number">1888</span>K(<span class="number">125952</span>K), <span class="number">0.0022190</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 1880K-&gt;0<span class="title">K</span><span class="params">(<span class="number">38400</span>K)</span>] [ParOldGen: 8K-&gt;1777<span class="title">K</span><span class="params">(<span class="number">35328</span>K)</span>] 1888K-&gt;1777<span class="title">K</span><span class="params">(<span class="number">73728</span>K)</span>, [Metaspace: 8164K-&gt;8164<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0100681 secs] [Times: user</span>=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">[GC (Last ditch collection) [PSYoungGen: <span class="number">0</span>K-&gt;<span class="number">0</span>K(<span class="number">38400</span>K)] <span class="number">1777</span>K-&gt;<span class="number">1777</span>K(<span class="number">73728</span>K), <span class="number">0.0005698</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </span><br><span class="line">[<span class="function">Full <span class="title">GC</span> <span class="params">(Last ditch collection)</span> [PSYoungGen: 0K-&gt;0<span class="title">K</span><span class="params">(<span class="number">38400</span>K)</span>] [ParOldGen: 1777K-&gt;1629<span class="title">K</span><span class="params">(<span class="number">67584</span>K)</span>] 1777K-&gt;1629<span class="title">K</span><span class="params">(<span class="number">105984</span>K)</span>, [Metaspace: 8164K-&gt;8156<span class="title">K</span><span class="params">(<span class="number">1056768</span>K)</span>], 0.0124299 secs] [Times: user</span>=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndStartAgent(InstrumentationImpl.java:<span class="number">388</span>)</span><br><span class="line">	at sun.instrument.InstrumentationImpl.loadClassAndCallAgentmain(InstrumentationImpl.java:<span class="number">411</span>)</span><br><span class="line">Caused by: java.lang.OutOfMemoryError: Compressed <span class="class"><span class="keyword">class</span> <span class="title">space</span></span></span><br><span class="line"><span class="class">	<span class="title">at</span> <span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Unsafe</span>.<span class="title">defineClass</span>(<span class="title">Native</span> <span class="title">Method</span>)</span></span><br><span class="line">	at sun.reflect.ClassDefiner.defineClass(ClassDefiner.java:63)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1</span>.run(MethodAccessorGenerator.java:<span class="number">399</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator$<span class="number">1</span>.run(MethodAccessorGenerator.java:<span class="number">394</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generate(MethodAccessorGenerator.java:<span class="number">393</span>)</span><br><span class="line">	at sun.reflect.MethodAccessorGenerator.generateSerializationConstructor(MethodAccessorGenerator.java:<span class="number">112</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.generateConstructor(ReflectionFactory.java:<span class="number">398</span>)</span><br><span class="line">	at sun.reflect.ReflectionFactory.newConstructorForSerialization(ReflectionFactory.java:<span class="number">360</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.getSerializableConstructor(ObjectStreamClass.java:<span class="number">1574</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.access$<span class="number">1500</span>(ObjectStreamClass.java:<span class="number">79</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3</span>.run(ObjectStreamClass.java:<span class="number">519</span>)</span><br><span class="line">	at java.io.ObjectStreamClass$<span class="number">3</span>.run(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.security.AccessController.doPrivileged(Native Method)</span><br><span class="line">	at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:<span class="number">494</span>)</span><br><span class="line">	at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:<span class="number">391</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1134</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:<span class="number">1548</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:<span class="number">1509</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:<span class="number">1432</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:<span class="number">1178</span>)</span><br><span class="line">	at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:<span class="number">348</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeJRMPStub(RMIConnectorServer.java:<span class="number">727</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStub(RMIConnectorServer.java:<span class="number">719</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.encodeStubInAddress(RMIConnectorServer.java:<span class="number">690</span>)</span><br><span class="line">	at javax.management.remote.rmi.RMIConnectorServer.start(RMIConnectorServer.java:<span class="number">439</span>)</span><br><span class="line">	at sun.management.jmxremote.ConnectorBootstrap.startLocalConnectorServer(ConnectorBootstrap.java:<span class="number">550</span>)</span><br><span class="line">	at sun.management.Agent.startLocalManagementAgent(Agent.java:<span class="number">137</span>)</span><br></pre></td></tr></table></figure></li><li><p>直接内存溢出问题（少见）<br>《深入理解Java虚拟机》P59，使用Unsafe分配直接内存，或者使用NIO的问题</p></li><li><p>栈溢出问题<br>-Xss设定太小</p></li><li><p>比较一下这两段程序的异同，分析哪一个是更优的写法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    o = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//业务处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重写finalize引发频繁GC<br>小米云，HBase同步系统，系统通过nginx访问超时报警，最后排查，C++程序员重写finalize引发频繁GC问题<br>为什么C++程序员会重写finalize？（new delete）<br>finalize耗时比较长（200ms）</p></li><li><p>如果有一个系统，内存一直消耗不超过10%，但是观察GC日志，发现FGC总是频繁产生，会是什么引起的？<br>System.gc() (这个比较Low)</p></li><li><p>Distuptor有个可以设置链的长度，如果过大，然后对象大，消费完不主动释放，会溢出 (来自 死物风情)</p></li><li><p>用jvm都会溢出，mycat用崩过，1.6.5某个临时版本解析sql子查询算法有问题，9个exists的联合sql就导致生成几百万的对象（来自 死物风情）</p></li><li><p>new 大量线程，会产生 native thread OOM，（low）应该用线程池，<br>解决方案：减少堆空间（太TMlow了）,预留更多内存产生native thread<br>JVM内存占物理内存比例 50% - 80%</p></li></ol><h3 id="GC常用参数"><a href="#GC常用参数" class="headerlink" title="GC常用参数"></a>GC常用参数</h3><ul><li>-Xmn -Xms -Xmx -Xss<br>年轻代 最小堆 最大堆 栈空间</li><li>-XX:+UseTLAB<br>使用TLAB，默认打开</li><li>-XX:+PrintTLAB<br>打印TLAB的使用情况</li><li>-XX:TLABSize<br>设置TLAB大小</li><li>-XX:+DisableExplictGC<br>System.gc()不管用 ，FGC</li><li>-XX:+PrintGC</li><li>-XX:+PrintGCDetails</li><li>-XX:+PrintHeapAtGC</li><li>-XX:+PrintGCTimeStamps</li><li>-XX:+PrintGCApplicationConcurrentTime (低)<br>打印应用程序时间</li><li>-XX:+PrintGCApplicationStoppedTime （低）<br>打印暂停时长</li><li>-XX:+PrintReferenceGC （重要性低）<br>记录回收了多少种不同引用类型的引用</li><li>-verbose:class<br>类加载详细过程</li><li>-XX:+PrintVMOptions</li><li>-XX:+PrintFlagsFinal -XX:+PrintFlagsInitial<br>必须会用</li><li>-Xloggc:opt/log/gc.log</li><li>-XX:MaxTenuringThreshold<br>升代年龄，最大值15</li><li>锁自旋次数 -XX:PreBlockSpin 热点代码检测参数-XX:CompileThreshold 逃逸分析 标量替换 …<br>这些不建议设置</li></ul><h3 id="Parallel常用参数"><a href="#Parallel常用参数" class="headerlink" title="Parallel常用参数"></a>Parallel常用参数</h3><ul><li>-XX:SurvivorRatio</li><li>-XX:PreTenureSizeThreshold<br>大对象到底多大</li><li>-XX:MaxTenuringThreshold</li><li>-XX:+ParallelGCThreads<br>并行收集器的线程数，同样适用于CMS，一般设为和CPU核数相同</li><li>-XX:+UseAdaptiveSizePolicy<br>自动选择各区大小比例</li></ul><h3 id="CMS常用参数"><a href="#CMS常用参数" class="headerlink" title="CMS常用参数"></a>CMS常用参数</h3><ul><li>-XX:+UseConcMarkSweepGC</li><li>-XX:ParallelCMSThreads<br>CMS线程数量</li><li>-XX:CMSInitiatingOccupancyFraction<br>使用多少比例的老年代后开始CMS收集，默认是68%(近似值)，如果频繁发生SerialOld卡顿，应该调小，（频繁CMS回收）</li><li>-XX:+UseCMSCompactAtFullCollection<br>在FGC时进行压缩</li><li>-XX:CMSFullGCsBeforeCompaction<br>多少次FGC之后进行压缩</li><li>-XX:+CMSClassUnloadingEnabled</li><li>-XX:CMSInitiatingPermOccupancyFraction<br>达到什么比例时进行Perm回收</li><li>GCTimeRatio<br>设置GC时间占用程序运行时间的百分比</li><li>-XX:MaxGCPauseMillis<br>停顿时间，是一个建议时间，GC会尝试用各种手段达到这个时间，比如减小年轻代</li></ul><h3 id="G1常用参数"><a href="#G1常用参数" class="headerlink" title="G1常用参数"></a>G1常用参数</h3><ul><li>-XX:+UseG1GC</li><li>-XX:MaxGCPauseMillis<br>建议值，G1会尝试调整Young区的块数来达到这个值</li><li>-XX:GCPauseIntervalMillis<br>？GC的间隔时间</li><li>-XX:+G1HeapRegionSize<br>分区大小，建议逐渐增大该值，1 2 4 8 16 32。<br>随着size增加，垃圾的存活时间更长，GC间隔更长，但每次GC的时间也会更长<br>ZGC做了改进（动态区块大小）</li><li>G1NewSizePercent<br>新生代最小比例，默认为5%</li><li>G1MaxNewSizePercent<br>新生代最大比例，默认为60%</li><li>GCTimeRatio<br>GC时间建议比例，G1会根据这个值调整堆空间</li><li>ConcGCThreads<br>线程数量</li><li>InitiatingHeapOccupancyPercent<br>启动G1的堆空间占用比例</li></ul><h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><ol><li><p>-XX:MaxTenuringThreshold控制的是什么？<br>A: 对象升入老年代的年龄</p><pre><code>B: 老年代触发FGC时的内存垃圾比例</code></pre></li><li><p>生产环境中，倾向于将最大堆内存和最小堆内存设置为：（为什么？）<br>A: 相同 B：不同</p></li><li><p>JDK1.8默认的垃圾回收器是：<br>A: ParNew + CMS</p><pre><code>B: G1
C: PS + ParallelOld
D: 以上都不是</code></pre></li><li><p>什么是响应时间优先？</p></li><li><p>什么是吞吐量优先？</p></li><li><p>ParNew和PS的区别是什么？</p></li><li><p>ParNew和ParallelOld的区别是什么？（年代不同，算法不同）</p></li><li><p>长时间计算的场景应该选择：A：停顿时间 B: 吞吐量</p></li><li><p>大规模电商网站应该选择：A：停顿时间 B: 吞吐量</p></li><li><p>HotSpot的垃圾收集器最常用有哪些？</p></li><li><p>常见的HotSpot垃圾收集器组合有哪些？</p></li><li><p>JDK1.7 1.8 1.9的默认垃圾回收器是什么？如何查看？</p></li><li><p>所谓调优，到底是在调什么？</p></li><li><p>如果采用PS + ParrallelOld组合，怎么做才能让系统基本不产生FGC</p></li><li><p>如果采用ParNew + CMS组合，怎样做才能够让系统基本不产生FGC</p><p>1.加大JVM内存</p><p>2.加大Young的比例</p><p>3.提高Y-O的年龄</p><p>4.提高S区比例</p><p>5.避免代码内存泄漏</p></li><li><p>G1是否分代？G1垃圾回收器会产生FGC吗？</p></li><li><p>如果G1产生FGC，你应该做什么？</p><ol><li>扩内存</li><li>提高CPU性能（回收的快，业务逻辑产生对象的速度固定，垃圾回收越快，内存空间越大）</li><li>降低MixedGC触发的阈值，让MixedGC提早发生（默认是45%）</li></ol><ol start="18"><li><p>问：生产环境中能够随随便便的dump吗？<br>小堆影响不大，大堆会有服务暂停或卡顿（加live可以缓解），dump前会有FGC</p></li><li><p>问：常见的OOM问题有哪些？<br>栈 堆 MethodArea 直接内存</p></li></ol></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">https://blogs.oracle.com/</a><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">jonthecollector</a><a href="https://blogs.oracle.com/jonthecollector/our-collectors" target="_blank" rel="noopener">/our-collectors</a></li><li><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html</a></li><li><a href="http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp" target="_blank" rel="noopener">http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp</a></li><li>JVM调优参考文档：<a href="https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/13/gctuning/introduction-garbage-collection-tuning.html#GUID-8A443184-7E07-4B71-9777-4F12947C8184</a></li><li><a href="https://www.cnblogs.com/nxlhero/p/11660854.html" target="_blank" rel="noopener">https://www.cnblogs.com/nxlhero/p/11660854.html</a> 在线排查工具</li><li><a href="https://www.jianshu.com/p/507f7e0cc3a3" target="_blank" rel="noopener">https://www.jianshu.com/p/507f7e0cc3a3</a> arthas常用命令</li><li>Arthas手册：<ol><li>启动arthas java -jar arthas-boot.jar</li><li>绑定java进程</li><li>dashboard命令观察系统整体情况</li><li>help 查看帮助</li><li>help xx 查看具体命令帮助</li></ol></li><li>jmap命令参考： <a href="https://www.jianshu.com/p/507f7e0cc3a3" target="_blank" rel="noopener">https://www.jianshu.com/p/507f7e0cc3a3</a><ol><li>jmap -heap pid</li><li>jmap -histo pid</li><li>jmap -clstats pid</li></ol></li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Thymeleaf</title>
    <url>/sr/post/2020-04-14-%E6%9D%82%E9%A1%B9-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E-2020-04-14-Thymeleaf/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。</p><p>FreeMarker是一个用Java语言编写的模板引擎，它基于模板来生成文本输出。FreeMarker与Web容器无关，即在Web运行时，它并不知道Servlet或HTTP。它不仅可以用作表现层的实现技术，而且还可以用于生成XML，JSP或Java 等，在spring4.0中推荐使用thymeleaf来做前端模版引擎。<br>2、JSP技术spring boot 官方是不推荐的，原因有三：<br>2.1. 在tomcat上，jsp不能在嵌套的tomcat容器解析即不能在打包成可执行的jar的情况下解析<br>2.2. Jetty 嵌套的容器不支持jsp<br>2.3. Undertow<br>3、反正就是spring推荐themleaf，就学学themleaf。</p><h3 id="同类技术对比"><a href="#同类技术对比" class="headerlink" title="同类技术对比"></a>同类技术对比</h3><h4 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h4><p>优点：<br>1、功能强大，可以写java代码<br>2、支持jsp标签（jsp tag）<br>3、支持表达式语言（el）<br>4、官方标准，用户群广，丰富的第三方jsp标签库<br>5、性能良好。jsp编译成class文件执行，有很好的性能表现<br>缺点：<br>jsp没有明显缺点，非要挑点骨头那就是，由于可以编写java代码，如使用不当容易破坏mvc结构。</p><h4 id="Velocity"><a href="#Velocity" class="headerlink" title="Velocity"></a>Velocity</h4><p>优点：<br>1、不能编写java代码，可以实现严格的mvc分离<br>2、性能良好，据说比jsp性能还要好些<br>3、使用表达式语言，据说jsp的表达式语言就是学velocity的<br>缺点：<br>1、不是官方标准<br>2、用户群体和第三方标签库没有jsp多。<br>3、对jsp标签支持不够好<br>4、已经很久很久没有维护了。</p><h4 id="Freemarker"><a href="#Freemarker" class="headerlink" title="Freemarker"></a>Freemarker</h4><p>优点：<br>1、不能编写java代码，可以实现严格的mvc分离<br>2、性能非常不错<br>3、对jsp标签支持良好<br>4、内置大量常用功能，使用非常方便<br>5、宏定义（类似jsp标签）非常方便<br>6、使用表达式语言<br>缺点：<br>1、不是官方标准<br>2、用户群体和第三方标签库没有jsp多</p><p>选择freemarker的原因：<br>1、性能。velocity应该是最好的，其次是jsp，普通的页面freemarker性能最差（虽然只是几毫秒到十几毫秒的差距）。但是在复杂页面上（包含大量判断、日期金额格式化）的页面上，freemarker的性能比使用tag和el的jsp好。<br>2、宏定义比jsp tag方便<br>3、内置大量常用功能。比如html过滤，日期金额格式化等等，使用非常方便<br>4、支持jsp标签<br>5、可以实现严格的mvc分离</p><h4 id="Thymeleaf-1"><a href="#Thymeleaf-1" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h4><p>Thymeleaf是个XML/XHTML/HTML5模板引擎，可以用于Web与非Web应用。<br>Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。Thymeleaf的可扩展性也非常棒。你可以使用它定义自己的模板属性集合，这样就可以计算自定义表达式并使用自定义逻辑。这意味着Thymeleaf还可以作为模板引擎框架。</p><p>Thymeleaf</p><p>优点：静态html嵌入标签属性，浏览器可以直接打开模板文件，便于前后端联调，SprinBoot 官方推荐方案。<br>缺点：模板必须符合xml规范</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>模板引擎</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch</title>
    <url>/sr/post/2020-04-13-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF-2020-04-13-Elasticsearch/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="Ik分词器"><a href="#Ik分词器" class="headerlink" title="Ik分词器"></a>Ik分词器</h3><p>ik_max_word和 ik_smart介绍</p><p>学习过Solr或Elasticsearch的同学都知道IK分词器，它是一个针对中文的分词器。<br>IK分词器地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik</a><br>IK分词器有两种分词模式：ik_max_word和ik_smart模式。</p><p>1、ik_max_word</p><p>会将文本做最细粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为“中华人民共和国、中华人民、中华、华人、人民共和国、人民、共和国、大会堂、大会、会堂等词语。</p><p>2、ik_smart<br>会做最粗粒度的拆分，比如会将“中华人民共和国人民大会堂”拆分为中华人民共和国、人民大会堂。</p><p>测试两种分词模式的效果：</p><p>发送：post localhost:9200/_analyze<br>测试ik_max_word<br>{“text”:“中华人民共和国人民大会堂”,“analyzer”:“ik_max_word” }<br>测试ik_smart<br>{“text”:“中华人民共和国人民大会堂”,“analyzer”:“ik_smart” }</p><p>最佳实践<br>两种分词器使用的最佳实践是：索引时用ik_max_word，在搜索时用ik_smart。<br>即：索引时最大化的将文章内容分词，搜索时更精确的搜索到想要的结果。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Cluster</p><p>代表一个集群，集群中有多个节点，其中有一个为主节点，这个主节点是可以通过选举产生的，主从节点是对于集群内部来说的。es的一个概念就是去中心化，字面上理解就是无中心节点，这是对于集群外部来说的，因为从外部来看es集群，在逻辑上是个整体，你与任何一个节点的通信和与整个es集群通信是等价的。</p><p>Shards<br>代表索引分片，es可以把一个完整的索引分成多个分片，这样的好处是可以把一个大的索引拆分成多个，分布到不同的节点上。构成分布式搜索。分片的数量只能在索引创建前指定，并且索引创建后不能更改。</p><p>replicas<br>代表索引副本，es可以设置多个索引的副本，副本的作用一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复。二是提高es的查询效率，es会自动对搜索请求进行负载均衡。</p><p>Recovery<br>代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>中间件技术</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker</title>
    <url>/sr/post/2020-04-01-%E8%99%9A%E6%8B%9F%E5%8C%96%E4%B8%8E%E5%AE%B9%E5%99%A8%E5%8C%96-2020-04-01-Docker/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><ul><li><p>SaaS：Software-as-a-Service（软件即服务）提供给客户的服务是运营商运行在云计算基础设施上的应用程序，用户可以在各种设备上通过客户端界面访问，如浏览器。消费者不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等等；</p></li><li><p>PaaS：Platform-as-a-Service（平台即服务）提供给消费者的服务是把客户采用提供的开发语言和工具（例如Java，python, .Net等）开发的或收购的应用程序部署到供应商的云计算基础设施上去。</p></li></ul><p>客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但客户能控制部署的应用程序，也可能控制运行应用程序的托管环境配置；</p><ul><li>IaaS： Infrastructure-as-a-Service（基础设施即服务）提供给消费者的服务是对所有计算基础设施的利用，包括处理CPU、内存、存储、网络和其它基本的计算资源，用户能够部署和运行任意软件，包括操作系统和应用程序。</li></ul><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>起源：Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。</p><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p><p>架构：Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>VMware Workstation Pro + CentOS 7</p><ul><li>安装 CentOS 7 (Linux内核3.10)</li><li>查看内核版本</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[admin@juejun ~]$ uname -r</span><br><span class="line">3.10.0-693.el7.x86_64</span><br></pre></td></tr></table></figure><ul><li>更新 yum，这一步可能会让你输入密码，此时密码位数是不可见的，过程中如果出现什么错误，百度解决后重新执行即可，出现y/n，直接 y 回车 （可以使用 su 命令直接切换为 root 用户，使用 exit 即可退出）</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[admin@juejun ~]$ sudo yum update</span><br></pre></td></tr></table></figure><ul><li>安装docker</li></ul><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[admin@juejun ~]$ sudo yum install docker</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>虚拟化与容器化</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Lucene</title>
    <url>/sr/post/2020-03-28-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF-2020-03-28-Lucene/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>Lucene是apache软件基金会发布的一个开放源代码的全文检索引擎工具包，由资深全文检索专家Doug Cutting所撰写,它是一个全文检索引擎的架构，提供了完整的创建索引和查询索引，以及部分文本分析的引擎，Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎，Lucene在全文检索领域是一个经典的祖先，现在很多检索引擎都是在其基础上创建的，思想是相通的。</p><h3 id="Lucene"><a href="#Lucene" class="headerlink" title="Lucene"></a>Lucene</h3><p>Lucene 解决的是我们在站内根据文本关键字来进行搜索数据时，避免像查询数据库时带来的响应缓慢的问题。</p><p>索引库=索引域（词汇表）+文档域（原始记录）</p><p>文档域：文档域存储的信息就是采集到的信息，通过Document对象来存储，具体说是通过Document对象中Field域来存储数据。比如：数据库中一条记录会存储一个一个Document对象，数据库中一列会存储成Document中一个Field域。Field域的name为字段名，value则为具体值。文档域中，Document对象之间是没有关系的，而且每个Document中的Field域也不一定一样。</p><p>索引域：主要是为了搜索使用的，索引域的内容是经过Lucene分词之后存储的。</p><p>倒排索引表：传统方法是先找到文件，如何在文件中找内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大就搜索慢。 倒排索引结构是根据内容（词语）找文档，包括索引和文档两部分。索引即词汇表，它是在索引中匹配搜索关键字，由于索引内容量有限并且采用固定优化算法搜索速度很快，先找到索引中的词汇，词汇又与文档关联，从而最终找到了文档。</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p><strong>类介绍</strong></p><p>IndexWriter是索引过程的核心组件，通过IndexWriter可以创建新索引、更新索引、删除索引操作。IndexWriter需要通过Directory对索引进行存储操作。</p><p>Directory描述了索引的存储位置，底层封装了I/O操作，负责对索引进行存储。它是一个抽象类，它的子类常用的包括FSDirectory（在文件系统存储索引）、RAMDirectory（在内存存储索引）。</p><p>Analyzer是分词器，通过Analyzer可以实现分词，分词的目的就是在索引域中创建词条，主要过程就是先分词后过滤（标准过滤=&gt;大小写过滤=&gt;停用词过滤），使用时机：创建索引库时使用，查询时使用（注：创建时用哪个分词器，搜索时就用哪个分词器）</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>中间件技术</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ</title>
    <url>/sr/post/2020-03-27-%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%8A%80%E6%9C%AF-2020-03-27-RabbitMQ/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h3 id="什么是MQ"><a href="#什么是MQ" class="headerlink" title="什么是MQ"></a>什么是MQ</h3><p>消息队列（Message Queue，简称MQ），存储的数据结构为队列，存储的元素是一条条消息，符合 FIFO。其主要用途：不同进程Process/线程Thread之间通信。MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务</p><p>为什么会需要消息队列(MQ)？</p><p>主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达<code>MySQL</code>，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发<strong>too many connections</strong>错误。通过使用消息队列，我们可以异步处理请求，从而缓解系统的压力。</p><p>应用场景：异步通讯、应用(服务)解耦、并发缓冲（流量削峰）</p><p>MQ的不足是：</p><ul><li>系统更复杂，多了一个MQ组件</li><li>消息传递路径更长，延时会增加</li><li>消息可靠性和重复性互为矛盾，消息不丢不重难以同时保证</li><li>上游无法知道下游的执行结果，这一点是很致命的</li></ul><p>无论如何，记住这个结论：<strong>调用方实时依赖执行结果的业务场景，请使用调用，而不是MQ</strong></p><p><strong>概念介绍</strong>:</p><p>Broker:它提供一种传输服务,它的角色就是维护一条从生产者到消费者的路线，保证数据能按照指定的方式进行传输,<br>Exchange：消息交换机,它指定消息按什么规则,路由到哪个队列。<br>Queue:消息的载体,每个消息都会被投到一个或多个队列。<br>Binding:绑定，它的作用就是把exchange和queue按照路由规则绑定起来.<br>Routing Key:路由关键字,exchange根据这个关键字进行消息投递。<br>vhost:虚拟主机,一个broker里可以有多个vhost，用作不同用户的权限分离。<br>Producer:消息生产者,就是投递消息的程序.<br>Consumer:消息消费者,就是接受消息的程序.<br>Channel:消息通道,在客户端的每个连接里,可建立多个channel.</p><p>RabbitMQ 基础设施：交换机、队列、绑定（交换机和队列的粘合剂）</p><p>发布者将无法发布到不存在的交换机，并且消费者也无法从不存在的队列中获取消息。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>中间件技术</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/sr/post/2020-03-24-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-03-24-SpringCloud/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h3 id="引"><a href="#引" class="headerlink" title="引"></a>引</h3><p>在传统的软件架构中，我们通常采用的是单体应用来构建一个系统，一个单体应用糅合了各种业务模块。起初在业务规模不是很大的情况下，对于单体应用的开发维护也相对容易。但随着企业的发展，业务规模与日递增，单体应用变得愈发臃肿。由于单体应用将各种业务模块聚合在一起，并且部署在一个进程内，所以通常我们对其中一个业务模块的修改也必须将整个应用重新打包上线。为了解决单体应用变得庞大脯肿之后产生的难以维护的问题，微服务架构便出现在了大家的视线里</p><h3 id="什么是Spring-Cloud"><a href="#什么是Spring-Cloud" class="headerlink" title="什么是Spring Cloud"></a>什么是Spring Cloud</h3><p>Spring Cloud是一个基千Spring Boot实现的微服务架构开发工具。它为微服务架构中涉及的配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud的诞生并不是为了解决微服务中的某一个问题，而是提供了一套解决微服务架构实施的综合性解决方案。</p><p><em>版本号的问题</em><br>springcloud项目是由多个独立项目集合而成的，每个项目都是独立的，各自进行自己的迭代和版本发布。所以springcloud不方便使用版本号来管理，而是使用版本名。以避免和子项目版本号的冲突。</p><p>我们主要关心的是 Netflix 的子项目</p><p><em>Spring Cloud</em>组件</p><p>服务发现——Netflix Eureka: Eureka会将服务注册到EurekaService,并且EurakeClient还可以返回过来从EurekaService拉去注册表,从而知道服务在哪里<br>客服端负载均衡——Netflix Ribbon: 服务间发起请求的时候,基于Ribbon服务做到负载均衡,从一个服务的对台机器中选择一台<br>熔断器——Netflix Hystrix: 发起的请求是通过Hystrix的线程池来走,不同的服务走不同的线程池,实现了不同的服务调度隔离,避免服务雪崩的问题<br>服务网关——Netflix Zuul<br>分布式配置——Spring Cloud Config</p><p>Feign:基于fegin的动态代理机制,根据注解和选择机器,拼接Url地址,发起请求</p><p>Zuul:如果前端后端移动端调用后台系统,统一走zull网关进入,有zull网关转发请求给对应的服务</p><h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><h3 id="Eureka-服务治理组件"><a href="#Eureka-服务治理组件" class="headerlink" title="Eureka 服务治理组件"></a>Eureka 服务治理组件</h3><p>Eureka 是由<code>Netflix</code>开发的一款服务治理开源框架，Spring-cloud对其进行了集成。Eureka既包含了服务端也包含了客户端，Eureka服务端是一个<strong>服务注册中心(Eureka Server)</strong>，提供服务的注册和发现，即当前有哪些服务注册进来可供使用；Eureka客户端为<strong>服务提供者(Server Provider)</strong>，它将自己提供的服务注册到Eureka服务端，并周期性地发送心跳来更新它的服务租约，同时也能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态。这样<strong>服务消费者(Server Consumer)</strong>便可以从服务注册中心获取服务名称，并消费服务。</p><div class="note info"><p>服务端需开启注解：<code>@EnableEurekaServer</code><br>客户端需开启注解：<code>@EnableEurekaClient</code>或<code>@EnableDiscoveryClient</code></p></div><p>优势: 支持用户认证，支持注册列表缓存（容错），保护模式（解决分区故障），健康检查</p><h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>服务提供者要向<code>EurekaServer</code>进行服务注册，并完成服务续约等工作。</p><ul><li>服务注册</li></ul><ol><li>启动类上添加@DiscoveryClient，pom文件中添加eureka-client坐标</li><li>配置文件中添加注册中心信息</li><li>服务在启动时，检测是否有@DiscoveryClient注解和配置信息</li><li>如果有，则会向注册中心发起注册请求，携带服务元数据信息(IP、端口、服务列表)</li><li>Eureka注册中心会把服务的信息保存在Map中</li></ol><ul><li>服务续约<br>服务注册完成以后，服务提供者和注册中心会维持一个 心跳 ，保存服务处于存在状态，这个动作<br>称之为服务续约(renew)。</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">#租约到期，服务时效时间，默认值90秒</span></span><br><span class="line">    <span class="attr">lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line">    <span class="comment">#租约续约间隔时间，默认30秒</span></span><br><span class="line">    <span class="attr">lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>参数说明：<br>lease-expiration-duration-in-seconds:<br>租约到期时效时间，默认90秒；类似于和房东签合同，合同有效期为90天。<br>lease-renewal-interval-in-seconds:<br>租约续约间隔时间，默认30秒，类似于每隔30天再次和房东签订一个有效期为90天的合同<br>服务超过90秒没有发生心跳，EurekaServer会将服务从列表移除[ 前提是EurekaServer关闭了自我保护 ]</p><ul><li>开启健康检查</li></ul><p>例如Mysql服务下线时自动下线此服务，</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka.client.healthcheck.enable&#x3D;true</span><br></pre></td></tr></table></figure><h4 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h4><ul><li>获取注册中心服务列表(前提：<code>eureka.client.fetch-registry=true</code>)</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># EurekaServer的地址</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:7001/eureka</span></span><br><span class="line">    <span class="attr">registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><p>参数说明：<br>服务消费者启动时，会检测是否获取服务注册信息配置<br>如果是，则会从 EurekaServer服务列表获取只读备份，缓存到本地；每隔30秒，会重新获取并更新数据，每隔30秒的时间可以通过配置 registry-fetch-interval-seconds 修改</p><h4 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h4><ul><li>失效剔除<br>服务中心每隔一段时间(默认60秒)将清单中没有续约的服务剔除。<br>通过eureka.server.eviction-interval-timer-in-ms配置可以对其进行修改，单位是毫秒</li></ul><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">  <span class="comment"># 对无效的服务进行剔除，单位是毫秒</span></span><br><span class="line">    <span class="attr">eviction-interval-timer-in-ms:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><ul><li>自我保护</li></ul><p>Eureka Server 在运行期间会去统计心跳失败比例在 15 分钟之内是否低于 85%，如果低于 85%，Eureka Server 会将这些实例保护起来，让这些实例不会过期，但是在保护期内如果服务刚好这个服务提供者非正常下线了，此时服务消费者就会拿到一个无效的服务实例，此时会调用失败，对于这个问题需要服务消费者端要有一些容错机制，如重试，断路器等。(防止网络阻塞的问题)</p><p>1.自我保护模式下，不会剔除任何服务实例<br>2.自我保护模式保证了大多数服务依然可用<br>3.通过<code>eureka.server.enable-self-preservation</code>配置可用关闭触发自我保护，默认值是打开</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">server:</span></span><br><span class="line">    <span class="comment">#默认打开 </span></span><br><span class="line">    <span class="attr">enable-self-preservation:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Ribbon-负载均衡组件"><a href="#Ribbon-负载均衡组件" class="headerlink" title="Ribbon 负载均衡组件"></a>Ribbon 负载均衡组件</h3><p>主要提供客户侧的软件负载均衡算法。<br>遇到的坑: java.net.UnknownHostException，场景：eureka服务治理，ribbon负载均衡时，消费端通过<code>RestTemplate</code>调用服务端时出现<br>解决方法: 在主引导类的<code>RestTemplate</code>bean 配置中添加负载均衡注解<code>@LoadBalanced</code></p><p>常见算法</p><p>随机<br>轮询<br>一致性hash<br>加权<br>自定义</p><h3 id="Hystrix-熔断器组件"><a href="#Hystrix-熔断器组件" class="headerlink" title="Hystrix 熔断器组件"></a>Hystrix 熔断器组件</h3><p><strong>级联故障</strong><br>为了保证其高可用，单个服务通常会集群部署。由于网络原因或者服务自身的原因，服务并不能保证完全可用，如果单个服务出现问题，调用这个服务的就会出现线程阻塞，此时若有大量的请求涌入，线程资源就会被消耗完毕，导致服务瘫痪。</p><p>服务熔断：一般是指软件系统中，由于某些原因使得服务出现了过载现象，为防止造成整个系统故障，从而采用的一种保护措施，所以很多地方把熔断亦称为过载保护。很多时候刚开始可能只是系统出现了局部的、小规模的故障，然而由于种种原因，故障影响的范围越来越大，最终导致了全局性的后果</p><p>熔断器的核心：线程隔离和服务降级</p><ul><li>线程隔离：是指Hystrix在用户请求和服务之间加入了线程池（size:10）。为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。</li></ul><p>原理：用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果线程池已满，则会进行降级处理，用户的请求不会被阻塞，至少可以看到一个执行结果（例如返回友好的提示信息），而不是无休止的等待或者看到系统崩溃。</p><ul><li>服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用（非主要的服务和页面）。触发Hystrix服务降级的情况：线程池已满、请求超时。（client端做）</li></ul><p>熔断器状态介绍:</p><ul><li><strong>Closed.</strong>：关闭状态，所有请求正常访问，<code>under threshold</code>(阈值以下)则关闭。</li><li><strong>Open</strong>：打开状态，所有请求都会被降级。Hystrix 会对请求情况计数，当一定时间段内失败请求百分比<code>threshold reached</code>(达到阈值)则触发熔断，默认失败比例的阈值是50%，熔断触发的最小个数20次/10s</li><li><strong>Half Open</strong>：半开状态，Open 状态不是永久的，Open状态过一段时间（默认5s）转为此状态来尝试恢复。此状态时：允许有且仅一个请求进入，一旦请求成功就关闭断路器。请求失败就到Open状态（这样再过5秒才能转到半开状态）</li></ul><p>流程说明:</p><p>1:每次调用创建一个新的HystrixCommand，把依赖调用封装在run()方法中。<br>2:执行execute()/queue做同步或异步调用。<br>3:判断熔断器(circuit-breaker)是否打开，如果打开跳到步骤8，进行降级策略，如果关闭进入步骤。<br>4:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8，否则继续后续步骤。<br>5:调用HystrixCommand的run方法。运行依赖逻辑<br>5a:依赖逻辑调用超时，进入步骤8。<br>6:判断逻辑是否调用成功<br>6a:返回成功调用结果<br>6b:调用出错，进入步骤8。<br>7:计算熔断器状态，所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态。<br>8:getFallback()降级逻辑。<br>以下四种情况将触发getFallback调用：<br>(1)：run()方法抛出非HystrixBadRequestException异常<br>(2)：run()方法调用超时<br>(3)：熔断器开启拦截调用<br>(4)：线程池/队列/信号量是否跑满<br>8a:没有实现getFallback的Command将直接抛出异常<br>8b:fallback降级逻辑调用成功直接返回<br>8c:降级逻辑调用失败抛出异常<br>9:返回执行成功结果</p><h4 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h4><p>熔断策略配置(部分)：</p><ol start="0"><li>熔断器状态(false:关闭): circuitBreaker.forceClosed</li><li>熔断后休眠时间(5000毫秒)：circuitBreaker.sleepWindowInMilliseconds</li><li>熔断触发最小请求次数(20次/10s)：circuitBreaker.requestVolumeThreshold</li><li>熔断触发错误比例阈值(50%)：circuitBreaker.errorThresholdPercentage</li><li>熔断超时时间(1000毫秒)：execution.isolation.thread.timeoutInMilliseconds<br>默认值：1000<br>在<code>THREAD</code>模式下，达到超时时间，可以中断<br>在<code>SEMAPHORE</code>模式下，会等待执行完成后，再去判断是否超时</li><li>隔离策略(THREAD)：execution.isolation.strategy<br>默认使用THREAD模式，以下几种情况可以使用SEMAPHORE模式：</li></ol><ul><li>只想控制并发度</li><li>外部的方法已经做了线程隔离</li><li>调用的是本地方法或者可靠度非常高、耗时特别小的方法（如medis）</li></ul><p><strong>局部熔断</strong></p><p>1.导入 hystrix 依赖坐标<br>2.开启熔断:引导类加<code>@EnableCircuitBreaker</code>或者<code>@SpringCloudApplication</code>(此注解相当于：<code>@SpringBootApplication</code>+ <code>@EnableDiscoveryClient</code>+<code>@EnableCircuitBreaker</code>)<br>3.熔断后的降级处理方法 fallBack()<br>4.在需要熔断降级处理的方法上加<code>@HystrixCommand(fallbackMethod = &quot;fallBack&quot;)</code></p><p><strong>全局熔断</strong></p><p>针对某个类进行全局熔断。</p><p>1.导入 hystrix 依赖坐标<br>2.开启熔断:引导类加<code>@EnableCircuitBreaker</code>或者<code>@SpringCloudApplication</code>(此注解相当于：<code>@SpringBootApplication</code>+ <code>@EnableDiscoveryClient</code>+<code>@EnableCircuitBreaker</code>)<br>3.熔断后的降级处理方法 defaultFallBack()<br>4.在需要熔断降级处理的方法上加<code>@HystrixCommand</code>，在类上加<code>@DefaultProperties(defaultFallback = &quot;defaultFallBack&quot;)</code></p><h3 id="Feign-声明式服务调用组件"><a href="#Feign-声明式服务调用组件" class="headerlink" title="Feign 声明式服务调用组件"></a>Feign 声明式服务调用组件</h3><p>前面我们分别通过Spring Cloud Ribbon和Spring Cloud Hystrix实现了客户端负载均衡和服务容错，而Spring Cloud Feign不但整合了这两种功能，而且还提供了一种比Ribbon更简单的服务调用方式-在Spring Cloud Feign中编写服务调用代码非常简单，几乎可以直接将服务提供者的代码复制过来，去掉方法体转换为接口即可。</p><h3 id="Gateway-服务网关"><a href="#Gateway-服务网关" class="headerlink" title="Gateway 服务网关"></a>Gateway 服务网关</h3><p>网关：为微服务提供统一的路由管理，可以在路由管理基础上进行一系列的过滤，可以做一系列的监控操作，限流。</p><p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot2.0 和 Project Reactor 等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管<br>理方式。</p><p>路由和转发：过滤器断言</p><h4 id="微服务四大设计原则"><a href="#微服务四大设计原则" class="headerlink" title="微服务四大设计原则"></a>微服务四大设计原则</h4><ul><li><p>AKF 拆分原则</p></li><li><p>前后端分离</p></li><li><p>无状态服务</p></li><li><p>Restful 通信风格</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot</title>
    <url>/sr/post/2020-03-22-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-03-22-SpringBoot/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>用来简化spring应用的初始搭建以及开发过程 使用特定的方式来进行配置（properties或yml文件），创建独立的spring引导程序，启动main方法运行一个springboot项目，拥有嵌入的 Tomcat 无需部署war文件，简化maven配置（依赖传递性），添加对应功能的starter自动化配置需要的参数。</p><p>总结：spring boot来简化spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用</p><h4 id="项目运行命令-nohup和-amp-的区别"><a href="#项目运行命令-nohup和-amp-的区别" class="headerlink" title="项目运行命令: nohup和&amp;的区别"></a>项目运行命令: nohup和&amp;的区别</h4><p>&amp; ： 指在后台运行</p><p>nohup（no hang up） ： 不挂断的运行，注意并没有后台运行的功能，，就是指，用nohup运行命令可以使命令永久的执行下去，和用户终端没有关系，例如我们断开SSH连接都不会影响他的运行，注意了nohup没有后台运行的意思；&amp;才是后台运行</p><p>&amp;是指在后台运行，但当用户推出(挂起)的时候，命令自动也跟着退出</p><p>那么，我们可以巧妙的吧他们结合起来用就是<br>nohup COMMAND &amp;<br>这样就能使命令永久的在后台执行</p><h4 id="bootstrap-配置文件"><a href="#bootstrap-配置文件" class="headerlink" title="bootstrap 配置文件"></a>bootstrap 配置文件</h4><p>在 Spring Boot 中有两种上下文【配置文件】，一种是 bootstrap, 另外一种是 application；<br>bootstrap 是应用程序的父上下文，也就是说 bootstrap 加载优先于 applicaton。bootstrap 主要用于<br>从额外的资源来加载配置信息【git服务器等】，还可以在本地外部配置文件中解密属性。这两个上下文<br>共用一个环境，它是任何Spring应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们<br>默认也不能被本地相同配置覆盖。<br>因此，对比 application 配置文件，bootstrap 配置文件具有以下几个特性。<br>boostrap 由父 ApplicationContext 加载，比 applicaton 优先加载<br>boostrap 里面的属性不能被覆盖</p><p><strong>bootstrap使用场景</strong></p><p>使用 Spring Cloud Config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的<br>配置属性来加载外部配置中心的配置信息；<br>一些固定的不能被覆盖的属性<br>一些加密/解密的场景；</p><h4 id="多配置文件"><a href="#多配置文件" class="headerlink" title="多配置文件"></a>多配置文件</h4><p>mvn 打包(注意: 要在<code>poxm.xml</code>同级目录下)</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package -Dmaven.test.skip&#x3D;true -P prod</span><br></pre></td></tr></table></figure><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li>自动配置(AutoConfiguration)原理-condition接口</li><li>自动配置(AutoConfiguration)原理-@Enable*类型注解</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringSecurity</title>
    <url>/sr/post/2020-03-11-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-03-11-SpringSecurity/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>ZooKeeper</title>
    <url>/sr/post/2020-02-25-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-02-25-ZooKeeper/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，是 Hadoop 和 Hbase 的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。<br>ZooKeeper 的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。<br>ZooKeeper 包含一个简单的原语集，提供 Java 和 C 的接口。<br>ZooKeeper 代码版本中，提供了分布式独享锁、选举、队列的接口，代码在 <code>$zookeeper_home\src\recipes</code>。其中分布锁和队列有 Java 和 C 两个版本，选举只有 Java 版本。</p><p>节点数据存储位于<code>zoo.cfg</code>的配置<code>dataDir=../data</code>路径下，文件都是以二进制存储的。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>分布式应用程序可以基于 ZooKeeper 实现诸如 <strong>数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、配置维护，名字服务、分布式同步、分布式锁和分布式队列</strong>等功能。</p><h4 id="ZooKeeper-文件系统"><a href="#ZooKeeper-文件系统" class="headerlink" title="ZooKeeper 文件系统"></a>ZooKeeper 文件系统</h4><p>Zookeeper 提供一个多层级的节点命名空间（节点称为znode）。与文件系统不同的是，这些节点都可以设置关联的数据，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了这个树状的目录结构，这种特性使得 Zookeeper 不能用于存放大量的数据，每个节点的存放数据上限为<strong>1M</strong>。</p><h4 id="ZooKeeper-通知机制"><a href="#ZooKeeper-通知机制" class="headerlink" title="ZooKeeper 通知机制"></a>ZooKeeper 通知机制</h4><h4 id="主要应用场景"><a href="#主要应用场景" class="headerlink" title="主要应用场景"></a>主要应用场景</h4><p>命名服务（注册中心）：维护服务地址列表</p><p>数据发布与订阅（配置中心）：抽取公共配置，维护公共配置，一旦修改，应用可监听到并获取最新配置</p><div class="note info"><p><strong>配置中心的关注点</strong></p><ul><li>配置中心的弱依赖<br>应用应该弱依赖于配置中心，如果配置中心挂掉，不能影响应用的正常运行，所以客户端应该缓存配置数据</li><li>配置存储应该做好容灾备份<br>配置中心的数据是不能丢失的，如果丢失了，估计几百个配置项就无法寻回，这种是无法允许的</li><li>推送时延和推送成功率<br>如上节使用zookeeper来说，watcher机制并不能保证每一次配置的更改都推送给客户端，这种对于应用也是一件无法允许的事情</li><li>灰度<br>如果使用zookeeper来做配置中心，做灰度是一件很难的事情，不是说不能做，是需要客户端去配合过滤一些不必要的数据，而这种造成了网络的垃圾开销及客户端的复杂度，下文会详细说</li><li>集中入口及变更审计能力</li></ul></div><p>集群管理:<br>分布式锁管理:<br>分布式队列管理:<br>Master 选举: 在分布式环境中，有些业务逻辑只需要集群中的某一台机器进行执行，其他的机器可以共享这个结果，这样可以大大减少重复计算，提高性能，于是就需要进行 Master 选举</p><p><em>ZooKeeper 负载均衡和 Nginx 负载均衡区别</em>：zk的负载均衡是可以调控，nginx只是能调权重，其他需要可控的都需要自己写插件；但是nginx的吞吐量比zk大很多，应该说按业务选择用哪种方式。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="文件系统模型"><a href="#文件系统模型" class="headerlink" title="文件系统模型"></a>文件系统模型</h4><p>层次模型和key-value 模型是两种主流的数据模型。ZooKeeper 使用文件系统模型主要基于以下两点考虑：</p><ul><li>文件系统的树形结构便于表达数据之间的层次关系。</li><li>文件系统的树形结构便于为不同的应用分配独立的命名空间（namespace）。</li></ul><h4 id="集群角色"><a href="#集群角色" class="headerlink" title="集群角色"></a>集群角色</h4><p>zookeeper 摒弃以往的<code>Master</code>/<code>Slave</code>角色，引入了新的</p><ul><li>Leader: 领导者负责进行投票的发起和决议，更新系统状态。</li><li>Follower: 跟随者用于接收客户请求并向客户端返回结果，在选主过程中参与投票</li><li>Observer: 观察者可以接收客户端连接，将写请求转发给 Leader 节点。但 Observer 不参加投票过程，只同步 Leader 的状态。Observer 的目的是为了扩展系统，提高读取速度。</li></ul><p>一个 ZooKeeper 集群同一时刻只会有一个 Leader，其他都是 Follower 或 Observer</p><p>ZooKeeper 配置很简单，每个节点的配置文件(zoo.cfg)都是一样的，只有 myid 文件不一样。myid 的值必须是 zoo.cfg 中server.{数值} 的{数值}部分。</p><p><code>zoo.cfg</code>配置文件示例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial </span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between </span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just </span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;..&#x2F;data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the </span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br></pre></td></tr></table></figure><p>ZooKeeper 默认只有 Leader 和 Follower 两种角色，没有 Observer 角色。为了使用 Observer 模式，在任何想变成Observer的节点的配置文件中加入:peerType=observer 并在所有 server 的配置文件中，配置成 observer 模式的 server 的那行配置追加 :observer</p><h4 id="节点读写服务分工"><a href="#节点读写服务分工" class="headerlink" title="节点读写服务分工"></a>节点读写服务分工</h4><p>1.ZooKeeper 集群的所有机器通过一个 Leader 选举过程来选定一台被称为『Leader』的机器，<code>Leader</code>服务器为客户端提供读和写服务。</p><p>2.Follower 和 Observer 都能提供读服务，不能提供写服务。两者唯一的区别在于，Observer机器不参与 Leader 选举过程，也不参与写操作的『过半写成功』策略，因此 Observer 可以在不影响写性能的情况下提升集群的读性能。</p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session 是指客户端会话，在讲解客户端会话之前，我们先来了解下客户端连接。在 ZooKeeper 中，一个客户端连接是指客户端和 ZooKeeper 服务器之间的TCP长连接。</p><p>ZooKeeper 对外的服务端口默认是 2181，客户端启动时，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了，通过这个连接，客户端能够通过心跳检测和服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能通过该连接接收来自服务器的 Watch 事件通知。</p><p>Session 的 SessionTimeout 值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在 SessionTimeout 规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p><h4 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h4><p>ZooKeeper 的结构其实就是一个树形结构，Leader 就相当于其中的根结点，其它节点就相当于 follow 节点，每个节点都保留自己的内容。</p><p>有四种类型的 znode：（临时节点可以用来服务发现、服务注册/顺序编号可以用来实现保持时序的分布式锁 命名服务（分布式自增id）分布式队列先进先出 ）</p><p>1、PERSISTENT-持久化目录节点：客户端与zookeeper断开连接后，该节点依旧存在</p><p>2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点：客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</p><p>3、EPHEMERAL-临时目录节点：客户端与zookeeper断开连接后，该节点被删除（node_0000000001）</p><p>4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点：客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="Watcher-机制"><a href="#Watcher-机制" class="headerlink" title="Watcher 机制"></a>Watcher 机制</h4><p>首先，ZooKeeper 提供了分布式数据的发布/订阅功能。这就不得不联想到设计模式中的经典「观察者模式」，此模式可以定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。主要解决了<strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作</strong>。</p><p>ZooKeeper 的 Watcher 机制主要包括客户端线程、客户端 WatchManager 和 ZooKeeper 服务器三部分。</p><p>客户端线程: 分布在各处的 ZooKeeper 的 jar 包程序，被引用在各个独立应用程序中。<br>WatchManager ：一个接口，用于管理各个监听器，只有一个方法 materialize()，返回一个 Watcher 的 set<br>ZooKeeper服务器: 部署在远程主机上的 ZooKeeper 集群，当然，也可能是单机的。</p><p>为了更好的实现 Java 操作 ZooKeeper 服务器，后来出现了 Curator 框架，非常的强大，目前已经是 Apache 的顶级项目，里面提供了更多丰富的操作，例如 Session 超时重连、主从选举、分布式计数器、分布式锁等等适用于各种复杂的 Zookeeper 场景的 API 封装</p><p><strong>Curator 引入了 Cache 的概念用来实现对 ZooKeeper 服务器端进行事件监听。Cache 是 Curator 对事件监听的包装，其对事件的监听可以近似看做是一个本地缓存视图和远程 ZooKeeper 视图的对比过程。而且 Curator 会自动的再次监听，我们就不需要自己手动的重复监听了</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--zookeeper的依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--	zookeeper CuratorFramework 是Netflix公司开发一款连接zookeeper服务的框架，通过封装的一套高级API 简化了ZooKeeper的操作，提供了比较全面的功能，除了基础的节点的操作，节点的监听，还有集群的连接以及重试。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p><strong>Leader选举，要求 可用节点数量 &gt; 总节点数量/2 。注意 是 &gt; , 不是 ≥</strong></p><p>假设有三台服务器（a、b、c）用于搭建zookeeper集群，在每台服务器的<code>$zookeeper/data/</code>路径下建有 sid 文件，此文件用于保存服务器的编号，分别对应 a-1,b-2,c-3;</p><p>1、服务器a 启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器a 的状态一直属于Looking(选举状态)。<br>2、服务器b 启动，给自己投票，同时与之前启动的服务器a 比对，首先对比 zxid，谁大谁就是 Leader 如果相同则比较 sid，此时服务器b 的编号大所以服务器b 胜出，此时服务器a 的选票将会改为投给服务器b ，所以服务器b 的选票数大于服务器半数，服务器b 被选为 Leader<br>3、服务器c 启动，给自己投票，同时与之前启动的服务器a,b 交换信息，尽管服务器c 的编号大，但之前服务器b 已经胜出，所以服务器c 只能成为 Follower。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP</title>
    <url>/sr/post/2020-02-15-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-Web-2020-02-15-Web05-HTTP/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><h4 id="TPC-IP"><a href="#TPC-IP" class="headerlink" title="TPC/IP"></a>TPC/IP</h4><p>建立起一个TCP连接需要经过“三次握手”：</p><p>第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p><p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p><p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次挥手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）</p><p>seq和ack号存在于TCP报文段的首部中，seq是序号，ack是确认号，大小均为4字节。</p><p>seq：占 4 字节，序号范围[0，2^32-1]，序号增加到 2^32-1 后，下个序号又回到 0。TCP 是面向字节流的，通过 TCP 传送的字节流中的每个字节都按顺序编号，而报头中的序号字段值则指的是本报文段数据的第一个字节的序号。</p><p>ack：占 4 字节，期望收到对方下个报文段的第一个数据字节的序号</p><p>SYN，ACK是标志位<br>SEQ，AN是数据包序号<br>SYN=1, ACK=0, SEQ=200 的意思是：发送的为一个SYN请求，发送端的初始数据包序号为200<br>SYN=1, ACK=1, SEQ=4800, AN=201 的意思是：接收端的确认信息，且接收端的初始数据包序号为4800</p><h4 id="SOCKET"><a href="#SOCKET" class="headerlink" title="SOCKET"></a>SOCKET</h4><p>套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。</p><p>应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。</p><p>HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。</p><p>1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。</p><p>2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。</p><p>由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。</p><h3 id="安全特性和幂等特性"><a href="#安全特性和幂等特性" class="headerlink" title="安全特性和幂等特性"></a>安全特性和幂等特性</h3><p>Http 协议规定了不同方法的安全特性和幂等特性，作为服务提供者的服务器必需为客户端提供这些特性</p><p><strong>安全性</strong>，仅指该方法的多次调用不会产生副作用，不涉及传统意义上的“安全”，这里的副作用是指资源状态。即，安全的方法不会修改资源状态，尽管多次调用的返回值可能不一样(被其他非安全方法修改过)。</p><p><strong>幂等性</strong>，是指该方法多次调用返回的效果(形式)一致，客户端可以重复调用并且期望同样的结果。幂等的含义类似于编程语言中的setter方法，一次调用和多次调用产生的效果是一致的，都是对一个变量进行赋值。安全性和幂等性含义有些接近，容易搞混。</p><table><thead><tr><th>方法名</th><th>安全性</th><th>幂等性</th></tr></thead><tbody><tr><td>GET</td><td>是</td><td>是</td></tr><tr><td>HEAD</td><td>是</td><td>是</td></tr><tr><td>OPTIONS</td><td>是</td><td>是</td></tr><tr><td>DELETE</td><td>否</td><td>是</td></tr><tr><td>PUT</td><td>否</td><td>是</td></tr><tr><td>POST</td><td>否</td><td>否</td></tr></tbody></table><p>可以认为安全的方法都是只读的方法(GET, HEAD, OPTIONS)，不会改变资源状态，显然，这三个方法也是幂等的。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/sr/post/2020-02-11-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-02-11-SpringMVC/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="MVC-设计模型"><a href="#MVC-设计模型" class="headerlink" title="MVC 设计模型"></a>MVC 设计模型</h3><p>MVC全名是 Model View Controller 模型视图控制器。</p><ul><li>Model：数据模型，JavaBean的类，用来进行数据封装。</li><li>View：指JSP、HTML用来展示数据给用户</li><li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ul><div class="note success"><p><strong>面向接口编程</strong></p><p>为什么要用Service接口和DAO接口？我们还得回到最基本的面向对象设计原则上去。<br>面向对象设计原则中有三条与此相关：开闭原则、依赖倒转原则、理氏替换原则。还记得依赖倒转原则吧？高层不依赖于低层，二者都依赖于抽象，也就是面向接口编程。<br>为什么要用Service接口？是让表示层不依赖于业务层的具体实现。为什么要用DAO接口？是让业务层不依赖于持久层的具体实现。有了这两个接口，Spring IOC容器才能发挥作用。<br>举个例子，用DAO接口，那么持久层用Hibernate，还是用iBatis，还是 JDBC，随时可以替换，不用修改业务层Service类的代码。<br>使用接口的意义就在此。</p></div><h3 id="SpringMVC-是什么"><a href="#SpringMVC-是什么" class="headerlink" title="SpringMVC 是什么?"></a>SpringMVC 是什么?</h3><ol><li>是一种基于 Java 实现的 MVC 设计模型的请求驱动类型的轻量级WEB框架。</li><li><code>Spring MVC</code> 属于<code>SpringFrameWork</code>的后续产品，已经在<code>Spring Web Flow</code>里面。</li><li>使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 SpringMVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等</li></ol><h3 id="常见组件"><a href="#常见组件" class="headerlink" title="常见组件"></a>常见组件</h3><p>用于 HTTP 请求处理程序/控制器的中央调度器: org.springframework.web.servlet.DispatcherServlet</p><p>处理器映射器: org.springframework.web.servlet.HandlerMapping</p><p>处理器适配器: org.springframework.web.servlet.HandlerAdapter</p><p>视图解析器: org.springframework.web.servlet.ViewResolver</p><h3 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h3><p>表单提交的数据都是k=v格式的 username=xma&amp;password=1001，SpringMVC 的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的，要求提交表单的键名和参数的名称是相同的</p><p><strong>支持的数据类型</strong></p><p>基本数据类型和字符串类型<br>实体类型（JavaBean）<br>集合数据类型（List、map等）</p><p><strong>类型转换器</strong></p><p><strong>获取原生servlet API</strong></p><h3 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h3><h4 id="RequestParam【重点】"><a href="#RequestParam【重点】" class="headerlink" title="RequestParam【重点】"></a>RequestParam【重点】</h4><h5 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用：</p><p>把请求中指定名称的参数给控制器中的形参赋值。</p></li><li><p>属性</p><p>value： 请求参数中的名称。<br>required：请求参数中是否必须提供此参数。 默认值： true。表示必须提供，如果不提供将报错。</p><p>defaultValue:默认值</p></li></ul><p>细节: json 类型数据必须加此注解</p><h5 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"user/testRequestParam?name=张三"</span>&gt;</span>测试RequestParam <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>UserController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testRequestParam"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRequestParam</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>,required = <span class="keyword">true</span>,defaultValue = <span class="string">"李四"</span>)</span> String username)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"username="</span>+username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestBody-ResponseBody【重点】"><a href="#RequestBody-ResponseBody【重点】" class="headerlink" title="RequestBody/ResponseBody【重点】"></a>RequestBody/ResponseBody【重点】</h4><p>请求体: post方式的请求参数,get方式没有请求体</p><p>Get和Post区别</p><ol><li>get方式 请求参数拼接在请求路径后面, post 方式 请求参数在请求体里面</li><li>get方式 请求参数浏览器地址栏可见, post 方式 请求参数浏览器地址栏不可见</li><li>get方式 请求参数大小有限制的, post 方式请求参数大小没有限制的</li></ol><h5 id="使用说明-1"><a href="#使用说明-1" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用</p><p>1.用于获取请求体内容。 直接使用得到是 key=value&amp;key=value…结构的字符串。</p><p>2.把获得json类型的数据转成pojo对象(后面再讲)</p><p>注意: get 请求方式不适用。</p></li><li><p>属性</p><p>required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false， get 请求得到是 null。</p></li></ul><h5 id="使用实例-1"><a href="#使用实例-1" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>  <span class="attr">action</span>=<span class="string">"user/testRequestBody "</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"测试RequestBody"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>UserController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testRequestBody"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">testRequestBody</span><span class="params">(@RequestBody String queryStr)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"queryStr="</span>+queryStr);</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="PathVariable【重点】"><a href="#PathVariable【重点】" class="headerlink" title="PathVariable【重点】"></a>PathVariable【重点】</h4><h5 id="REST-风格-URL"><a href="#REST-风格-URL" class="headerlink" title="REST 风格 URL"></a>REST 风格 URL</h5><p>​ REST（英文： Representational State Transfer，简称 REST）描述了一个架构样式的网络系统，比如 web 应用程序。它首次出现在 2000 年 Roy Fielding 的博士论文中，他是 HTTP 规范的主要编写者之一。在目前主流的三种 Web 服务交互方案中， REST 相比于 SOAP（Simple Object Access protocol，简单对象访问协议）以及 XML-RPC 更加简单明了，无论是对 URL 的处理还是对 Payload 的编码， REST 都倾向于用更加简单轻量的方法设计和实现。值得注意的是 REST 并没有一个明确的标准，而更像是一种设计的风格。它本身并没有什么实用性，其核心价值在于如何设计出符合 REST 风格的网络接口。</p><ul><li><p>restful 的优点</p><p>它结构清晰、符合标准、易于理解、 扩展方便，所以正得到越来越多网站的采用。</p></li><li><p>restful 的特性：</p><p>​ 资源（Resources） ： 网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的存在。可以用一个 URI（统一资源定位符）指向它，每种资源对应一个特定的 URI 。要获取这个资源，访问它的 URI 就可以，因此 URI 即为每一个资源的独一无二的识别符。表现层（Representation） ： 把资源具体呈现出来的形式，叫做它的表现层 （Representation）。比如，文本可以用 txt 格式表现，也可以用 HTML 格式、 XML 格式、 JSON 格式表现，甚至可以采用二进制格式。状态转化（State Transfer） ： 每 发出一个请求，就代表了客户端和服务器的一次交互过程。HTTP 协议，是一个无状态协议，即所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段， 让服务器端发生“ 状态转化” （State Transfer）。而这种转化是建立在表现层之上的，所以就是 “ 表现层状态转化” 。具体说，就是 HTTP 协议里面，四个表示操作方式的动词： GET 、 POST 、 PUT、DELETE。它们分别对应四种基本操作： GET 用来获取资源， POST 用来新建资源， PUT 用来更新资源， DELETE 用来删除资源 .</p></li></ul><div class="note info"><p>Spring(Spring MVC) 对 RESTful 的支持</p><ul><li><p>利用@RequestMapping 指定要处理请求的 URI 模板和 HTTP 请求的动作类型</p></li><li><p>利用@PathVariable 将 URI 请求模板中的变量映射到处理方法参数上</p></li><li><p>利用 Ajax,在客户端发出 PUT、DELETE 动作的请求</p></li></ul></div><ul><li>实例</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">保存</span><br><span class="line">	传统：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;save</span><br><span class="line">	REST：http:&#x2F;&#x2F;localhost:8080&#x2F;user						    POST方式	执行保存</span><br><span class="line"></span><br><span class="line">更新</span><br><span class="line">	传统：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;update?id&#x3D;1</span><br><span class="line">	REST：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;1					    PUT方式	执行更新   1代表id</span><br><span class="line"></span><br><span class="line">删除	</span><br><span class="line">	传统：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;delete?id&#x3D;1</span><br><span class="line">	REST：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;1				       DELETE方式	执行删除 1代表id  </span><br><span class="line"></span><br><span class="line">查询</span><br><span class="line">	传统：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;findAll</span><br><span class="line">	REST：http:&#x2F;&#x2F;localhost:8080&#x2F;user						  GET方式	查所有</span><br><span class="line"></span><br><span class="line">	传统：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;findById?id&#x3D;1</span><br><span class="line">	REST：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;1 					  GET方式	根据id查1个</span><br></pre></td></tr></table></figure><h5 id="使用说明-2"><a href="#使用说明-2" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用：</p><p>用于绑定 url 中的占位符。 例如：请求 url 中 /delete/{id}， 这个{id}就是 url 占位符。<br>url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p></li><li><p>属性：</p><p>value： 用于指定 url 中占位符名称。<br>required：是否必须提供占位符。</p></li></ul><h5 id="使用实例-2"><a href="#使用实例-2" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;user&#x2F;testPathVaribale&#x2F;1&quot;&gt;测试PathVaribale&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>UserController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"testPathVaribale/&#123;id&#125;"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">testPathVaribale</span><span class="params">(@PathVariable(value = <span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"id="</span>+id);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RequestHeader【了解】"><a href="#RequestHeader【了解】" class="headerlink" title="RequestHeader【了解】"></a>RequestHeader【了解】</h4><h5 id="使用说明-3"><a href="#使用说明-3" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li>作用：<br>用于获取请求消息头。</li><li>属性：<br>value：提供消息头名称<br>required：是否必须有此消息头</li></ul><h5 id="使用实例-3"><a href="#使用实例-3" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;user&#x2F;testRequestHeader&quot;&gt;测试RequestHeader&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>UserController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testRequestHeader"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRequestHeader</span><span class="params">(@RequestHeader(value = <span class="string">"User-Agent"</span>)</span> String requestHeader)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"requestHeader="</span>+requestHeader);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CookieValue【了解】"><a href="#CookieValue【了解】" class="headerlink" title="CookieValue【了解】"></a>CookieValue【了解】</h4><h5 id="使用说明-4"><a href="#使用说明-4" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用：</p><p>用于把指定 cookie 名称的值传入控制器方法参数。</p></li><li><p>属性：</p><p>value：指定 cookie 的名称。<br>required：是否必须有此 cookie。</p></li></ul><h5 id="使用实例-4"><a href="#使用实例-4" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;user&#x2F;testCookieValue&quot;&gt;测试CookieValue&lt;&#x2F;a&gt;&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure><ul><li>UserController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"testCookieValue"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testCookieValue</span><span class="params">(@CookieValue(value=<span class="string">"JSESSIONID"</span>)</span> String sessionId)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"sessionId="</span>+sessionId);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ModelAttribute-【课后自学】"><a href="#ModelAttribute-【课后自学】" class="headerlink" title="ModelAttribute 【课后自学】"></a>ModelAttribute 【课后自学】</h4><h5 id="使用说明-5"><a href="#使用说明-5" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用：</p><p>​ 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。</p><p>​ 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。</p><p>​ 出现在参数上，获取指定的数据给参数赋值。</p></li><li><p>属性：<br>value：用于获取数据的 key。 key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</p></li><li><p>应用场景：<br>当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。<br>例如：<br>​ 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数<br>​ 据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。</p></li></ul><h5 id="使用实例-5"><a href="#使用实例-5" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"user/testModelAttribute"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"testModelAttribute"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>UserController.java(用在方法上面)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String  <span class="title">testModelAttribute</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"testModelAttribute ...收到了请求..."</span>+user);</span><br><span class="line">    <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User  <span class="title">getModel</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"getModel ...收到了请求..."</span>);</span><br><span class="line">    <span class="comment">//模拟查询数据库, 把性别也查询出来</span></span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(username);</span><br><span class="line">    user.setUsername(password);</span><br><span class="line">    user.setSex(<span class="string">"男"</span>);</span><br><span class="line">    <span class="keyword">return</span>  user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>UserController.java(用在参数上面)</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/testModelAttribute"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String  <span class="title">testModelAttribute</span><span class="params">(@ModelAttribute(<span class="string">"u"</span>)</span> User user)</span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"testModelAttribute ...收到了请求..."</span>+user);</span><br><span class="line">       <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="comment">//没有返回值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">getModel</span><span class="params">(String username, String password, Map&lt;String,User&gt; map)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"getModel ...收到了请求..."</span>);</span><br><span class="line">       <span class="comment">//模拟查询数据库, 把性别也查询出来</span></span><br><span class="line">       User user = <span class="keyword">new</span> User();</span><br><span class="line">       user.setUsername(username);</span><br><span class="line">       user.setUsername(password);</span><br><span class="line">       user.setSex(<span class="string">"男"</span>);</span><br><span class="line">       map.put(<span class="string">"u"</span>,user);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="SessionAttributes-【课后自学】"><a href="#SessionAttributes-【课后自学】" class="headerlink" title="SessionAttributes 【课后自学】"></a>SessionAttributes 【课后自学】</h4><h5 id="使用说明-6"><a href="#使用说明-6" class="headerlink" title="使用说明"></a>使用说明</h5><ul><li><p>作用：</p><p>用于多次执行(多次请求)控制器方法间的参数共享。(该注解定义在类上)，底层会存入到 request 域中</p></li><li><p>属性：<br>value：用于指定存入的属性名称<br>type：用于指定存入的数据类型。</p></li></ul><h5 id="使用实例-6"><a href="#使用实例-6" class="headerlink" title="使用实例"></a>使用实例</h5><ul><li>页面</li></ul><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;a href="sessionController/setAttribute?name=张三&amp;age=18"&gt;测试SessionAttributes(存)&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href="sessionController/getAttribute"&gt;测试SessionAttribute(取)&lt;/a&gt;&lt;br/&gt;</span><br><span class="line">&lt;a href="sessionController/removeAttribute"&gt;测试SessionAttribute(清空)&lt;/a&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure><ul><li>SessionController.java</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sessionController"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value = &#123;<span class="string">"name"</span>,<span class="string">"age"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/setAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setAttribute</span><span class="params">(String name, <span class="keyword">int</span> age, Model model)</span></span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"name"</span>,name);</span><br><span class="line">        model.addAttribute(<span class="string">"age"</span>,age);</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAttribute</span><span class="params">(ModelMap modelMap)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name="</span>+modelMap.get(<span class="string">"name"</span>));</span><br><span class="line">        System.out.println(<span class="string">"age="</span>+modelMap.get(<span class="string">"age"</span>));</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/removeAttribute"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeAttribute</span><span class="params">(SessionStatus sessionStatus)</span></span>&#123;</span><br><span class="line">        sessionStatus.setComplete();</span><br><span class="line">        <span class="keyword">return</span>  <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应和结果视图"><a href="#响应和结果视图" class="headerlink" title="响应和结果视图"></a>响应和结果视图</h3><p>响应 String<br>响应 void<br>响应 ModelAndView<br>响应关键字：forword/redirect</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>当我们使用 jersy 把图片从客服端上传到引用服务器之后，在上传指图片服务器时，我们可能会遇见以下三个错误：</p><div class="note danger"><p>returned a response status of 400 OR 403 OR 409</p></div><ul><li>400 解决方法</li></ul><p>首先排除 url 和参数错误，这里只说在你确认代码无误的情况下报错的情况：<strong>不管上传的是什么类型的文件，文件名改成英文名</strong></p><ul><li>403 解决方法</li></ul><p><strong>Tomcat 默认为情况下，是不允许向服务器执行写操作的</strong>，所以我们需要到文件服务器的<code>\conf\web.xml</code>文件中追加如下参数</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.catalina.servlets.DefaultServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--追加参数 begin--&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>readonly<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--追加参数 end--&gt;</span> </span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>listings<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>409 解决方法</li></ul><p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。即当前访问的路径下没有相关文件或文件夹，所以我们在<code>target/项目名</code>的路径下，<strong>新建一个上传服务器路径一致的文件夹</strong></p><h3 id="MVC-异常处理机制"><a href="#MVC-异常处理机制" class="headerlink" title="MVC 异常处理机制"></a>MVC 异常处理机制</h3><h3 id="MVC-拦截机制"><a href="#MVC-拦截机制" class="headerlink" title="MVC 拦截机制"></a>MVC 拦截机制</h3><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器(自己编写的 Controller)进行预处理和后处理。他们之间的区别如下</p><table><thead><tr><th>类别</th><th>使用范围</th><th>拦截范围</th></tr></thead><tbody><tr><td>拦截器</td><td>SpringMVC项目</td><td>只会拦截访问的控制器方法的请求</td></tr><tr><td>过滤器</td><td>任何web项目</td><td>任何资源(servlet,控制器,jsp,html等)</td></tr></tbody></table><p>​ 我们要想自定义拦截器， 要求必须实现： HandlerInterceptor 接口。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截!!!!!!"</span>);</span><br><span class="line">        <span class="comment">//如果返回false则被拦截，true则放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册到 SpringMVC 的配置文件</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">        "/*"和"/**"的区别:</span></span><br><span class="line"><span class="comment">          "/*"表示拦截一级目录</span></span><br><span class="line"><span class="comment">          "/**"表示拦截多级目录 </span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sysInterceptor"</span> <span class="attr">class</span>=<span class="string">"com.juejun.Interceptor.SysInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 提供了 AbstractAnnotationConfigDispatcherServletInitializer 类（也是WebApplicationInitializer的子类），可以实现 ssm 纯注解开发</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo</title>
    <url>/sr/post/2020-02-10-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-02-10-Dubbo/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="引"><a href="#引" class="headerlink" title="引"></a>引</h2><p>学习 dubbo 之前我们有必要了解下分布式系统这个概念。<br>当一个互联网业务获得大众欢迎的时候，最显著碰到的技术问题，就是服务器非常繁忙。当每天有1000万个用户访问你的网站时，无论你使用什么样的服务器硬件，都不可能只用一台机器就承载的了。因此，在互联网程序员解决服务器端问题的时候，必须要考虑如何使用多台服务器，为同一种互联网应用提供服务，这就是所谓“分布式系统”的来源。</p><p>分布式的世界中涉及到大量的协议（raft、2pc、lease、quorum等）、大量的理论（FLP， CAP等）、大量的系统（GFS、MongoDB、MapReduce、Spark、RabbitMQ等）</p><p>负载均衡:这里就拿 IP 负载均衡来说吧，<strong>IP负载均衡</strong>是对外提供一个公共地址，请求过来时通过轮询、随机等，路由到不同 Server。目的是分摊访问压力。</p><h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><h3 id="Dubbo-作用"><a href="#Dubbo-作用" class="headerlink" title="Dubbo 作用"></a>Dubbo 作用</h3><p>Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的<strong>RPC 远程服务调用方案</strong>，以及<strong>SOA 服务治理方案</strong>，协议和序列化框架都可以插拔是极其鲜明的特色。</p><p>在一个典型 RPC 的使用场景中，包含了服务发现、负载、容错、网络传输、序列化等组件，其中“RPC 协议”就指明了程序如何进行网络传输和序列化。</p><p><strong>什么叫RPC</strong></p><p>Remote Procedure Call 远程过程调用，是分布式架构的核心，按响应方式分如下两种：</p><p>​ 同步调用：客户端调用服务方方法，等待直到服务方返回结果或者超时，再继续自己的操作。</p><p>​ 异步调用：客户端把消息发送给中间件，不再等待服务端返回，直接继续自己的操作。</p><ul><li><p>是一种进程间的通信方式</p></li><li><p>它允许应用程序调用网络上的另一个应用程序中的方法</p></li><li><p>对于服务的消费者而言，无需了解远程调用的底层细节，是透明的</p><p>需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。</p><p>RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo、spring Cloud等。</p></li></ul><p><strong>为什么要RPC</strong></p><p>RPC 是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据.</p><p>简单的说，dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有dubbo这样的分布式服务框架的需求，并且本质上是个服务调用的东东，说白了就是个远程服务调用的分布式框架（告别Web Service模式中的WSdl，以服务者与消费者的方式在dubbo上注册）。</p><ul><li>同步调用：需等待结果</li><li>异步调用：无需等待结果</li></ul><p><strong>核心部分</strong></p><ol><li><p>远程通讯<br>提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</p></li><li><p>集群容错<br>提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</p></li><li><p>自动发现<br>基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</p></li></ol><h3 id="系统架构演变"><a href="#系统架构演变" class="headerlink" title="系统架构演变"></a>系统架构演变</h3><p><strong>随系统复杂度的增长，系统架构的变化和侧重点</strong></p><p><strong>单一应用架构</strong><br>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。<br>此时，用于简化增删改查工作量的<strong>数据访问框架(ORM)</strong>是关键。</p><p><strong>垂直应用架构</strong><br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的<strong>Web 框架(MVC)</strong>是关键。</p><p><strong>分布式服务架构</strong><br>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。<br>此时，用于提高业务复用及整合的<strong>分布式服务框架(RPC)</strong>是关键。</p><p><strong>流动计算架构</strong><br>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。<br>此时，用于提高机器利用率的<strong>资源调度和治理中心(SOA)</strong>是关键。<br>SOA的标志：服务粒度粗、数据库单一、ESB/SOAP</p><h3 id="Dubbo-分层"><a href="#Dubbo-分层" class="headerlink" title="Dubbo 分层"></a>Dubbo 分层</h3><p>服务接口层（Service）：该层是与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</p><p>配置层（Config）：对外配置接口，以ServiceConfig和ReferenceConfig为中心，可以直接new配置类，也可以通过spring解析配置生成配置类。</p><p>服务代理层（Proxy）：服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton，以ServiceProxy为中心，扩展接口为ProxyFactory。</p><p>服务注册层（Registry）：封装服务地址的注册与发现，以服务URL为中心，扩展接口为RegistryFactory、Registry和RegistryService。可能没有服务注册中心，此时服务提供方直接暴露服务。</p><p>集群层（Cluster）：封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心，扩展接口为Cluster、Directory、Router和LoadBalance。将多个服务提供方组合为一个服务提供方，实现对服务消费方来透明，只需要与一个服务提供方进行交互。</p><p>监控层（Monitor）：RPC调用次数和调用时间监控，以Statistics为中心，扩展接口为MonitorFactory、Monitor和MonitorService。</p><p>远程调用层（Protocol）：封将RPC调用，以Invocation和Result为中心，扩展接口为Protocol、Invoker和Exporter。Protocol是服务域，它是Invoker暴露和引用的主功能入口，它负责Invoker的生命周期管理。Invoker是实体域，它是Dubbo的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起invoke调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p><p>信息交换层（Exchange）：封装请求响应模式，同步转异步，以Request和Response为中心，扩展接口为Exchanger、ExchangeChannel、ExchangeClient和ExchangeServer。</p><p>网络传输层（Transport）：抽象mina和netty为统一接口，以Message为中心，扩展接口为Channel、Transporter、Client、Server和Codec。</p><p>数据序列化层（Serialize）：可复用的一些工具，扩展接口为Serialization、 ObjectInput、ObjectOutput和ThreadPool。</p><h3 id="Dubbo-适用场景"><a href="#Dubbo-适用场景" class="headerlink" title="Dubbo 适用场景"></a>Dubbo 适用场景</h3><p>1.RPC 分布式服务</p><p>当网站变大后，不可避免的需要拆分应用进行服务化，以提高开发效率，调优性能，节省关键竞争资源等。</p><p>比如：为了适用不断变化的市场需求，以及多个垂直应用之间数据交互方便，我们把公共的业务抽取出来作为独立的模块，为其他的应用提供服务，系统逐渐依赖于抽象和rpc远程服务调用。</p><p>2.配置管理</p><p>当服务越来越多时，服务的URL地址信息就会爆炸式增长，配置管理变得非常困难，F5硬件负载均衡器的单点压力也越来越大。</p><p>3.服务依赖</p><p>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</p><p>4.服务扩容</p><p>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？等等……</p><h3 id="Dubbo-架构分析"><a href="#Dubbo-架构分析" class="headerlink" title="Dubbo 架构分析"></a>Dubbo 架构分析</h3><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><p>Provider：暴露服务的服务提供者</p><p>Container：服务运行的容器</p><p>Consumer：调用远程服务的消费者</p><p>Registry：服务注册和发现的注册中心</p><p>Minitor：统计服务调用次数和时间的监控中心</p><h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h4><p>1、服务容器负责启动，加载，运行服务提供者<br>2、服务提供者在启动时，向注册中心注册自己提供的服务。<br>3、服务消费者在启动时，向注册中心订阅自己所需的服务。<br>4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p><p>Dubbo提供了三大核心能力：<strong>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</strong>。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>Dubbo 负载均衡是体现在服务层面的，内置了 4 种负载均衡策略:</p><p>RandomLoadBalance:随机负载均衡。随机的选择一个。是Dubbo的默认负载均衡策略。<br>RoundRobinLoadBalance:轮询负载均衡。轮询选择一个。<br>LeastActiveLoadBalance:最少活跃调用数，相同活跃数的随机。活跃数指调用前后计数差。使慢的 Provider 收到更少请求，因为越慢的 Provider 的调用前后计数差会越大。<br>ConsistentHashLoadBalance:一致性哈希负载均衡。相同参数的请求总是落在同一台机器上。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring</title>
    <url>/sr/post/2020-02-03-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-02-03-Spring/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><p>Spring 是一个非侵入式的轻量级容器框架，它可以帮我们管理对象及其依赖关系，还提供像通用日志记录、性能统计、安全控制、异常处理等面向切面的能力，还能帮我管理最头疼的数据库事务，本身提供了一套简单的 JDBC 访问实现，提供与第三方数据访问框架集成（如 Hibernate、JPA），与各种 Java EE 技术整合（如 Java Mail、任务调度等等），提供一套自己的 Web 层框架 Spring MVC、而且还能非常简单的与第三方 web 框架集成，相当于<strong>胶水</strong>的作用</p><div class="note info"><p>框架是一组程序的集合，包含了一系列的最佳实践，作用是解决某个领域的问题，框架提供了骨架（通用代码），而程序设计者只需要提供血肉（业务逻辑代码）就行了。</p></div><h3 id="Spring-做了什么"><a href="#Spring-做了什么" class="headerlink" title="Spring 做了什么?"></a>Spring 做了什么?</h3><p>a.传统程序开发，创建对象及组装对象间依赖关系由我们在程序内部进行控制，这样会造成程序的高度耦合，如果我们要修改对象间的依赖关系就必须修改源代码，重新编译、部署；此时而如果引入 Spring ，则由 Spring 这个第三者来集中化管理配置并提供这些资源，也降低了程序之间的耦合。</p><p>b.将日志记录、性能监测、权限控制、事务处理、异常处理等等系统层面的代码从业务逻辑代码中分离，从而对业务逻辑的各个部分进行隔离，提高了系统层代码的重用性，也同时降低了程序之间的耦合，提高了开发效率。</p><h3 id="Spring-主要模块"><a href="#Spring-主要模块" class="headerlink" title="Spring 主要模块"></a>Spring 主要模块</h3><p><img data-src="https://s2.ax1x.com/2020/02/10/15z5d0.png" alt="Spring 主要模块"></p><center><h4>「数据访问/集成」</h4></center><p>由 spring-jdbc，spring-orm，spring-oxm，spring-jms 和 spring-tx 模块组成。</p><p>spring-jdbc 模块提供了一个JDBC –抽象层，消除了需要的繁琐的JDBC编码和数据库厂商特有的错误代码解析。</p><p>spring-tx 模块支持用于实现特殊接口和所有POJO（普通Java对象）的类的编程和声明式事务 管理。</p><p>spring-orm 模块为流行的对象关系映射(object-relational mapping )API提供集成层，包括JPA和Hibernate。使用spring-orm模块，您可以将这些O / R映射框架与Spring提供的所有其他功能结合使用，例如前面提到的简单声明性事务管理功能。</p><p>spring-oxm 模块提供了一个支持对象/ XML映射实现的抽象层，如JAXB，Castor，JiBX和XStream。</p><p>spring-jms 模块(Java Messaging Service) 包含用于生产和消费消息的功能。自Spring Framework 4.1以来，它提供了与 spring-messaging模块的集成。</p><center><h4>「Web」</h4></center><p>由spring-web，spring-webmvc 和 spring-websocket，spring-Webflux 4个模块组成。</p><p>spring-web 模块提供基本的面向Web的集成功能，例如多部分文件上传功能，以及初始化一个使用了Servlet侦听器和面向Web的应用程序上下文的IoC容器。它还包含一个HTTP客户端和Spring的远程支持的Web相关部分。</p><p>spring-webmvc 模块（也称为Web-Servlet模块）包含用于Web应用程序的Spring的模型-视图-控制器(MVC)和REST Web Services实现。 Spring的MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。</p><p>spring-websocket 模块主要是与Web前端的全双工通讯的协议。</p><p>spring-Webflux是一个新的非堵塞函数式 Reactive Web框架，可以用来建立异步的，非阻事件驱动的服务，并且扩展性非常好。</p><center><h4>「AOP 和设备支撑」</h4></center><p>由 spring-aop、 spring-aspects 和 spring-Instrument 3 个模块组成。</p><p>提供了 AOP（拦截器）机制，提供了符合 AOP Alliance 规范的面向切面的编程实现，让你可以定义，例如方法拦截器（method-interceptors）和切入点（pointcuts），从逻辑上讲，从而减弱代码的功能耦合，清晰的被分离开。而且，利用 source-level 的元数据功能，还可以将各种行为信息合并到你的代码中。</p><center><h4>「Core Container」</h4></center><p>由 spring-beans，spring-core， spring-context，spring-context-support，和 spring-expression （Spring表达式语言）。</p><p>spring-core和spring-beans模块提供了框架的基础功能，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模式的实现。你不再需要编程去实现单例模式，允许你把依赖关系的配置和描述从程序逻辑中解耦。</p><p>上下文（spring-context）模块建立在由Core和Beans模块提供的坚实的基础上：它提供一个框架式的对象访问方式，类似于一个JNDI注册表。上下文模块从Beans模块继承其功能，并添加支持国际化（使用，例如，资源集合），事件传播，资源负载，并且透明创建上下文，例如，Servlet容器。Context模块还支持Java EE的功能，如EJB，JMX和基本的远程处理。ApplicationContext接口是Context模块的焦点。 spring-context-support支持整合普通第三方库到Spring应用程序上下文，特别是用于高速缓存（ehcache，JCache）和调度（CommonJ，Quartz）的支持。</p><p>spring-expression模块提供了强大的表达式语言去支持查询和操作运行时对象图。这是对JSP 2.1规范中规定的统一表达式语言（unified EL）的扩展。该语言支持设置和获取属性值，属性分配，方法调用，访问数组，集合和索引器的内容，逻辑和算术运算，变量命名以及从Spring的IoC容器中以名称检索对象。 它还支持列表投影和选择以及常见的列表聚合。</p><p><strong>Core Container 模块整合了 Beans，Core，Context，SpEL，主要的功能是实现了反向控制 IOC（Inversion of Control）与依赖注入 DI（Dependency Injection）、Bean 配置以及加载，其中涉及到的有 Beans、BeanFactory、BeanDefinitions、ApplicationContext、Spring 的 EL 表达式等几个重要概念。</strong></p><center><h4>「Test」</h4></center><p>主要为测试提供支持的，毕竟在不需要发布（程序）到你的应用服务器或者连接到其他企业设施的情况下能够执行一些集成测试或者其他测试对于任何企业都是非常重要的。</p><p>SpEL支持在表达式中使用多种类型的运算符，具体情况如上图所示。SpEL默认的格式为#{expression}。当然，它也支持嵌套一般的属性获取符${properties}，如#{${someProperty} + 2}。这些值可以使用@Value(“”)注释注入到相应的属性上。</p><h3 id="IoC-容器"><a href="#IoC-容器" class="headerlink" title="IoC 容器"></a>IoC 容器</h3><p><strong>什么是 IoC?</strong></p><p>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低程序之间的耦合度(松耦合)，当 Spring 应用了 IoC ，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖的目标对象，它描述了对象的定义和依赖的一个过程，也就是说，依赖的对象通过构造函数、工厂方法参数或者属性注入，当对象实例化后依赖的对象才被创建，当创建 bean 后容器注入这些依赖对象。这个过程基本上是反向的，因此命名为控制反转（IoC），它通过直接使用构造类来控制实例化，或者定义它们之间的依赖关系，或者类似于服务定位模式的一种机制。IoC 与 JNDI 相反 —— JNDI 不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它</p><p>IoC 主要实现形式有两种:<br><strong>依赖注入(Dependency Injection)</strong><br>依赖查找(Dependency Lookup)</p><p>Spring 提供了好几种的方式来给属性赋值</p><p>1) 通过<code>构造函数</code><br>2) 通过<code>setter</code><br>3) 通过<code>p命名空间</code><br>4) 通过<code>自动装配</code><br>5) 通过<code>注解</code></p><p><strong>什么是 Bean?</strong></p><p>Bean 是被实例化的，组装的以及被 Spring 容器管理的 Java Bean 对象，Spring 容器会自动完成 @Bean 对象的实例化。创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质</p><h4 id="spring-中容器"><a href="#spring-中容器" class="headerlink" title="spring 中容器"></a>spring 中容器</h4><p><code>org.springframework.beans和org.springframework.context</code>是 Spring 框架中 IoC 容器的基础，<code>BeanFactory</code>接口提供一种高级的配置机制能够管理任何类型的对象。<code>ApplicationContext</code>是<code>BeanFactory</code>的子接口。它能更容易集成 Spring 的 AOP 功能、消息资源处理（比如在国际化中使用）、事件发布和特定的上下文应用层比如在网站应用中的<code>WebApplicationContext</code>。</p><p>常见实现类:<br>FileSystemXmlApplicationContext: 独立的 XML 应用程序上下文，从文件系统或 URL 获取上下文定义文件<br>ClassPathXmlApplicationContext: 独立的 XML 应用程序上下文，从类路径获取上下文定义文件<br>AnnotationConfigApplicationContext: 独立的注解应用程序上下文，接受组件类的字节码作为输入 获取上下文定义文件</p><p><img data-src="https://s2.ax1x.com/2020/02/06/160ofe.png" alt="UML 类图"></p><p>BeanFactory 和 ApplicationContext 的区别：</p><p>1、创建 Bean 的时间点</p><p>ApplicationContext—–读取完配置文件，立即加载 Bean (适用单例)<br>BeanFactory————读取完配置文件，延迟加载 Bean (适用多例)</p><p>在 Spring 中总体来看可以通过三种方式来配置对象:</p><p>a.使用 XML 文件配置<br>b.使用注解来配置（Spring 2.5）<br>c.使用 JavaConfig 来配置 （Spring 3.0）</p><p>Spring JavaConfig 是 Spring 社区的产品，它提供了一种纯 Java 方法来配置 Spring IoC 容器。因此，它有助于避免使用 XML 配置。涉及注解 @Configuration,@Bean,@Import和@DependsOn</p><h4 id="spring-管理-Bean"><a href="#spring-管理-Bean" class="headerlink" title="spring 管理 Bean"></a>spring 管理 Bean</h4><p><strong>创建 Bean 的三种方法</strong></p><p>使用默认构造器(一步)创建：某个类的默认构造器自动创建<br>使用静态工厂(一步)创建：某个类中的静态方法创建对象，并存入 spring 容器<br>使用实例工厂(两步)创建：某个类中的方法创建对象，并存入 spring 容器</p><p><strong>基于 XML 配置元数据完整的配置文件命名空间如下</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:c</span>=<span class="string">"http://www.springframework.org/schema/c"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:cache</span>=<span class="string">"http://www.springframework.org/schema/cache"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:lang</span>=<span class="string">"http://www.springframework.org/schema/lang"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:util</span>=<span class="string">"http://www.springframework.org/schema/util"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">		http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd "</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这里写 bean 的配置和相关引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 在这里写 bean 的配置和相关引用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 在这里配置更多的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 默认在启动时是要从配置的命名空间的位置加载 XSD 文件来验证 xml 文件的，所以如果有的时候断网了，或者一些开源软件切换域名，那么就很容易碰到应用启动不了。<br>为了防止这种情况，Spring 提供了一种机制，即默认从本地加载 XSD 文件，当本地没有时才根据实际的URI去联网获得。</p><p>命名空间是为了防止相同标签解析冲突（添加命名空间相当于添加了前缀来隔开），而 shema 对应的地址（.xsd文件）规定了文件应该遵循的规则（比如标签怎么写等等）。</p><div class="note info"><p><code>&lt;beans&gt;</code>元素：xmlns 名称空间如<code>xmlns:p xmlns:mvc 、xmlns:tx 、xmlns:context</code>等等，xsi(xml schema instance)是指此 xml文件遵守的规范，xsi:schemaLocation 是指具体用到的 schema 文件资源位置。<br><code>&lt;bean&gt;</code>元素：id 属性用来使用标识每个独立的 bean 定义的字符串。class 属性定义了 bean 的类型，这个类型必须使用全路径类名（必须是包路径+类名）。id 属性值可以被其他依赖对象引用。</p></div><p><strong>Bean 的五大作用域</strong>：通过<code>&lt;bean&gt;</code>的<code>scope</code>属性指定</p><p>singleton：单例的（默认）<br>prototype：多例的<br>request：作用于 web 的请求<br>session：作用于 web 的会话<br>global-session：作用于集群环境下 web 的会话（全局会话），所有子服务器共享此 Bean</p><p><strong>为什么用单例/多例的对象?</strong></p><p>之所以用单例，是因为没必要每个请求都新建一个对象，这样既浪费CPU又浪费内存；<br>之所以用多例，是为了防止并发问题；即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理；</p><p>用单例和多例的参考：当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例，否则单例；<br>所谓单例就是所有的请求都用一个对象来处理，比如我们常用的 service 和 dao 层的对象通常都是单例的，<br>而多例则指每个请求用一个新的对象来处理，比如 action(controller);</p><p><strong>Bean 的生命周期方法</strong><br>通过<code>&lt;bean&gt;</code>的<code>init-method</code>属性指定初始化时调用方法，<code>destroy-method</code>指定销毁时调用的方法。<br>或者通过注解：<code>@PostConstruct</code>和<code>@PreDestroy</code></p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>使用注解时，必须的 xml 约束</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"指定注解扫描的包"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span>&gt;</span>...<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>常见注解</strong></p><p>a.用于定义 bean：把普通pojo实例化到spring容器中，相当于配置文件中的<code>&lt;bean id=&quot;&quot; class=&quot;&quot;/&gt;</code></p><p>@Component<br>├─ @Controller<br>├─ @Service<br>├─ @Repository</p><p>b.用于注入 bean：</p><p>以下三个注解只能注入其他 bean 类型的数据，而基本类型和 string 类型不能使用</p><p>@Autowired 按类型自动装配<br>@Qualifier、@Primary 按名称手动装配(需搭配 @Autowired 使用)<br>@Resource 按 bean 的 id注入(独立完成手动装配)</p><p><em>注：@Resource 是JDK自带的，包路径为<code>javax.annotation.Resource</code>，@Resource 的作用相当于 @Autowired，只不过两者来自不同家族，默认装配策略不同而已， @Autowired 默认按照 byType 自动注入，@Resource 默认按照 byName 自动注入。</em></p><p>在Spring3.0之后，有效的自动装配策略分为<code>byType</code>、<code>byName</code>、<code>constructor</code>三种方式。<code>@Autowired</code>默认使用 byType 来自动装配，如果存在类型的多个实例就尝试使用 byName 匹配，如果通过 byName 也确定不了，可以通过<code>@Primary</code>和<code>@Priority</code>来确定</p><p>@Required 表明必须在配置时通过 bean 定义中的显式属性值或通过自动装配来填充受影响的 bean 属性。如果受影响的 bean 属性尚未填充，则容器将引发异常；否则，容器将抛出异常。</p><p>@Value 注解可用于注入基本类型和 String 类型的数据(SpEL)</p><p>@Value(“#{}”) 表示<strong>使用SpEl表达式</strong>来获取bean的属性，或者调用bean的某个方法。当然还有可以表示常量<br>@Value(“${}”) 表示注入外部配置文件对应的<code>property</code>(默认)</p><p>c.用于改变 bean 生命周期：</p><p>@Scope<br>├─ @PostConstruct：指定初始化时执行的方法<br>├─ @PreDestroy：指定销毁时执行的方法</p><p>d.新注解：（可完全脱离 xml 配置）</p><p>@Configuration: 指定为配置类，获取配置时需要使用 AnnotationApplicationContext<br>@Componentscan: 指定需要扫描的包<br>@Bean: 用于将当前方法返回值作为 Bean 存入容器,若方法存在参数，则按照<strong>Autowired 注解的自动注入的方式</strong>来查找到参数<br>@Import: 用于指定导入的<strong>子配置类组件</strong>的字节码<br>@PropertySources/@PropertySource: 用于指定<code>.properties</code>文件位置<br>@PostConstruct注解的方法将会在依赖注入完成后被自动调用</p><p>e.集成 junit</p><p>1.导入 spring 整合 junit 的坐标<br>2.使用 junit 的 @Runwith 指定新运行器替换原有的运行器<br>3.使用 spring 的 @ContexConfiguration 注解指定 spring 配置文件的位置<br>4.使用 spring 的 @Autowired 注解注入测试类中的成员</p><h4 id="依赖注入-Dependency-Injection"><a href="#依赖注入-Dependency-Injection" class="headerlink" title="依赖注入 Dependency Injection"></a>依赖注入 Dependency Injection</h4><p>DI 通常用于不常变化的数据注入，由于您可以混合使用基于构造函数的 DI 和基于 setter 的 DI，因此，将构造函数用于<em>强制性依赖项</em>，将setter 方法<em>用于可选性依赖项</em>是一个很好的经验法则。请注意，在 setter 方法上使用 @Required 注解可用于使属性成为必需的依赖项。</p><p><code>构造函数注入</code>: constructor-arg 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id），常用于注入到第三方 jar 包中的类</p><p><code>Setter 注入</code>：property 标签（name 属性指定参数名，value 属性指定参数值，ref 属性指定参数引用的其他 Bean 的 id）<strong>可避免通过构造函数注入产生的基于 xml 循环依赖问题</strong></p><p>对于使用 Spring 框架的开发人员来说，我们主要做的主要有两件事情：①开发 Bean;②配置 Bean;而 Spring 帮我们做的就是根据配置文件来创建Bean 实例，并调用 Bean 实例的方法来完成“依赖注入”，可以把 Spring 容器理解成一个大型工厂，Bean 就是该工厂的产品，工厂( Spirng 容器)里能生产出来什么样的产品(Bean)，完全取决于我们在配置文件中的配置。其实就是根据配置文件产生对象,而不需要人为的手动去创造对象,降低了耦合</p><p>用处不同：传统 javabean 更多地作为值传递参数，而spring中的bean用处几乎无处不在，任何组件都可以被称为bean<br>写法不同：传统 javabean 作为值对象，要求每个属性都提供getter和setter方法；但spring中的bean只需为接受设值注入的属性提供setter方法</p><hr><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><p><strong>什么是 AOP?</strong></p><p>AOP 面向切面编程是 OOP 的延续，是一个概念，一个规范，OOP 中模块化的关键单元是类，而在 AOP 中模块化的关键单元是切面。面向切面编程则是希望能够将通用需求功能从不相关的类当中分离出来，能够使得很多类共享一个行为，一旦发生变化，不必修改很多类，而只需要修改这个行为即可。</p><p><strong>AOP 其实是一种正交化编程设计思想，假设把应用程序想成一个立体结构的话，OOP 思想就是将利刃是纵向水平切入系统，把系统划分为很多个模块（如：用户模块，文章模块等等），而 AOP 思想的利刃是横向垂直切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录，事务控制等等）</strong></p><p>Spring 提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。</p><p>底层实现原理就是<strong>动态代理</strong>，通过代理控制对象的访问，实现方法的增强。</p><p><strong>Maven引入AOP</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">versio</span>&gt;</span>1.8.7<span class="tag">&lt;/<span class="name">versio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="JDK-动态代理（接口）"><a href="#JDK-动态代理（接口）" class="headerlink" title="JDK 动态代理（接口）"></a>JDK 动态代理（接口）</h4><p>Spring AOP 默认将标准 JDK 动态代理用于 AOP 代理，这使得可以代理任何接口（或一组接口）。</p><h4 id="CGLIB-动态代理（子类）"><a href="#CGLIB-动态代理（子类）" class="headerlink" title="CGLIB 动态代理（子类）"></a>CGLIB 动态代理（子类）</h4><p>Spring AOP 也可以使用 CGLIB 动态代理。这时对于代理类而不是接口是必需的。如果业务对象未实现接口，则默认情况下使用 CGLIB 。最好的做法是对接口进行编程，而不是对类进行编程。业务类通常将实现一个或多个业务接口。在那些需要建议在接口上未声明的方法，或者需要将代理对象作为具体类型传递给方法的情况下（在极少数情况下），可以 强制使用 CGLIB。</p><h4 id="AOP-相关术语"><a href="#AOP-相关术语" class="headerlink" title="AOP 相关术语"></a>AOP 相关术语</h4><p><code>连接点(Joinpoint)</code>: 被拦截到的点，Spring 只支持方法类型的连接点,具体体现形式就是<strong>Service 层接口中的所有方法</strong>,它连接我们的业务和增强的方法<br><strong><code>切入点(Pointcut)</code></strong>: 指我们要对哪些 Joinpoint 拦截定义,具体体现形式就是 <strong>Service 层接口中被动态代理增强的方法</strong><br><strong><code>通知/增强(Advice)</code></strong>: 指拦截到 Joinpoint 后做的事情,通知类型:前置通知/后置通知/异常通知/最终通知/环绕通知(环绕通知是spring 提供的一种可以在代码中手动控制增强方法何时执行的方式)<br><code>引介(Introduction)</code>: 是一种特殊的通知,在不修改类代码前提下,可在运行期为类动态地添加一些 Method/Field<br><code>目标对象(Target)</code>: 代理的目标对象(被代理的类)<br><code>织入(Weaving)</code>: 将增强代码应用到目标对象来创建新的代理对象的过程, Spring 采用动态代理织入,AspectJ 采用编译期织入和类装载织入<br><code>代理对象(Proxy)</code>: 一个类被 AOP 织入增强后的产物(代理类)<br><strong><code>切面(Aspect)</code></strong>: 是<strong>切入点和通知(引介)的结合</strong>，在 Spring 中，切面一般使用<code>@Aspect</code>来使用，在 XML 中，可以使用 <code>&lt;aop:aspect&gt;</code>来定义一个切面。</p><p><strong>静态织入</strong></p><p><code>编译期</code>: 切面在目标类编译时被织入，这种方式需要特殊的编译器。AspectJ 的织入编译器就是以这种方式织入切面的。<br><code>类加载期</code>: 切面在目标类加载到 JVM 时被织入，这种方式需要特殊的类加载器( ClassLoader )，它可以在目标类引入应用之前增强目标类的字节码。<br><code>运行期</code>: 切面在应用运行的某个时期被织入。一般情况下，在织入切面时，AOP容器会为目标对象动态创建一个代理对象，Spring AOP 采用的就是这种织入方式。</p><h4 id="Spring-AOP-干了啥？"><a href="#Spring-AOP-干了啥？" class="headerlink" title="Spring AOP 干了啥？"></a>Spring AOP 干了啥？</h4><p>Spring 框架监控切入点方法的执行,一旦监控到切入点方法被执行,将使用代理机制,动态创建目标对象的代理对象,根据通知类别,在代理对象的对应通知位置,将通知对应功能织入,完成完整代码的逻辑运行</p><div class="note primary"><p>Spring 文档中写到：Spring AOP 部分使用 JDK 动态代理或者 CGLIB 来为目标对象创建代理，如果被代理的目标对象实现了至少一个接口，则会使用 JDK 动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。</p></div><p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种</p><h4 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p>// TODO</p><hr><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><h4 id="编码式事务"><a href="#编码式事务" class="headerlink" title="编码式事务"></a>编码式事务</h4><h4 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h4><p><strong>声明式事务</strong>以方法为单位，进行事务控制；抛出异常，事务回滚，最小的执行单位为方法。决定执行成败是通过是否抛出异常来判断的，抛出异常即执行失败，这里所说的声明，就是指在配置文件中声明。用在 Spring 配置文件中声明式的处理事务来代替代码式的处理事务。</p><p>声明式事务管理也有两种常用的方式：</p><p>基于<code>&lt;tx&gt;</code>和<code>&lt;aop&gt;</code>命名空间的xml配置文件；<br>基于<code>@Transactional</code>注解。</p><p><strong>好处</strong></p><p>非侵入式：事务管理不侵入开发的组件<br>插拔方便：不需要事务管理的时候，直接移除配置即可</p><p>PlatformTransactionManager 此接口是 Spring 的事务管理器，它里面提供了我们常用的操作事务的方法</p><p><strong>常见失效场景</strong></p><ul><li>如果使用 MySQL 且引擎是 MyISAM，则事务会不起作用，原因是 MyISAM 不支持事务，改成 InnoDB 引擎则支持事务。</li><li>注解 @Trasactional 只能加在 public 修饰的方法上事务才起效。如果加在 protect、private 等非 public 修饰的方法上，事务将失效。<br>如果在开启了事务的方法内，使用了 try-catch 语句块对异常进行了捕获，而没有将异常抛到外层，事务将不起效。</li><li>如果 A 方法开启了事务，B 方法没有开启事务，B 方法调用了 A 方法。如果 B 方法发生异常中，但不是调用的 A 方法产生的，则异常不会使 A 方法的事务回滚，此时事务无效。如果 B 方法发生异常中，异常是调用的 A 方法产生的，则 A 方法的事务回滚，此时事务有效。在 B 方法上加上注解 @Trasactional，这样 A 和 B 方法就在同一个事务里了，不管异常产生在哪里，事务都是有效的。</li><li>简单地说，当存在方法之间调用时，异常发生在无事务的方法中，但不是被调用的方法产生的，被调用的方法的事务无效。只有异常发生在开启事务的方法内，事务才有效。</li><li>如果使用了Spring + MVC，则 context:component-scan 重复扫描问题可能会引起事务失效。</li></ul><div class="note primary"><p>Spring 团队建议在具体的类（或类的方法）上使用 @Transactional ，而不要使用在类所要实现的任何接口上。在接口上使用 @Transactional，只能当你设置了基于接口的代理时它才生效。因为注解是不能继承的，这就意味着如果正在使用基于类的代理时，那么事务的设置将不能被基于类的代理所识别，而且对象也将不会被事务代理所包装。</p></div><p><strong>真正进行管理事务的对象（JDBC）</strong>: <code>org.springframework.jdbc.datasource.DataSourceTransactionManager</code>事务管理器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring 中基于 XML 的声明式事务控制配置步骤</span><br><span class="line"></span><br><span class="line">1、配置事务管理器 </span><br><span class="line">2、配置事务的通知</span><br><span class="line">  此时我们需要导入事务的约束 tx名称空间和约束，同时也需要aop的</span><br><span class="line">  使用tx:advice标签配置事务通知</span><br><span class="line">      属性：</span><br><span class="line">          id：给事务通知起一个唯一标识</span><br><span class="line">          transaction-manager：给事务通知提供一个事务管理器引用</span><br><span class="line">3、配置AOP中的通用切入点表达式</span><br><span class="line">4、建立事务通知和切入点表达式的对应关系</span><br><span class="line">5、配置事务的属性</span><br><span class="line">        是在事务的通知tx:advice标签的内部</span><br></pre></td></tr></table></figure><p><strong>事务的定义信息对象</strong></p><p><code>TransactionDefinition</code>维护的事务属性有以下五个</p><h5 id="传播行为-propagation"><a href="#传播行为-propagation" class="headerlink" title="传播行为 propagation"></a>传播行为 propagation</h5><p>REQUIRED: 需要事务,外部存在事务融入当前事务,外部没有事务,开启新的事务<br>SUPPORTS: 支持事务,外部存在事务融入当前事务,外部没有事务,不开启新的事务<br>REQUIRES_NEW: 每次开启新的事务,如果外部存在事务外部事务挂起,开启新的事务运行,运行结束后回复外部事务<br>NOT_SUPPORTED: 不支持事务,如果外部存在事务外部事务挂起,已非事务方式运行.<br>NEVER: 不支持事务,存在事务报错<br>MANDATORY: 强制事务没有事务报错<br>NESTED: 嵌套事务,数据库不支持</p><h5 id="隔离级别-isolation"><a href="#隔离级别-isolation" class="headerlink" title="隔离级别 isolation"></a>隔离级别 isolation</h5><p>DEFAULT: 采用数据库默认隔离级别<br>READ_UNCOMMITTED: 读未提交<br>READ_COMMITTED: 读提交 用来避免脏读现象出现的 oracle 默认隔离级别<br>REPEATABLE_READ: 可重复读 是用来避免不可重复读现象出现的 (在一次事务中一方更新,导致两次查询结果不一致这种情况叫不可重复读) mysql 默认隔离级别<br>SERIALIZABLE : 可串行化读 用来避免幻影读现象出现 (在一次事务中一方插入,导致两次查询结果不一致这种情况叫幻读)</p><h5 id="读写性-readonly"><a href="#读写性-readonly" class="headerlink" title="读写性 readonly"></a>读写性 readonly</h5><p>只读事务内，不能增加、修改、删除内容，否则报Cannot execute statement in a READ ONLY transaction。<br>只读事务内，只能读取到执行时间点前的内容，期间修改的内容不能读取到。<br>只读事务作为 ORM 框架优化执行的一个暗号，比如放弃加锁，或者flush never</p><p>关于只读事务：</p><p><strong>MySQL 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现 Cannot execute statement in a READ ONLY transaction，注意 Oracle 不支持此配置</strong></p><p>网上的各种资料里众说纷纭：</p><p>“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。<br>但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。<br>因此，“只读事务” 仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 一般配置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 增删改 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span> <span class="attr">isolation</span>=<span class="string">"SERIALIZABLE"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 查询 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">isolation</span>=<span class="string">"SERIALIZABLE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h5 id="超时性-timeout"><a href="#超时性-timeout" class="headerlink" title="超时性 timeout"></a>超时性 timeout</h5><p>timeout: -1 永不超时</p><h5 id="回滚性-rollback-for-amp-amp-no-rollback-for"><a href="#回滚性-rollback-for-amp-amp-no-rollback-for" class="headerlink" title="回滚性 rollback-for &amp;&amp; no-rollback-for"></a>回滚性 rollback-for &amp;&amp; no-rollback-for</h5><p>rollback-for: 遇到什么异常类回滚<br>no-rollback-for: 遇到什么异常类不回滚</p><p><strong>以上两个属性都不设置时，表示遇到异常都回滚</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"save*"</span> <span class="attr">rollback-for</span>=<span class="string">""</span> <span class="attr">no-rollback-for</span>=<span class="string">""</span> <span class="attr">propagation</span>=<span class="string">"REQUIRES_NEW"</span> <span class="attr">read-only</span>=<span class="string">"true"</span> <span class="attr">isolation</span>=<span class="string">"SERIALIZABLE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="编码式事务-1"><a href="#编码式事务-1" class="headerlink" title="编码式事务"></a>编码式事务</h4><p>TransactionTemplate 事务模板</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN</title>
    <url>/sr/post/2020-01-12-%E6%9D%82%E9%A1%B9-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7-2020-01-12-SVN/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="SVN使用规范"><a href="#SVN使用规范" class="headerlink" title="SVN使用规范"></a>SVN使用规范</h2><ul><li><strong>先更新，再提交</strong></li></ul><p>SVN更新的原则是要随时更新，随时提交。当完成了一个小功能，能够通过编译并且自己测试之后，谨慎地提交。</p><p>如果在修改的期间别人也更改了svn的对应文件，那么commit就可能会失败。如果别人和自 己更改的是同一个文件，那么update时会自动进行合并，如果修改的是同一行，那么合并时会产生冲突，这种情况就需要同之前的开发人员联系，两个人一起协商解决冲突，解决冲突之后，需要两人一起测试保证解决冲突之后，程序不会影响其他功能。</p><p>在更新时注意所更新文件的列表，如果提交过程中产生了更新，则也是需要重新编译并且完成自己的一些必要测试，再进行提交。这样既能了解别人修改了哪些文件，同时也能避免SVN合并错误导致代码有错。</p><ul><li><strong>多提交</strong></li></ul><p>每次提交的间歇尽可能地短，以几个小时的开发工作为宜。例如在更改UI界面的时候，可以每完成一个UI界面的修改或者设计，就提交一次。在开发功能模块的时候，可以每完成一个小细节功能的测试，就提交一次，在修改bug的时候，每修改掉一个bug并且确认修改了这个bug，也就提交一次。我们提倡多提交，也就能多为代码添加上保险。</p><ul><li><strong>不要提交不能通过编译的代码</strong></li></ul><p>代码在提交之前，首先要确认自己能够在本地编译。如果在代码中使用了第三方类库，要考虑到项目组成员中有些成员可能没有安装相应的第三方类库。项目经理在准备项目工作区域的时候，需要考虑到这样的情况，确保开发小组成员在签出代码之后能够在统一的环境中进行编译。</p><ul><li><strong>每次提交必须写明注释</strong></li></ul><p>在一个项目组中使用SVN，如果提交空的标注或者不确切的标注将会让项目组中其他的成员感到很无奈，项目经理无法很清晰的掌握工作进度，无法清晰的把握此次提交的概要信息。在发现错误后也无法准确的定位引起错误的文件。所以，在提交工作时，要填写明晰的标注，能够概要的描述所提交文件的信息，让项目组其他成员在看到标注后不用详细看代码就能了解你所做的修改。</p><ul><li><strong>不要提交本地自动生成的文件</strong></li></ul><p>例如 IDEA 里面的 <code>.idea</code> 文件和 maven 项目编译之后的文件 target 文件</p><h2 id="IDEA-集成-SVN"><a href="#IDEA-集成-SVN" class="headerlink" title="IDEA 集成 SVN"></a>IDEA 集成 SVN</h2><p><strong>先共享在提交</strong>：<code>import into version control</code></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL</title>
    <url>/sr/post/2020-01-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98-2020-01-11-SQL/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><div class="note info"><p>数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS</p></div><h1 id="SQL必知必会"><a href="#SQL必知必会" class="headerlink" title="SQL必知必会"></a>SQL必知必会</h1><h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>表中的任何列都可以作为主键，只要它满足以下条件：</p><ul><li><p>任意两行都不具有相同的主键值；</p></li><li><p>每一行都必须具有一个主键值（主键列不允许 NULL 值）；</p></li><li><p>主键列中的值不允许修改或更新；</p></li><li><p>主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）</p></li></ul><h2 id="字段（field）"><a href="#字段（field）" class="headerlink" title="字段（field）"></a>字段（field）</h2><p>基本上与列（column）的意思相同，不过数据库列一般称为列，而术语字段通常与计算字段一起使用。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>SQL 是一种专门用来与数据库沟通的语言。它专门用来跟数据库沟通的语言。</p><p>设计SQL的目的是<strong>提供一种从数据库中读写数据的简单有效方法</strong></p><blockquote><p>SQL 语句不区分大小写<br>多条 SQL 语句必须以分号（；）分隔<br>在处理 SQL 语句时，其中所有空格都被忽略</p></blockquote><blockquote><p>子句（clause）<br>SQL 语句由子句构成，有些子句是必需的，有些则是可选的。一个子<br>句通常由一个关键字加上所提供的数据组成。</p></blockquote><h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><ul><li><p>SELECT</p><ul><li><p>查询单列 <code>SELECT name FROM students;</code></p><p>从students表中查询出一个名为name的列，所需要查询的列名跟在SELECT后面，</p></li></ul><p>FROM关键字指出从哪个表中查询。</p><ul><li><p>查询多列 <code>SELECT name， age FROM students；</code></p><p>此SQL指定了两个列名，用逗号分隔。</p></li><li><p>查询所有列 <code>SELECT * FROM students；</code></p><p>给定一个通配符（*），则返回表中所有列。</p></li><li><p>查询非重复值 <code>SELECT DISTINCT age FROM students；</code></p><p>使用<code>DISTINCT</code>关键字排除年龄相同的学生，它必须放在列名的前面。</p></li><li><p>限制查询 <code>SELECT name FROM students LIMIT 2 OFFSET 3;</code></p><p>使用<code>LIMIT</code>关键字限制查询的条数为两条，<code>OFFSET</code>后跟行号（此行不参与查询）</p><p>简化版 <code>SELECT name FROM students LIMIT 3，2;</code></p><p>此时，逗号之前的值对应省略的 OFFSET ，逗号之后的值对应 LIMIT</p></li><li><p>聚合函数</p><ul><li>count(列名)，统计记录条数，若列中可能有值为null，可以使用 ifnull(字段名，默认值) 例：select count(ifnull(total，0)) from user 将 null 的记录的赋值为 0</li><li>max(列名)，统计列中最大值</li><li>min(列名)，统计列中最小值</li><li>sum(列名)，统计列中数据和</li><li>avg(列名)，求列内平均值</li></ul></li></ul><p>— 分组查询(重点)<br>语法：</p><ul><li><p>场景 1 ：根据性别分组， 并统计每组学生的总人数<br>select sex count(*) from students group by sex;</p></li><li><p>场景 2 ：根据性别分组， 统计组内学生的总人数 &gt; 3 的(分组后筛选)<br>select sex，count(id) sum from user group by sex having sum &gt; 3;</p></li></ul><p>总结：</p><ul><li>根据某一列进行分组， 将分组字段结果中相同内容作为一组; 有几组 返回的记录就有几条</li><li>单独分组 没有意义， 返回每一组的第一条记录</li><li>分组的目的一般为了做统计使用， 所以经常和聚合函数一起使用</li><li>在分组里面， 如果 select 后面的列没有出现在 group by 后面 展示这个组的这个列的第一个数据</li><li>where 和 having 的区别</li></ul></li></ul><table><thead><tr><th>子名</th><th>作用</th></tr></thead><tbody><tr><td>where 子句</td><td>1) 对查询结果进行分组前，将不符合where条件的行去掉，即在分组之前过滤数据，即先过滤再分组。2) where后面不可以使用聚合函数</td></tr><tr><td>having字句</td><td>1) having 子句的作用是筛选满足条件的组，即在分组之后过滤数据，即先分组再过滤。2) having后面可以使用聚合函数</td></tr></tbody></table><ul><li>分页查询</li></ul><p>LIMIT 跳过的数据条数，查询记录条数;</p><h2 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h2><p>1.单列排序</p><p>​<code>SELECT name FROM students ORDER BY age;</code></p><p>从students 表中查询名为 name 的列，并按 age 大小排序。</p><p><strong>ORDER BY 应是SELECT 语句中的最后一条子句。</strong></p><blockquote><p>使用ORDER BY 子句进行升序排序，子句后跟排序的参照列，通常为查询列，也可不为查询的列（查询字段）。</p></blockquote><p>2.多列排序</p><p><code>SELECT name，sex FROM students ORDER BY age，number;</code></p><p>在多个列进行排序时，仅在有相同 age 行时，才会按 number 进行再次排序，否则不会按 number 进行排序。</p><p>​</p><p>按照查询列的相对位置排序</p><p><code>SELECT name，age FROM students ORDER BY 2，1;</code></p><blockquote><p>当不采用查询字段进行排序时，无法使用此技术。</p></blockquote><p>4.指定排序方向</p><p><code>SELECT name FROM students ORDER BY age DESC;</code></p><p>在 ORDER BY 子句后 加上 <code>DESC</code> 关键字，表明此排序为降序排序。升序是默认的，关键字为<code>ASC</code> ，无需手动指定。</p><blockquote><p>在多个列上降序排序<br>如果想在多个列上进行降序排序，必须对每一列指定 DESC 关键字。</p></blockquote><h2 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h2><ul><li><p>WHERE 子句 <strong>应在 表名 （FROM 子句）后给出。</strong></p><p><code>SELECT NAME FROM students WHERE age=8 ;</code></p><p>此语句查询出age = 8 的 name 字段。</p><p><code>SELECT NAME，sex FROM students WHERE sex&lt;&gt;&#39;男&#39; ;</code></p><p>此语句查询出sex不等于男的 name ， sex 字段。</p></li></ul><blockquote><p>何时使用引号?</p><p>如果将值与字符串类型的列进行比较，就需要限定引号。用来与数值列进行比较的值则不用。</p></blockquote><h2 id="高级过滤"><a href="#高级过滤" class="headerlink" title="高级过滤"></a>高级过滤</h2><ul><li><p>组合WHERE 子句（使用圆括号明确分组操作符）</p><ul><li>AND：用来查询<strong>满足所有给定条件</strong>的行。</li><li>OR：用来查询<strong>任一给定条件</strong>的行。</li></ul></li><li><p>IN 操作符</p><p>IN 操作符用来指定条件范围，范围中的每个条件都可以进行匹配</p><p>IN 取一组由逗号分隔、括在圆括号中的合法值</p><p>优点</p><ul><li>更清楚直观</li><li>求值顺序更容易管理</li><li>比一组OR 操作符执行更块</li><li>可以包含其他 SELECT 语句，可以动态建立WHERE 子句</li></ul></li><li><p>NOT 操作符</p><p>NOT 操作符用来否定其后面跟的任何条件，从而排除此条件</p><p>常用于跟 IN 操作符搭配使用过滤</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用于查询排除湖南、杭州的行</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	<span class="keyword">NAME</span>，age，address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	<span class="keyword">NOT</span> address <span class="keyword">IN</span>(<span class="string">'湖南'</span>，<span class="string">'杭州'</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用通配符过滤"><a href="#使用通配符过滤" class="headerlink" title="使用通配符过滤"></a>使用通配符过滤</h2><p>特点：过滤条件未知</p><p>通配符搜索只能用于文本字段（字符串），非文本数据类型字段不能使用通配符搜索。</p><p><strong>LIKE 操作符</strong></p><p>% ：表示任何字符出现的任意次数，单独出现的话将会匹配所有（不包括NULL）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.用于查询出所有以"马"开头的行</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">NAME</span>，age，address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"马%"</span>; </span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 2.用于查询出所有包含"马"的行	</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">NAME</span>，age，address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"%马%"</span>;</span><br></pre></td></tr></table></figure><p>_ ：以单个下划线 _ 表示匹配一个字符</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用于查询出名称为3个字且中第二个字为"马"</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">NAME</span>，age，address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"_马_"</span>;</span><br></pre></td></tr></table></figure><p><del>[ ] ：用来指定一个字符集，必须指定指定位置（通配符的位置）的一个字符</del> （MySQL 中不支持）</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>在 SELECT 语句中，子查询总是从内向外处理。在处理上面的 SELECT 语句时，DBMS 实际上执行了两个操作。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL架构与历史"><a href="#MySQL架构与历史" class="headerlink" title="MySQL架构与历史"></a>MySQL架构与历史</h2><h3 id="MySQL的schema的定义"><a href="#MySQL的schema的定义" class="headerlink" title="MySQL的schema的定义"></a>MySQL的schema的定义</h3><p><strong>schema 就是数据库对象的集合，所谓的数据库对象也就是常说的表，索引，视图，存储过程等</strong></p><blockquote><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字 SCHEMA 替代 DATABASE ，例如使用<code>CREATE SCHEMA</code>来代替<code>CREATE DATABASE</code>。</p><p>​ 在MySQL中基本认为schema和数据库相同，也就是说schema的名称和数据库的实例的名称相同，一个数据库有一个schema</p></blockquote><h3 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h3><ul><li>服务器层的服务</li><li>查询执行引擎</li><li>存储引擎</li></ul><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><h5 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h5><ul><li><p>读锁/S锁/共享锁</p><p>读锁是共享的，或者说是互不阻塞。多个客户可以同时读取同一数据，而互不干扰。</p></li></ul><ul><li><p>写锁/X锁/排他锁</p><p>写锁是排他的，一个写锁会阻塞（排斥）其他的写锁和读锁，以确保同一时间内只有一个用户才能执行写入。</p></li></ul><h5 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h5><ul><li>表锁（table look）：开销最小的策略，是MySQL中最基本的锁策略。</li><li>行级锁（row look）：开销最大的策略，可以最大程度的支持并发处理。</li></ul><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>概念：一组原子性的SQL查询或一个独立的工作单元。</p><h4 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h4><ul><li>原子性（atomicity）：事务必须被视为最小不可分割工作单元，事务中所有操作要么全部成功，要么全部失败回滚。</li><li>一致性（consistency）：数据库总是从一个一致性的状态转为另一个一致性的状态。</li><li>隔离性（isolation）：通常来说并发的事务之间不会互相影响，一个事务所作的修改在最终提交之前，对其他事务是不可见的。</li><li>持久性（durability）：一旦事务提交，则其所做的修改就会永久保存到数据库。</li></ul><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><ul><li><p>读未提交（Read Uncommitted）：事务中的修改即使未提交，对其他事务同样可见</p></li><li><p>读已提交（Read committed）：事务从开始到提交之前，对其他事务不可见</p></li><li><p>可重复读（Repeatable Read）:保证了在同一个事务中多次读取同样的记录结果是一致的（MySQL默认隔离级别）</p></li><li><p>可串行化(Serializable）：通过强制事务串行执行，在读取的每一行数据都加锁。</p></li></ul><table><thead><tr><th>事务隔离级别\出现的问题</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读</td><td>否</td><td>否</td><td>是</td></tr><tr><td>可串行化</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><div class="note info"><p>幻读：指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入/删除了记录，当前事务再次读取该范围记录时，会产生幻行。</p></div><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>什么是死锁？</p><p>死锁指两个或者多个事务在同一资源上相互占用，并请求获取对方的排他锁，从而导致的恶性循环的现象。</p><p>死锁的产生：</p><ul><li>当多个事务试图以不同顺序锁定资源时，就会产生死锁。</li><li>当多个事务同时锁定同一个资源时，也会产生死锁。</li></ul><p>死锁的解决：部分或者完全回滚其中一个事务，才能打破死锁。</p><h4 id="MySQL中的事务"><a href="#MySQL中的事务" class="headerlink" title="MySQL中的事务"></a>MySQL中的事务</h4><p>非事务型的存储引擎：MyISAM、内存表。没有commit和rollback的概念，默认一直处于自动提交（不能回滚）</p><p>MySQL提供两种事务型的存储引擎：<code>InnoDB</code>和 <code>NDB Cluster</code></p><ul><li>使用START TRANSACTION开启事务</li><li>使用COMMIT提交事务</li><li>使用ROLLBACK回滚事务</li></ul><p><strong>MySQL默认使用自动提交事务（AutoCommit），可以通过修改autocommit的value</strong></p><p><strong>0/OFF表示禁用，1/ON表示开启。</strong></p><h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 MVCC"></a>多版本并发控制 MVCC</h3><p>MVCC是行级锁的变种，避免了很多加锁操作，开销更低。</p><p>不同存储引擎的MVCC实现不同，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。</p><p><strong>1.MVCC下InnoDB行为：</strong></p><ul><li>通过在每一行后面保存两个隐藏列（一列保存创建时间，一列保存销毁时间，这里时间指的是系统版本号）。</li><li>每开始一个新事务，系统版本号递增，事务开始时的系统版本号作为此事务的版本号，用来和查询到的每行记录的版本号进行比较。</li></ul><p><strong>2.在Repeatable Readb隔离级别下，具体的MVCC操作：</strong></p><ul><li><p>Select：</p><p>InnoDB将会根据以下两个条件检查每行记录：</p><ul><li>查找版本号小于或等于当前事务的版本号（确保事务读取的行，应在事务开始前已存在或事务自身插入或者修改的）</li><li>行的删除版本号要么未定义，要么大于当前事务的版本号（确保事务读取的行，在事务开始前已被删除）<br><strong>两个条件是必要条件，只要满足才能返回查询结果。</strong></li></ul></li><li><p>Insert：InnoDB为新插入的每一行保存当前系统版本号作为行创建版本号</p></li><li><p>Delete：InnoDB为新删除的每一行保存当前系统版本号作为行删除标识。</p></li><li><p>Update：InnoDB为新插入每一行新记录，保存当前系统版本号作为行创建版本号，同时保存当前系统版本号到原来的行作为行删除标识。</p></li></ul><p>MVCC只工作在Repeatable Read和Read committed隔离级别。</p><p>因为Read Uncommitted读取的行总是最新的</p><p>而Serializable则会对读取的每行进行加锁</p><h3 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h3><h4 id="InnoDB引擎概览"><a href="#InnoDB引擎概览" class="headerlink" title="InnoDB引擎概览"></a>InnoDB引擎概览</h4><p>InnoDB 引擎是MySQL 5.5 及以后的版本<strong>默认事务引擎</strong> ，2008年发布的InnoDB plugin，不支持全文索引（可使用sphinx插件），5.6以后支持了全文索引。<strong>MySQL中规定自增列必须为主键</strong>。</p><ul><li><p>InnoDB的数据存储在表空间（tablespace）或多表空间中</p><p>如果使用多表空间，那么每个表都有一个表空间文件用于存储每个表的数据和索引，文件名以表名开头，以.ibd为扩展名。</p></li><li><p>InnoDB采用MVCC来支持高并发，并且实现了四个标准隔离级别。默认级别为可重复读Repeatable Read），并通过<strong>间隙锁</strong>防止幻读出现。使得InnoDB不仅仅锁定查询涉及行， 还对索引中间的间隙进行锁定，防止幻影行的插入。</p></li><li><p>InnoDB表是基于<strong>聚簇索引建立</strong>，存储格式是平台独立的</p></li><li><p>InnoDB内部的优化：可预测性预读、自适应哈希索引、插入缓冲区</p></li><li><p>InnoDB的行为非常复杂，可参考官方手册的“InnoDB事务模型和锁“</p></li><li><p>InnoDB可以通过一些机制和工具支持真正的热备份</p></li><li><p>InnoDB创建的是索引组织表</p></li></ul><blockquote><p>mysql中每个表都有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p><p>以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。</p><ul><li>如果表上定义有主键，该主键索引是聚集索引。</li><li>如果不定义为表的主键时，MySQL取第一个唯一索引（unique）而且只含非空（NOT NULL）作为主键，InnoDB使用它作为聚集索引。</li><li>如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</li></ul></blockquote><h4 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h4><p>MySQL 5.1 及之前版本的默认引擎。设计简单，只支持表锁，不支持事务和行级锁。</p><p>MyISAM创建的是堆表。每张MyISAM表被存放在三个文件 。<code>.frm</code>文件件存放表结构。 数据文件是<code>.MYD</code> (MYData) ， 索引文件是 <code>.MYI</code>(MYIndex) 。</p><h4 id="MEMORY存储引擎"><a href="#MEMORY存储引擎" class="headerlink" title="MEMORY存储引擎"></a>MEMORY存储引擎</h4><p>MEMORY存储引擎使用存储在内存中的内容来创建表，所有数据也放在内存中。</p><p>每个基于 MEMORY 存储引擎的表实际对应一个磁盘文件。</p><p>该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。</p><p>而其数据文件，都是存储在内存中。这样有利于对数据的快速的处理，提高整个表的处理效率。</p><h4 id="第三方存储引擎"><a href="#第三方存储引擎" class="headerlink" title="第三方存储引擎"></a>第三方存储引擎</h4><ul><li>OLTP类引擎</li><li>面向列的存储引擎 ：Info bright</li><li>社区存储引擎</li></ul><p>尽量避免使用混合引擎存储。若需要则考虑以下几点因素</p><ul><li>事务</li><li>备份</li><li>崩溃恢复</li><li>特性</li></ul><h4 id="转换表的使用引擎"><a href="#转换表的使用引擎" class="headerlink" title="转换表的使用引擎"></a>转换表的使用引擎</h4><ul><li><p>ALTER TABLE</p></li><li><p>导入与导出</p></li><li><p>创建与查询（高效且安全）</p></li></ul><h2 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h2><p>基准测试的两种策略</p><ul><li><p>集成式：针对整个系统的整体测试</p><p>测试工具</p><ul><li>ab</li><li>http_load</li><li>JMeter</li></ul></li><li><p>单组件式：针对MySQL的单独测试</p><p>测试工具</p><ul><li>MySQL slap</li><li>MySQL Benchmark Suite</li><li>Super Smark</li><li>Database Test Suite</li><li>Percona’s TPCC_MySQL Tool</li><li>sysbench</li></ul></li></ul><p>基准测试的测试指标</p><ul><li>吞吐量：单位时间内事务处理数</li><li>响应时间或延迟：测试任务所需的整体时间</li><li>并发性：正在工作中的并发操作或是同时工作的线程数或者连接数</li><li>可扩展性</li></ul><p>MySQL的内置 <code>BENCHMARK()</code>，用于测试SQL执行速度的测量。</p><p><strong>性能指的是响应时间，性能优化工作需要基于高质量、全方位及完全的响应时间测量。</strong></p><p>完整的测量会产生大量需要分析的数据，需用到剖析器，剖析报告是汇总信息，掩盖和丢弃大量细节，所以不要完全依赖剖析报告。</p><h2 id="Schema与数据类型优化"><a href="#Schema与数据类型优化" class="headerlink" title="Schema与数据类型优化"></a>Schema与数据类型优化</h2><h3 id="选择优化的数据类型"><a href="#选择优化的数据类型" class="headerlink" title="选择优化的数据类型"></a>选择优化的数据类型</h3><p>类型选择简单原则</p><ul><li>更小的：例如只需要存 0~200，则选择 tinyint unsigned</li><li>更简单的：例如存储日期使用内建类型 date、time、datetime，而不是字符串varchar</li><li>避免 null</li></ul><p><strong>整数类型</strong> whole number</p><p>可选UNSIGNED属性，表示不允许负值，大致可使正数上限提升一倍。</p><ul><li>TINYINT ：8bit</li><li>SMALLINT：16bit</li><li>MEDIUMINT：24bit</li><li>INT：32bit</li><li>BIGINT：64bit</li></ul><p><strong>实数类型</strong> real number</p><ul><li>FLOAT：浮点数类型</li><li>DOUBLE：浮点数类型</li><li>DECIMAL：定点数类型</li></ul><p><strong>字符串类型</strong></p><ul><li>VARCHAR：可变长</li><li>CHAR：定长</li><li>TEXT</li><li>ENUM代替</li></ul><p><strong>日期和时间类型</strong></p><ul><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li>TIMESTAMP</li></ul><p><strong>位数据类型</strong></p><ul><li>BIT：最大长度64bit</li><li>SET：常用于保存大量true/false值</li><li>BLOB</li></ul><p><strong>选择标识符</strong></p><ul><li>整数类型：通常是标识列的最好选择，速度快且可自增长</li><li>ENUM和SET类型：避免使用作为标识列</li><li>字符串类型：避免使用作为标识列</li></ul><h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p>在范式化的数据库中，每个事实数据会出现并且只会出现一次</p><p>在反范式化的数据库中，信息是冗余的，可能会存储在多个位置</p><p><strong>范式的优点和缺点</strong></p><p>优点：</p><ul><li>更新操作较快</li><li>重复数据较少</li><li>生成的表较小</li></ul><p>缺点：范式化设计的schema通常需要关联</p><p><strong>反范式的优点和缺点</strong></p><p>优点：</p><ul><li>反范式化设计的schema因为所有数据在一张表中，避免了关联</li></ul><ul><li>当全表扫描时，避免了随机IO</li></ul><p>缺点：更新操作慢、重复数据较多</p><p><strong>混合范式化和反范式化</strong></p><h3 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h3><p>缓存表：表示存储那些可以比较简单地从schema其他表获取数据的表</p><p>汇总表：表示保存的是使用GROUP BY语句聚合数据的表</p><p><strong>物化视图</strong></p><p>MySQL并不支持原生物化视图，可以使用Flex views实现</p><p><strong>计数器表</strong></p><p>常用于缓存一个用户的好友数量、文件下载次数等。</p><h3 id="加快ALTER-TABLE操作速度"><a href="#加快ALTER-TABLE操作速度" class="headerlink" title="加快ALTER TABLE操作速度"></a>加快ALTER TABLE操作速度</h3><ul><li>只修改 .frm 文件</li><li>快速创建MyISAM索引</li></ul><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>尽量避免会导致极其复杂查询的schema设计、有很多列的表设计</li><li>使用小而简单的合适数据类型，除非需要，否则避免使用NULL</li><li>尽量使用相同的数据类型存储相似或相关的值</li><li>注意可变长字符串、尽量使用整型定义标识列</li><li>避免使用MySQL已遗弃的特性，例如指定浮点的精度、整数的显示宽度</li><li>小心使用ENUM和SET，避免使用BIT</li></ul><h2 id="创建高性能的索引"><a href="#创建高性能的索引" class="headerlink" title="创建高性能的索引"></a>创建高性能的索引</h2><p>索引（MySQL中也称为“键”）：存储引擎用于快速找到记录的一种数据结构。</p><p>索引分类：</p><blockquote><p>1．普通（辅助/二级）索引<br>2．惟一性索引<br>3．全文索引<br>4．单列索引<br>5．多列索引<br>6．空间索引</p></blockquote><h3 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h3><p><strong>索引类型（数据结构）</strong></p><ul><li><p>B-Tree索引：通常意味着所有值按顺序存储，并且每个叶子页到跟的距离相同。从索引的根节点开始进行搜索，根节点和叶子节点之间可能有很多层节点页。树的深度和表的大小直接相关。<strong>B-Tree对索引列是有顺序</strong></p><p><strong>组织存储的，利于范围查找数据</strong></p><ul><li>MyISAM相关：使用前缀压缩技术使索引更小，通过数据的物理位置引用被索引的行</li><li>InnoDB相关 ：按照原数据格式进行存储，根据主键引用被索引的行<br>​</li></ul><p><strong>B-Tree的查询类型</strong> ：适用于全键值、键值范围或键前缀查找（只适用与根据最左前缀的查找）。</p><ul><li><p>全值匹配</p></li><li><p>匹配最左前缀</p></li><li><p>匹配列前缀</p></li><li><p>匹配范围值</p></li><li><p>精确匹配某一列并范围匹配另外一列</p></li><li><p>只访问索引的查询</p><p>B-Tree的查询限制 ：</p></li></ul><ul><li>若不是按照索引的最左列开始，则无法使用</li><li>不能跳过索引中的列</li><li>若查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找</li></ul></li><li><p><strong>哈希索引</strong>：基于<strong>哈希表</strong>实现，只有精确匹配索引所有列的查询才有效（只有Memory引擎支持并且支持非唯一哈希索引），它可以将很长的索引简化。</p><p>哈希索引的限制 ：</p><ul><li>只包含哈希值和行指针，而不存储字段值</li><li>不是按照索引值顺序存储，无法用于排序</li><li>不支持部分索引列匹配查找</li><li>只支持等值比较查询</li><li>哈希冲突很多的时候对查询速度的影响较大，维护代价也会增高</li></ul></li><li><p>空间数据索引 R-Tree</p></li><li><p>全文索引：查找的是文本中的关键词，而不是直接比较索引值</p></li><li><p>其他索引类别：TokuDB使用的分形树索引（fractal tree index）</p></li></ul><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需扫描的数据量</li><li>索引可帮助服务器避免排序和临时表</li><li>索引可将随机I/O变为顺序I/O</li></ul><blockquote><p>索引并非为最佳解决方案，只有当索引帮助存储引擎快速查找到记录时带来的好处大于带来的其他额外开销时，索引才是有效的。对于非常小的表，大部分情况下使用简单的全表扫描更高效，而对于中大型的表，则使用索引。</p></blockquote><h3 id="高性能的索引策略"><a href="#高性能的索引策略" class="headerlink" title="高性能的索引策略"></a>高性能的索引策略</h3><p><strong>独立的列</strong> ：指索引列不能是表达式的一部分，也不能是函数的参数，必须为独立的。</p><p><strong>索引选择性</strong> ：不重复的索引值（基数cardinality）和数据表的行数（<em>#T</em>）的比值，唯一索引的选择性是 1，性能最好。</p><p><strong>前缀索引</strong> ：用索引开始的部分字符进行索引，会降低索引的选择性。</p><p><strong>多列索引</strong> ：MySQL 5.0及更新版本后引入 <code>索引合并</code> 策略：</p><blockquote><ul><li>OR 条件的联合 union</li><li>AND 条件的相交 intersection</li><li>组合前两者的联合及相交</li></ul></blockquote><p><strong>聚簇索引</strong> ：一种数据存储方式</p><blockquote><p>InnoDB 实现：在同一个结构保存B-Tree 的索引和数据行。</p><p>表中有聚簇索引时，数据行存放在索引的叶子页中，一个表只能有一个聚簇索引</p></blockquote><p>优点：</p><ul><li>可以将相关数据存储到一起</li><li>数据访问快</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li></ul><p>缺点：</p><ul><li>聚簇索引提高I/O 密集型应用的性能，但对数据放在内存中的时候，优势不大</li><li>插入速度严重依赖于插入顺序，更新聚簇索引列的代价很高</li><li>插入新行或主键更新需要移动行时，可能面临 “页分裂” 问题</li></ul><p><strong>覆盖索引</strong> ：一个索引包含（覆盖）所有需要查询的字段的值</p><p><strong>前缀压缩索引</strong> ：MyISAM</p><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li>前缀<code>%</code>模糊查询</li><li>判断大小，后面不索引</li><li>只访问索引</li></ul><p>自然主键\代理主键</p><h4 id="WAL-预写日志系统"><a href="#WAL-预写日志系统" class="headerlink" title="WAL 预写日志系统"></a>WAL 预写日志系统</h4><p>MySQL为了保证ACID中的一致性和持久性，使用了WAL。它数据库中一种高效的日志算法，对于非内存数据库而言，磁盘I/O操作是数据库效率的一大瓶颈。在相同的数据量下，采用WAL日志的数据库系统在事务提交时，磁盘写操作只有传统的回滚日志的一半左右，大大提高了数据库磁盘I/O操作的效率，从而提高了数据库的性能。</p><p>Redo log就是一种WAL的应用。当数据库忽然掉电，再重新启动时，MySQL可以通过Redo log还原数据。也就是说，每次事务提交时，不用同步刷新磁盘数据文件，只需要同步刷新Redo log就足够了。相比写数据文件时的随机IO，写Redo log时的顺序IO能够提高事务提交速度。</p><p>在没有开启binlog时，Redo log的刷盘操作将会是最终影响MySQL TPS的瓶颈所在。为了缓解这一问题，MySQL使用了组提交，将多个刷盘操作合并成一个，如果说10个事务依次排队刷盘的时间成本是10，那么将这10个事务一次性一起刷盘的时间成本则近似于1。</p><h3 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h3><p><code>schema.xml</code>配置逻辑库、逻辑表、分片规则</p><p>1.schema：逻辑库，与MySQL中的Database（数据库）对应，一个逻辑库中定义了所包括的Table。</p><p>2.table：逻辑表，即物理数据库中存储的某一张表，与传统数据库不同，这里的表格需要声明其所存储的逻辑数据节点DataNode。在此可以指定表的分片规则。</p><p>3.dataNode：MyCAT的逻辑数据节点，是存放table的具体物理节点，也称之为分片节点，通过DataSource来关联到后端某个具体数据库上</p><p>4.dataSource：定义某个物理库的访问地址，用于捆绑到Datanode上</p><p>5.rule：前面讲了数据切分，一个大表被分成若干个分片表，就需要一定的规则，这样按照某种业务规则把数据分到某个分片的规则就是分片规则，数据切分选择合适的分片规则非常重要，将极大的避免后续数据处理的难</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库与缓存</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>alibaba规约</title>
    <url>/sr/post/2020-01-10-%E6%9D%82%E9%A1%B9-%E8%AF%BB%E5%90%8E%E6%84%9F-2020-01-10-alibaba%E8%A7%84%E7%BA%A6/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="规约中一些术语的网络解释"><a href="#规约中一些术语的网络解释" class="headerlink" title="规约中一些术语的网络解释"></a>规约中一些术语的网络解释</h2><ul><li><p><strong>PO(Persistant Object) 持久对象</strong><br>用于表示数据库中的一条记录映射成的 java 对象。PO 仅仅用于表示数据，没有任何数据操作。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p><p>可以理解是一个PO就是数据库中的一条记录；可以理解某个事务依赖的原始数据；好处是可以将一条记录最为一个对象处理，可以方便转化为其他对象</p></li><li><p><strong>DO( Domain Object ) 领域对象</strong><br>从现实世界中抽象出的业务实体，一般还包含 ORM 映射</p></li><li><p><strong>BO(Business Object) 业务对象</strong><br>封装对象、复杂对象，里面可能包含多个类<br>主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。</p><p>用于表示一个业务对象。BO 包括了业务逻辑，常常封装了对 DAO、RPC 等的调用，可以进行 PO 与 VO/DTO 之间的转换。BO 通常位于业务层，要区别于直接对外提供服务的服务层：BO 提供了基本业务单元的基本业务操作，在设计上属于被服务层业务流程调用的对象，一个业务流程可能需要调用多个 BO 来完成。</p><p>比如一个简历，有教育经历、工作经历、社会关系等等。<br>我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。<br>建立一个对应简历的BO对象处理简历，每个BO包含这些PO。<br>这样处理业务逻辑时，我们就可以针对BO去处理。</p></li><li><p><strong>VO(Value Object) 值对象</strong><br>前端界面展示；value object 值对象；View Object 表现层对象；主要对应界面显示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值；对于 Android 而言即是activity或view中的数据元素。</p><p>用于表示一个与前端进行交互的 java 对象。有的朋友也许有疑问，这里可不可以使用 PO 传递数据？实际上，这里的 VO 只包含前端需要展示的数据即可，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。通常遵守 Java Bean 的规范，拥有 getter/setter 方法。</p></li><li><p><strong>DTO(Data Transfer Object) 数据传输对象</strong><br>前端调用时传输；也可理解成“上层”调用时传输;<br>比如我们一张表有100个字段，那么对应的PO就有100个属性。但是我们界面上只要显示10个字段，客户端用WEB service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有这10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构.到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO.</p><p>用于表示一个数据传输对象。DTO 通常用于不同服务或服务不同分层之间的数据传输。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。通常遵守 Java Bean 的规范，拥有 getter/setter 方法</p></li><li><p><strong>DAO(Data access object) 数据访问对象</strong><br>这个大家最熟悉，和上面几个O区别最大，基本没有互相转化的可能性和必要.，主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO；</p><p>用于表示一个数据访问对象。使用 DAO 访问数据库，包括插入、更新、删除、查询等操作，与 PO 一起使用。DAO 一般在持久层，完全封装数据库操作，对外暴露的方法使得上层应用不需要关注数据库相关的任何信息。</p></li><li><p><strong>POJO(Plain ordinary java object) 普通的 Java 对象</strong></p></li></ul><p>POJO 是 DO/DTO/BO/VO 的统称，一个 POJO 持久化以后就是 PO；直接用它传递、传递过程中就是 DTO；直接用来对应表示层就是 VO。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>读后感</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis</title>
    <url>/sr/post/2020-01-10-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-01-10-MyBatis/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="MyBatis-简介"><a href="#MyBatis-简介" class="headerlink" title="MyBatis 简介"></a>MyBatis 简介</h2><h3 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h3><p><strong>MyBatis</strong> 本是 apache 的一个开源项目 iBatis, 目前项目迁移至 GitHub，并且已改名为 MyBatis,是基于 Java 开发并依赖于 Maven 构建的持久层框,支持定制化 SQL、存储过程以及高级映射,使用简单的 XML 或注解来配置和映射原生信息,将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录</p><p>每个 MyBatis 的应用程序都是要用到 SqlSessionFactory 实例的，一个 SqlSessionFactory 实例可以通过 SqlSessionFactoryBuilder 来获得，SqlSessionFactoryBuilder 可以从一个 XML 配置文件或者一个预定义的配置类的实例获得（MyBatis有一个实用类—-Resources，它有很多方法，可以方便地从类路径及其它位置加载资源）</p><p>XML 配置文件中包含了对 MyBatis 系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager ）</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>轻量化</li><li>简单易学</li><li>解除 SQL 语句与程序代码的耦合</li><li>提供映射标签，支持对象与数据库的 ORM 字段关系映射</li><li>提供 XML 标签，支持编写<strong>动态 SQL 语句</strong></li><li>提供对象关系映射标签，支持对象关系组建维护</li></ul><h2 id="MyBatis-引入"><a href="#MyBatis-引入" class="headerlink" title="MyBatis 引入"></a>MyBatis 引入</h2><p>在 <strong>Maven</strong> 的 <code>pom.xml</code> 中引入坐标</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域（Scope）和生命周期"><a href="#作用域（Scope）和生命周期" class="headerlink" title="作用域（Scope）和生命周期"></a>作用域（Scope）和生命周期</h3><p><strong>SqlSessionFactoryBuilder</strong></p><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是<strong>方法作用域</strong>（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p><p><strong>SqlSessionFactory</strong></p><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是<strong>应用作用域</strong>。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p><p><strong>SqlSession</strong></p><p>每个线程都应该有它自己的 SqlSession 实例。<strong>SqlSession 的实例不是线程安全的，因此是不能被共享的</strong>，所以它的最佳的作用域是<strong>请求或方法作用域</strong>。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。 换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。 这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdk7 后的新特性(try-with-resources)</span></span><br><span class="line"><span class="comment">// 放在 try 小括号内的流、连接等任何继承了 java.lang.AutoCloseable / java.io.Closeable 接口的类都可以确保使用完后被关闭</span></span><br><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>映射器实例</strong></p><p>映射器实例是一些由你创建的、绑定你映射的语句的接口，它的最佳的作用域是<strong>方法作用域</strong>，但一般放在 try 的大括号内，随着 session 创建的而存在（因为映射器接口的实例是从 SqlSession 中获获取的）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 使用 SqlSession 创建对应 Dao 接口的代理对象 empDao</span></span><br><span class="line">  EmpDao empDao = session.getMapper(EmpDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML-主配置文件"><a href="#XML-主配置文件" class="headerlink" title="XML 主配置文件"></a>XML 主配置文件</h2><p><strong>主配置文件</strong>一般命名为 <code>mybatis-config.xml</code>,配置文件包含了会深深影响 MyBatis 行为的设置和属性信息</p><p>主配置文件<strong>内部结构</strong>大致如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/BlogMapper.xml"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>主配置文件的<strong>配置树</strong>如下</p><ul><li><p>configuration（配置）</p><ul><li>properties（属性）一般用于引入外部配置文件 xxx.properties （例如：dataSource 的配置信息文件）</li><li>settings（设置）一般用于配置开启二级缓存或者开启全局延迟加载（开启时所有关联对象都会延迟加载）</li><li><strong>typeAliases（类型别名）</strong> 为你的 POJO 起一个简短的别名，<strong>建议使用 package 子元素为整个 pojo 包起上别名（此时 alias 就是类名，不区分大小写）</strong></li><li>typeHandlers（类型处理器）</li><li>objectFactory（对象工厂） MyBatis 每次创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成</li><li>plugins（插件） MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用</li><li><strong>environments（环境配置）</strong> 尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境<ul><li>environment（环境变量）</li><li>transactionManager（事务管理器）type=”[JDBC|MANAGED]”,<strong>建议使用 Spring 事务模块进行事务的管理</strong></li><li>dataSource（数据源）<ul><li>UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接</li><li><strong>POOLED</strong>：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间</li><li>JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用</li></ul></li></ul></li><li>databaseIdProvider（数据库厂商标识）</li><li><strong>mappers（映射器）</strong> 定义 SQL 映射语句资源路径,<strong>建议使用package 子元素包扫描方式配置映射器，此时整个 Dao 包内的映射器接口都将全部注册为映射器</strong></li></ul><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将包内的映射器接口实现全部注册为映射器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"org.mybatis.Dao"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="XML-映射配置文件"><a href="#XML-映射配置文件" class="headerlink" title="XML 映射配置文件"></a>XML 映射配置文件</h2><p>在主配置文件中 mappers 包含了一组映射器（mapper），这些映射器的 XML 映射文件包含了 SQL 代码和映射定义信息，此映射配置文件通常指的是每个 dao 接口独立的配置文件</p><h3 id="建议遵守的规范"><a href="#建议遵守的规范" class="headerlink" title="建议遵守的规范"></a>建议遵守的规范</h3><p>一、<strong>命名规范</strong>：映射配置文件的文件名和对应的 Dao 接口的文件名(不含后缀)保持一致</p><p>此点不遵守可能带来的问题：</p><div class="note danger"><p>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): xxx.xxx.xxx.xxx.Xxx</p></div><p>二、<strong>存放路径</strong>：映射配置文件的存储包路径和对应的 Dao 接口包路径保持一致</p><p>此点不遵守可能带来的问题：</p><div class="note danger"><p>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): xxx.xxx.xxx.xxx.Xxx</p></div><p>三、<strong>namespace属性</strong>：根标签 mapper 的 namespace 属性要求是对应的 Dao 接口全限定类名</p><p>此点不遵守可能带来的问题：</p><div class="note danger"><p>org.apache.ibatis.exceptions.PersistenceException:<br>Error building SqlSession.<br>The error may exist in xxx/xxx/xxx/映射配置文件名.xml<br>Cause: org.apache.ibatis.builder.BuilderException:</p></div><p>四、<strong>id 属性</strong>：Dao 接口中的每一个操作方法数据库的方法对应映射配置文件中的一个增删改查元素,此元素的 id 属性值就是对应 Dao 接口的方法名</p><p>此点不遵守可能带来的问题：</p><div class="note danger"><p>org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): xxx.xxx.xxx.xxx.Xxx</p></div><h3 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h3><p>映射配置文件<strong>内部结构</strong>大致如下</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.mybatis.example.BlogMapper"</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- namespace 中必须是接口的全限定类名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>映射配置文件的根元素是 mapper ,常用子元素如下 resultMap* | sql* | insert* | update* | delete* | select*</p><ul><li>resultMap – 结果集映射规则，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象</li><li>sql – 可被其他语句引用的可重用语句块</li><li>insert – 映射插入语句</li><li>update – 映射更新语句</li><li>delete – 映射删除语句</li><li>select – 映射查询语句</li></ul><h3 id="select-元素常用属性"><a href="#select-元素常用属性" class="headerlink" title="select 元素常用属性"></a>select 元素常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>用于指定此标签在命名空间中唯一的标识符,此元素的 id 属性值就是对应 Dao 接口的方法名</td></tr><tr><td><strong>parameterType</strong></td><td>用于指定此语句<strong>参数类型</strong>的完全限定名或别名</td></tr><tr><td><strong>resultType</strong></td><td>用于指定此语句<strong>返回值类型</strong>的完全限定名或别名。注意：如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。可以使用 resultType 或 resultMap，但不能同时使用。</td></tr><tr><td><strong>resultMap</strong></td><td>常用于指定结果集的映射（搭配外部 resultMap 自定义映射规则标签一起使用）此标签不能与 resultType 同时使用</td></tr><tr><td><strong>resultSets</strong></td><td>此属性仅对多结果集的情况适用,它将列出语句执行后返回的结果集并给每个结果集一个名称，名称是逗号分隔的</td></tr></tbody></table><h3 id="insert-update-和-delete-元素常用属性"><a href="#insert-update-和-delete-元素常用属性" class="headerlink" title="insert, update 和 delete 元素常用属性"></a>insert, update 和 delete 元素常用属性</h3><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>id</strong></td><td>用于指定此标签在命名空间中唯一的标识符,此元素的 id 属性值就是对应 Dao 接口的方法名</td></tr><tr><td><strong>parameterType</strong></td><td>用于指定此语句<strong>参数类型</strong>的完全限定名或别名</td></tr><tr><td><strong>useGeneratedKeys</strong></td><td>（仅对 insert 和 update 有用）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td><strong>keyProperty</strong></td><td>（仅对 insert 和 update 有用）唯一标记一个属性，MyBatis 会通过 getGeneratedKeys 的返回值或者通过 insert 语句的 selectKey 子元素设置它的键值，默认值：未设置（unset）。如果希望得到多个生成的列，也可以是逗号分隔的属性名称列表。</td></tr></tbody></table><h4 id="selectKey-子元素的属性"><a href="#selectKey-子元素的属性" class="headerlink" title="selectKey 子元素的属性"></a>selectKey 子元素的属性</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">selectKey</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">"id"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">"int"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">order</span>=<span class="string">"BEFORE"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">"PREPARED"</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><strong>keyProperty</strong></td><td>用于指定 selectKey 语句查询结果要<strong>被赋值的属性名</strong>,如果希望作用于多列，可以使用逗号分隔的属性名称列表</td></tr><tr><td><strong>keyColumn</strong></td><td>用于匹配 selectKey 语句将要<strong>查询的列名</strong>,如果希望作用于多列，可以使用逗号分隔的属性名称列表</td></tr><tr><td><strong>resultType</strong></td><td>指定 selectKey 语句查询<strong>结果的类型</strong>，如果希望作用于多列，则可以使用一个包含期望属性的 Object 或 Map</td></tr><tr><td><strong>order</strong></td><td>设置为<strong>BEFORE</strong> :首先生成主键，设置到 keyProperty,然后执行 insert 语句；设置为<strong>AFTER</strong> :首先执行 insert 语句,然后执行 selectKey 语句</td></tr></tbody></table><h3 id="sql-元素的属性"><a href="#sql-元素的属性" class="headerlink" title="sql 元素的属性"></a>sql 元素的属性</h3><p>sql 元素可以被用来定义可重用的 SQL 代码段，这些 SQL 代码可以被包含在其他语句中。它可以（在加载的时候）被静态地设置参数。 在不同的包含语句中可以设置不同的值到参数占位符上<br>例如：</p><p>1.定义 sql 片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"userColumns"</span>&gt;</span> $&#123;alias&#125;.id,$&#123;alias&#125;.username,$&#123;alias&#125;.password <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.使用 sql 片段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t1"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span>,</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"userColumns"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"t2"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">  from some_table t1</span><br><span class="line">    cross join some_table t2</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>原始类型或简单数据类型 (比如 基本数据类型、包装器类型和 String 类型) 因为没有与其相关联的其他属性，它会完全用参数值来替代<br>一但传入复杂对象参数时，其行为将发生改变</p><div class="note default"><p>JDBC 要求，如果一个列允许 null 值，并且会传递值 null 的参数，就必须要指定 JDBC Type，阅读 PreparedStatement.setNull()的 JavaDoc 文档来获取更多信息。</p></div><p>例如：表内 middleInitial 字段可能被设置为 null</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#&#123;firstName&#125;</span><br><span class="line">#&#123;middleInitial,jdbcType=VARCHAR&#125;</span><br><span class="line">#&#123;lastName&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p><code>#{}</code> 这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个 “?” 来标识(占位符)。<strong>应用场景：传入用户信息（表示此参数是外界或业务层传入的）</strong><br><code>${}</code> 这就告诉 MyBatis 将在 SQL 语句直接替换传入参数。<strong>应用场景：替换表名（程序员自己赋值的地方，已经明确了此处将要传入的参数）</strong></p><h3 id="结果映射"><a href="#结果映射" class="headerlink" title="结果映射"></a>结果映射</h3><h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>由于 resultType 使用的是默认映射规则，一个字段对应 POJO 的一个属性，所有应用在映射 map 或更复杂的 POJO 上的会出现映射失败造成 null值，<br>使用 resultMap 可以自定义映射到 map 或更复杂的 POJO 上的 property ，完美解决列名与属性名不匹配而造成结果映射成 null 的问题</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>当前命名空间中的一个唯一标识，用于标识一个结果映射</td></tr><tr><td>type</td><td>被映射的类全限定类名, 或是别名</td></tr><tr><td>autoMapping</td><td>如果设置这个属性，MyBatis将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）</td></tr></tbody></table><hr><table><thead><tr><th>子元素</th><th>描述</th></tr></thead><tbody><tr><td>constructor</td><td>用于在实例化类时，注入结果到构造方法（通过修改对象属性的方式，可以满足大多数的数据传输对象（Data Transfer Object, DTO）以及绝大部分领域模型的要求）</td></tr><tr><td><strong>id</strong></td><td>表示此映射字段是唯一标识属性（用于存和嵌套结果映射）</td></tr><tr><td><strong>result</strong></td><td>表示此映射字段是普通结果</td></tr><tr><td>association</td><td>一个复杂类型的关联；许多结果将包装成这种类型（嵌套结果映射 – 关联本身可以是一个 resultMap 元素，或者从别处引用一个）</td></tr><tr><td>collection</td><td>一个复杂类型的集合（嵌套结果映射 – 集合本身可以是一个 resultMap 元素，或者从别处引用一个）</td></tr><tr><td>discriminator</td><td>一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）它很像 Java 语言中的 switch 语句</td></tr></tbody></table><p><strong>定义 resultMap</strong>：</p><p>这些是结果映射最基本的内容。id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"userResultMap"</span> <span class="attr">type</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"username"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"password"</span> <span class="attr">column</span>=<span class="string">"hashed_password"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用 resultMap</strong></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUsers"</span> <span class="attr">resultMap</span>=<span class="string">"userResultMap"</span>&gt;</span></span><br><span class="line">  select user_id, user_name, hashed_password</span><br><span class="line">  from some_table</span><br><span class="line">  where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>开启驼峰转换</strong></p><p>如果数据库中的字段名与对象只是简单的不一致的话，比如名字是一样的，只是分隔方式不一样，在数据库中使用了下划线分隔，而在对象中使用了驼峰分隔，如果都是这样子的话倒不是特别麻烦，只需要在mybatis的配置文件中开启驼峰转换即可。</p><setting name="mapUnderscoreToCamelCase" value="true"><h5 id="id-和-result"><a href="#id-和-result" class="headerlink" title="id 和 result"></a>id 和 result</h5><p><strong>id 和 result 的常用属性</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>property</td><td>用于指定映射到列的属性</td></tr><tr><td>column</td><td>用于指定被映射的表中的字段名</td></tr><tr><td>javaType</td><td>一个 Java 类的完全限定名，或一个类型别名</td></tr></tbody></table><h5 id="association"><a href="#association" class="headerlink" title="association"></a>association</h5><p>关联（association）元素处理 “has-a” 类型的 POJO 关系 （常用于一对一）</p><ul><li>关联的嵌套 Select 查询</li><li>关联的嵌套结果映射</li><li>关联的多结果集（ResultSet）</li></ul><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>property</td><td>用于指定映射到列的属性</td></tr><tr><td>javaType</td><td>要进行映射的 Java 类的完全限定名，或一个类型别名</td></tr></tbody></table><p><strong>关联的嵌套 Select 查询</strong></p><p>select 属性指定需要嵌套的 select 标签的 namespace + id</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>column</td><td><strong>数据库中的列名，或者是列的别名</strong>。一般情况下，这和传递给 resultSet.getString(columnName) 方法的参数一样。 注意：在使用复合主键的时候，你可以使用 column=”{prop1=col1,prop2=col2}” 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr><tr><td>select</td><td><strong>用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句</strong>。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 column=”{prop1=col1,prop2=col2}” 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 prop1 和 prop2 作为参数对象，被设置为对应嵌套 Select 语句的参数。</td></tr><tr><td>fetchType</td><td>可选的。<strong>有效值为 lazy 和 eager</strong>。 指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled 使用属性的值（动态代理实现）</td></tr></tbody></table><h5 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h5><p>映射嵌套结果集合到一个 List/Set 中，可以使用集合（collection） 元素 （常用于一对多）</p><p>同关联元素一样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>property</td><td>用于指定映射到列的属性</td></tr><tr><td>javaType</td><td>要进行映射的 Java 类的完全限定名，或一个类型别名</td></tr><tr><td><strong>ofType</strong></td><td><strong>将被收集的集合内的存储 POJO 类型</strong> (用于将属性的类型和集合存储的类型区分开来)</td></tr></tbody></table><ul><li>集合的嵌套 Select 查询</li><li>集合的嵌套结果映射</li><li>集合的多结果集（ResultSet）</li></ul><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p>构造（constructor）元素可以将结果注入构造方法</p><h5 id="discriminator"><a href="#discriminator" class="headerlink" title="discriminator"></a>discriminator</h5><p>有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。</p><p>在一个<code>&lt;resultMap/&gt;</code>中，属性出现的先后顺序必须是：constructor–&gt;id –&gt; result–&gt; association–&gt;collection –&gt;discriminator</p><h3 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h3><hr><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="内置缓存"><a href="#内置缓存" class="headerlink" title="内置缓存"></a>内置缓存</h4><p><strong>一级缓存</strong>：默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存，所以它的级别是<strong>SqlSession</strong></p><p><strong>二级缓存</strong>：它的级别是<strong>SqlSessionFactory</strong></p><p>step1：主配置文件的 setting 元素的<code>cacheEnabled 属性设置为 true</code><br>step2：映射配置文件内添加 <code>&lt;cache/&gt;</code> 元素<br>step3：被缓存的 POJO 必须实现 <code>Serializable</code> 接口<br>step4：commit and colse</p><h4 id="使用自定义缓存"><a href="#使用自定义缓存" class="headerlink" title="使用自定义缓存"></a>使用自定义缓存</h4><hr><h4 id="cache-ref"><a href="#cache-ref" class="headerlink" title="cache-ref"></a>cache-ref</h4><hr><h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p><strong>if</strong>：用于多条件动态添加<br><strong>choose (when, otherwise)</strong>：用于多条件的动态选择<br><strong>trim (where, set)</strong>：动态添加关键字<br><strong>foreach</strong>:用于遍历参数</p><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>动态 SQL 通常要做的事情是根据条件包含 where 子句的一部分， 解决 JDBC 或者 DBUtils 类似框架 或其他工具手动拼接 SQL 语句的窘境</p><h3 id="where"><a href="#where" class="headerlink" title="where"></a>where</h3><p>where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入“WHERE”子句。而且，若语句的开头为“AND”或“OR”，where 元素也会将它们去除</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候，foreach 元素的允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量</p><div class="note danger"><p>注意 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象传递给 foreach 作为集合参数。当使用可迭代对象或者数组时，index 是当前迭代的次数，item 的值是本次迭代获取的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p></div><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectPostIn"</span> <span class="attr">resultType</span>=<span class="string">"domain.blog.Post"</span>&gt;</span></span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. item 表示遍历出来的数据，在SQL语句中通过 #&#123;属性&#125;引入</span><br><span class="line">2. index 表示遍历出来的每一个元素的下标</span><br><span class="line">3. collection 表示要遍历的对象，如果对象是List集合，则写成list</span><br><span class="line">4. open 表示在遍历出来的第一个元素之前拼接字符串</span><br><span class="line">5. separator 表示在遍历出来的元素之间添加分隔符</span><br><span class="line">6. close 表示在遍历出来的最后一个元素之后拼接字符串</span><br></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>@select<br>@insert<br>@update<br>@delete<br>@results<br>@one<br>@many</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>3种执行器：Batch-批量、Simple-默认、Reuse-复用<br>一级缓存默认开启</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js</title>
    <url>/sr/post/2020-01-08-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-01-08-Nodejs/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="Node-jS"><a href="#Node-jS" class="headerlink" title="Node.jS"></a>Node.jS</h2><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>// TODO</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/sr/post/2020-01-04-%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6-2020-01-04-Vue/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:43 GMT+0000 (Coordinated Universal Time) --><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="Vue-概述"><a href="#Vue-概述" class="headerlink" title="Vue 概述"></a>Vue 概述</h3><p>Vue.js 是一个构建数据驱动的 web 界面的渐进式框架，Vue.js 的目标是通过尽可能简单的 API 实现响应式和组件化的视图组件(使用虚拟 DOM 替换)，Vue 在不同组件间强制使用单向数据流</p><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>Model View View Model 视图与模型双向绑定</p><h3 id="Vue-的模板语法"><a href="#Vue-的模板语法" class="headerlink" title="Vue 的模板语法"></a>Vue 的模板语法</h3><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>数据绑定最常见的形式就是使用 “Mustache” 语法 (双大括号) 的文本插值：<code>&lt;div&gt; &lt;/div&gt;</code><br>只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值</p><h4 id="el"><a href="#el" class="headerlink" title="el"></a>el</h4><p>只在 new 创建的 Vue 实例中遵守，是 Vue 挂载的元素节点，值可以是 CSS 选择符，或实际 HTML 元素，或返回 HTML 元素的函数</p><h3 id="Vue-指令"><a href="#Vue-指令" class="headerlink" title="Vue 指令"></a>Vue 指令</h3><h4 id="v-on-事件绑定"><a href="#v-on-事件绑定" class="headerlink" title="v-on 事件绑定"></a>v-on 事件绑定</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"doSomething"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>格式：<code>v-on:事件名=&quot;函数名(参数)&quot;</code></p><p>简写：<code>@事件名=&quot;函数名(参数)&quot;</code></p><h4 id="v-bind-属性绑定"><a href="#v-bind-属性绑定" class="headerlink" title="v-bind  属性绑定"></a>v-bind 属性绑定</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 完整语法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">:href</span>=<span class="string">"url"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>格式：<code>v-bind:属性名=属性值</code></p><p>简写: <code>:属性名=属性值</code></p><p><strong>绑定 HTML class 属性</strong> ：<code>:class=&quot;类名&quot;</code> ，这种方法可以于普通的 class 属性并存</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"jump"</span> <span class="attr">:class</span>=<span class="string">"next"</span> &gt;</span>点我跳转<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line">...</span><br><span class="line">data:&#123;</span><br><span class="line">  next:<span class="string">"jump2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>渲染后 <code>&lt;a class=&quot;jump jump2&quot;&gt;点我跳转&lt;/a&gt;</code></p><p><strong>绑定内联样式</strong>：<code>:style=&quot;{css属性名1：属性值 ， css属性名1：属性值}&quot;</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"styleObject"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//js</span></span><br><span class="line">...</span><br><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">'red'</span>,</span><br><span class="line">    fontSize: <span class="string">'13px'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v-text-标签体数据绑定（不解析-html-标签）"><a href="#v-text-标签体数据绑定（不解析-html-标签）" class="headerlink" title="v-text 标签体数据绑定（不解析 html 标签）"></a>v-text 标签体数据绑定（不解析 html 标签）</h4><h4 id="v-html-标签体数据绑定（解析-html-标签）"><a href="#v-html-标签体数据绑定（解析-html-标签）" class="headerlink" title="v-html 标签体数据绑定（解析 html 标签）"></a>v-html 标签体数据绑定（解析 html 标签）</h4><h4 id="v-model-表单控件绑定"><a href="#v-model-表单控件绑定" class="headerlink" title="v-model 表单控件绑定"></a>v-model 表单控件绑定</h4><p>可以将表单项的数据绑定至数据模型，表单项内数据发生变化时实时更新到数据模型中</p><p>格式：<code>v-model=&quot;键.值&quot;</code></p><div class="note danger"><p>v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。</p></div><p>v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><h4 id="v-for-列表渲染"><a href="#v-for-列表渲染" class="headerlink" title="v-for 列表渲染"></a>v-for 列表渲染</h4><p>格式 v-for=”(element,index) in items”</p><h4 id="v-if-“惰性”条件渲染"><a href="#v-if-“惰性”条件渲染" class="headerlink" title="v-if “惰性”条件渲染"></a>v-if “惰性”条件渲染</h4><p>可以使用 v-else 添加一个 else 块( 紧跟 v-if)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">"seen"</span>&gt;</span>showAAA<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>showBBB<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>v-if 指令将根据表达式 seen 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素</p><h4 id="v-show-条件展示"><a href="#v-show-条件展示" class="headerlink" title="v-show 条件展示"></a>v-show 条件展示</h4><h3 id="实例属性与方法"><a href="#实例属性与方法" class="headerlink" title="$ 实例属性与方法"></a>$ 实例属性与方法</h3><p>$watch 是一个实例方法，传入双向绑定的的某个值，设置回调函数即可监视某个变量的变化（类似于 <code>v-on:change=&quot;function&quot;</code>）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Vue-生命周期和钩子函数"><a href="#Vue-生命周期和钩子函数" class="headerlink" title="Vue 生命周期和钩子函数"></a>Vue 生命周期和钩子函数</h3><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。</p><p>比如 <strong>created</strong> 钩子可以用来在一个实例被创建之后执行代码，也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <strong>mounted</strong>、<strong>updated</strong> 和 <strong>destroyed</strong><br>生命周期钩子的 this 上下文指向调用它的 Vue 实例</p><p><img data-src="https://s2.ax1x.com/2020/03/07/3XAch4.png" alt="Vue 生命周期"></p><p>8个生命周期的执行点<br>4个基本的<br>4个特殊的</p><p>beforeCreate: 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p><p><strong>created</strong>: 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p><p>beforeMount: 在挂载开始之前被调用：相关的 render 函数首次被调用。</p><p><strong>mounted</strong>: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</p><p>beforeUpdate: 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p><p><strong>updated</strong>:由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。<br>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。<em>该钩子在服务器端渲染期间不被调用。</em></p><p>beforeDestroy: 实例销毁之前调用。在这一步，实例仍然完全可用。</p><p><strong>destroyed</strong>: Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p><h3 id="使用-axios-发异步请求"><a href="#使用-axios-发异步请求" class="headerlink" title="使用 axios 发异步请求"></a>使用 axios 发异步请求</h3><ul><li>与 jquery 的 ajax 比较相似</li><li>then 括号内回调方法的简写</li></ul><h2 id="联系人案例总结"><a href="#联系人案例总结" class="headerlink" title="联系人案例总结"></a>联系人案例总结</h2><h3 id="查询所有界面"><a href="#查询所有界面" class="headerlink" title="查询所有界面"></a>查询所有界面</h3><p>使用生命周期钩子函数 created() 调用 methods 内查询所有方法（发送异步请求），可以在本界面被渲染完毕前，查询到数据，并赋值给对应数据模型供页面展示所有联系人信息</p><h3 id="添加联系人界面"><a href="#添加联系人界面" class="headerlink" title="添加联系人界面"></a>添加联系人界面</h3><p>使用 v-model 进行表单控件数据绑定，通过 <code>onsubmit=&quot;return false&quot;</code> <strong>阻止表单的同步请求</strong>，同时绑定<code>提交</code>按钮的单击事件（发送异步请求）</p><h2 id="修改联系人界面"><a href="#修改联系人界面" class="headerlink" title="修改联系人界面"></a>修改联系人界面</h2><p>使用 v-model 进行表单控件数据绑定，通过钩子函数 created() 调用根据 id 查询用户方法（发送异步请求），可以在本界面被渲染完毕前，查询到数据，并赋值给对应数据模型供页面展示需要修改的某个联系人的所有信息，然后通过 <code>onsubmit=&quot;return false&quot;</code> <strong>阻止表单的同步请求</strong>，同时绑定<code>提交修改</code>按钮的单击事件（发送异步请求）</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>使用 confirm() 进行弹框提示是否删除，确认后调用根据 id 删除用户方法（发送异步请求）</p><p><strong>注意点</strong><br>a.使用 el 指定挂载 Vue 的元素节点<br>b.JavaBean 需要有 getter 和 setter<br>b.多个联系人( List )使用 <code>[ ]</code>类型的 json 对象模型<br>c.单个联系人使用 <code>{ }</code>类型的 json 对象模型<br>d. axiso 中<code>response.data</code>获取的是响应体<br>e.携带用户表单 json 数据时需使用 post 请求<br>f.<code>methods</code> 内的方法的方法名不能使用 JavaScript 的关键字(例如：<strong>delete()应该换成 deleteFun()</strong> )</p><p><strong>点击修改用户的数据时携带对应用户id</strong>：<code>v-bind:href=&quot;&#39;update.html?id=&#39;+linkMan.id&quot;</code></p><p><strong>通过 BOM 获取地址栏携带的用户 id 进行信息回显</strong>：<code>location.href.split(&quot;=&quot;)[1];</code></p><p><strong>点击返回上一个页面功能，若是<code>&lt;input&gt;</code>则添加原生 js 事件</strong>：</p><ul><li><p><code>onclick=&quot;javascript:history.back(-1);&quot;</code> 此方法不会刷新页面</p></li><li><p><code>οnclick=&quot;javascript:location=&#39;链接页面地址&#39;&quot;</code> 此方法将会刷新页面</p></li></ul><h2 id="Vue-组件式开发"><a href="#Vue-组件式开发" class="headerlink" title="Vue 组件式开发"></a>Vue 组件式开发</h2><h2 id="VueCli"><a href="#VueCli" class="headerlink" title="VueCli"></a>VueCli</h2><p>安装前提 nodejs、yarn</p><p>管理：vue ui</p><p>启动：npm run serve</p><p>创建 vue.config.js 文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">    devserver:&#123;   <span class="comment">//自启</span></span><br><span class="line">        port:<span class="number">3333</span>,</span><br><span class="line">        open:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sass-和-less"><a href="#sass-和-less" class="headerlink" title="sass 和 less"></a>sass 和 less</h3><p>都是css的拓展语言， less 和 sass 最主要的区别是less是通过Javascript编译，而sass是通过ruby编译的，如果没有引入前端工程化，less会消耗客户端性能，sass会消耗服务端性能，但是引入前端工程化的话，gunt，gulp，webpack等，less和sass在打包阶段都会转化成css，所以不会有区别，只是sass是基于ruby，所以每次npm的时候相对慢一点点</p><p>DevTools 开发者工具</p><p>Vue CLI 脚手架</p><h2 id="VueX"><a href="#VueX" class="headerlink" title="VueX"></a>VueX</h2><h2 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element UI"></a>Element UI</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>应用框架</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/sr/post/2020-01-04-%E6%9D%82%E9%A1%B9-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7-2020-01-04-Maven/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Maven-入门"><a href="#Maven-入门" class="headerlink" title="Maven 入门"></a>Maven 入门</h2><h3 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven 简介"></a>Maven 简介</h3><p>Apache 下的一个纯 Java 开发的开源项目。基于项目对象模型（缩写：POM）概念，Maven 利用一个中央信息片断执行管理一个项目的构建、报告和文档生成等步骤。</p><p><strong>Maven 包含</strong><br>一个项目对象模型( POM : Project Object Model )<br>一组标准集合<br>一个项目生命周期<br>一个依赖管理系统<br>一个运行逻辑系统</p><p><strong>Maven 能做到的</strong>：构建工程、管理 jar 包、编译代码、自动运行单元测试、打包生成报表、部署项目、生成 web 站点</p><h3 id="Maven-安装"><a href="#Maven-安装" class="headerlink" title="Maven 安装"></a>Maven 安装</h3><p>1.Apache 官网下载对应系统的安装包 <a href="http://maven.apache.org/download.cgi" target="_blank" rel="noopener">http://maven.apache.org/download.cgi</a><br>2.解压到你需要安装的目录下<br>3.配置 Maven 环境变量（百度配置教程，前提是已配置 JDK 环境变量 <code>java -version</code> 检查，Maven 基于 Java ）<br>4.命令行输入<code>mvn -v</code>，检查是否安装成功，能看到第一行显示 Maven 的版本信息即表示配置成功</p><h3 id="Maven-仓库"><a href="#Maven-仓库" class="headerlink" title="Maven 仓库"></a>Maven 仓库</h3><p>Maven 仓库：任何一个依赖、插件或者项目构建的输出，都可以称之为构件，Maven 仓库能帮助我们管理构件（主要是 jar 包），仓库就是放置所有 jar 文件（ WAR ，ZIP ，POM 等等）的地方</p><ul><li>本地仓库（local）：Maven 的本地仓库，在安装 Maven 后并不会创建，它是在第一次执行 maven 命令的时候才被创建</li><li>中央仓库（central）： Maven 社区管理的中央仓库，此仓库无需配置，访问需要联网 <a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a></li><li>远程仓库（remote）：如果 Maven 在中央仓库中也找不到依赖的文件，它会停止构建过程并输出错误信息到控制台。为避免这种情况，Maven 提供了远程仓库的概念，它是开发人员自己定制仓库，包含了所需要的代码库或者其他工程中用到的 jar 文件。</li></ul><p><strong>连接阿里云（Aliyun）Maven 仓库</strong></p><p><label style="color:#4285f4">编辑</label><code>根目录下\conf\setting.xml</code>文件，ctrl + F 找到<code>&lt;mirrors&gt;</code>标签，添加一个<code>&lt;mirror&gt;</code>子标签</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">    <span class="comment">&lt;!-- aliyun 仓库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Maven-命令"><a href="#Maven-命令" class="headerlink" title="Maven 命令"></a>Maven 命令</h3><h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><p>mvn clean 清除项目目录中的生成结果</p><p>mvn compile 编译 src 下的源代码</p><p>mvn test 运行应用程序中的单元测试</p><p>mvn package 根据 pom.xml 指定打包方式打包(默认为 jar)</p><p>mvn install 根据 pom.xml 指定安装路径安装 jar</p><p>mvn deploy 发布项目</p><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>mvn archetype:generate 创建Maven项目<br>mvn test-compile 编译测试源代码<br>mvn site 生成项目相关信息的网站<br>mvntomcat:run 启动tomcat服务<br>mvn clean package -Dmaven.test.skip=true:清除以前的包后重新打包，跳过测试类</p><h3 id="Maven-生命周期"><a href="#Maven-生命周期" class="headerlink" title="Maven 生命周期"></a>Maven 生命周期</h3><p>清理生命周期：clean(清理)<br>默认生命周期：default(编译、测试、打包、安装、部署)<br>站点生命周期：site(建站、发布、运行)</p><h3 id="Maven-核心功能"><a href="#Maven-核心功能" class="headerlink" title="Maven 核心功能"></a>Maven 核心功能</h3><h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><p>Maven 的一个核心特性就是依赖管理（就是管理 jar 包、解决 jar 冲突的过程），当 A.jar 包内需要用到 B.jar 包中的某些类时，就产生了 jar 包依赖</p><p>可传递性依赖：<strong>A 项目</strong> 依赖于 B 库，而 B 库 又于依赖于 <code>C 库</code>，此时 C 库是 B 库的直接依赖，是 A 项目的间接依赖</p><p><strong>依赖冲突</strong>：若上面的 <strong>A 项目</strong> 还需要引入 D 库，D 库也依赖于 <code>C 库</code>，当 D 库内的 C 版本号与 B 库的 C 不一致时就产生了依赖冲突</p><h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h4><p>Maven 项目通过依赖范围来控制何时引用资源 jar 包</p><p>依赖强度：compile &gt; provided &gt; runtime &gt; test</p><table><thead><tr><th>范围</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>相关依赖在项目的类路径下有效（缺省）</td><td>spring-core</td></tr><tr><td><strong>test</strong></td><td>相关依赖在项目测试编译阶段和执行阶段下有效</td><td>junit</td></tr><tr><td><strong>provided</strong></td><td>相关依赖是由运行时的 JDK 或者网络服务器提供</td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>相关依赖在执行阶段时必须的</td><td>JDBC 驱动</td></tr><tr><td>import</td><td>相关依赖是一个 pom.xml 里定义的依赖时使用</td><td>/</td></tr><tr><td>system</td><td>相关依赖需要提供一个系统路径</td><td>本地仓库、远程仓库</td></tr></tbody></table><h4 id="依赖原则"><a href="#依赖原则" class="headerlink" title="依赖原则"></a>依赖原则</h4><p>Maven 通过<code>自调节依赖原则</code>来解决依赖冲突</p><p><strong>第一声明优先</strong>: Maven 优先引入先使用 dependency 标签配置的冲突依赖</p><p><strong>最短路径优先</strong>: Maven 优先引入依赖层级最少的冲突依赖资源</p><p><strong>直接排除法</strong>:</p><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>我们可以在引入时指定版本号，通过 <code>&lt;dependencyManagement&gt;</code> 节点在父工程里配置子工程具体的依赖版本号</p><h4 id="一键构建"><a href="#一键构建" class="headerlink" title="一键构建"></a>一键构建</h4><h3 id="Maven-集成到-IDEA"><a href="#Maven-集成到-IDEA" class="headerlink" title="Maven 集成到 IDEA"></a>Maven 集成到 IDEA</h3><p><strong>使用骨架创建 Maven 项目</strong><br>Java 骨架：<code>org.apache.maven.archetypes:maven-archetype-quickstar</code></p><p>Web 骨架：<code>org.apache.maven.archetypes:maven-archetype-webapp</code></p><p><strong>指定编译的 JDK 版本</strong><br><label style="color:#4285f4">编辑</label><code>stting.xml</code> 文件，找到 <code>&lt;profiles&gt;</code>标签，向内部添加一个子标签<code>&lt;profile&gt;</code>，指定 JDK 编译版本</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span>  </span><br><span class="line">          <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>指定运行的 Tomcat 版本</strong><br><label style="color:#4285f4">编辑</label><code>pom.xml</code> 文件，找到 <code>&lt;plugins&gt;</code>标签(没有就创建一个)，向内部添加一个子标签<code>&lt;plugin&gt;</code>，指定运行时启动 tomcat7 插件，运行指令改为 <code>mvn tomcat7:run</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">server</span>&gt;</span>tomcat7<span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Maven-高级"><a href="#Maven-高级" class="headerlink" title="Maven 高级"></a>Maven 高级</h2><p>IDEA 下执行 test 或 install 控制台出现乱码解决方案：<code>&lt;argLine&gt;-Dfile.encoding=UTF-8&lt;/argLine&gt;</code></p><p><strong>打包方式</strong>:</p><p>jar:service/dao<br>war:web<br>pom:父工程(用于聚合多个子工程)</p><p><strong>Maven 规约</strong></p><p><code>/src/main/java/</code>：Java 源码。<br><code>/src/main/resource</code>：Java 配置文件，资源文件。<br><code>/src/test/java/</code>：Java 测试代码。<br><code>/src/test/resource</code>：Java 测试配置文件，资源文件。<br><code>/target</code>：文件编译过程中生成的 .class 文件、jar、war 等等。<br><code>pom.xml</code>：配置文件<br>Maven 要负责项目的自动化构建，以编译为例，Maven 要想自动进行编译，那么它必须知道 Java 的源文件保存在哪里，这样约定之后，不用我们手动指定位置，Maven 能知道位置，从而帮我们完成自动编译。</p><p>遵循<strong>约定&gt;&gt;&gt;配置&gt;&gt;&gt;编码</strong>。即能进行配置的不要去编码指定，能事先约定规则的不要去进行配置。这样既减轻了劳动力，也能防止出错。</p><h3 id="安装jar包到本地"><a href="#安装jar包到本地" class="headerlink" title="安装jar包到本地"></a>安装jar包到本地</h3><p>环境：Windows10+Maven3.6</p><p>1、拷贝需要安装的jar包到任意目录下，建议某个盘的根目录，我这里放至<code>D:/</code>下<br>2、<code>win+r</code>键输入cmd，打开dos窗口，输入以下命令，回车即可。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn install:install-file -DgroupId=填groupId -DartifactId=填artifactId -Dversion=填版本号 -Dpackaging=打包方式 -Dfile=jar包所在磁盘位置</span><br></pre></td></tr></table></figure><p>3、出现绿色提示:BUILD SUCCESS，即安装成功。去你的mvn仓库就可以看到。</p><p>注意: jar包所在路径不要有中文!所以直接放在根目录绝对没问题</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>DB03-Redis</title>
    <url>/sr/post/2020-01-03-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98-2020-01-03-DB03-Redis/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><h3 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h3><p>Redis 是一个使用 C 语言编写 、 遵守 BSD 协议、支持网络、可基于内存亦可持久化的日志型、Key-Value 非关系型数据库</p><div class="note info"><p>什么是 BSD 协议?<br>BSD 开源协议是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布</p></div><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>在 web2.0 大环境下，为了避免对关系型数据库大量 IO 操作，引入 NoSQL 可以更好的应对高并发读写和海量数据缓存。<br>NoSQL = Not Only SQL（非关系型数据库），去除了关系数据库的关系型特性的数据库，NoSQL 不保证关系数据的 ACID 特性，大部分不提供事务的管理，与关系型数据库形成互补关系，通常 NoSQL 数据库都具有以下几点特征：<strong>易扩展、大数据量，高性能、数据模型灵活、高可用</strong></p><table><thead><tr><th>NoSQL 分类</th><th>K/V存储数据库</th><th>列存储数据库</th><th>文档型数据库</th><th>图形(Graph)数据库</th></tr></thead><tbody><tr><td><strong>典型产品</strong></td><td><strong>Redis</strong></td><td>HBase</td><td>MongoDb</td><td>Neo4J</td></tr><tr><td><strong>应用场景</strong></td><td>内容缓存，日志系统</td><td>分布式文件系统</td><td>Web应用</td><td>社交网络</td></tr></tbody></table><h3 id="Redis-较其他-K-V-数据库的优势"><a href="#Redis-较其他-K-V-数据库的优势" class="headerlink" title="Redis 较其他 K/V 数据库的优势"></a>Redis 较其他 K/V 数据库的优势</h3><p>Redis 有着更为复杂的数据结构并且提供对他们的原子性操作<br>Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象<br>Redis 运行在内存中还可以持久化到磁盘</p><h3 id="Redis-初使用"><a href="#Redis-初使用" class="headerlink" title="Redis 初使用"></a>Redis 初使用</h3><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><ol><li>官网 <a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a> 或者中文网 <a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a></li><li>下载之后解压，在解压目录找到 <code>redis-server.exe</code> 这是 Redis 的服务器端，双击运行可以看到 Redis 的命令行界面，上面有进程 ID 和端口号，不要关闭此窗口</li><li>找到 <code>redis-cli.exe</code> 这是 Redis 的客户端，双击即可看到已连接到 Redis 服务器的端口 127.0.0.1:6379&gt;，说明已成功安装 Redis</li></ol><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>Windows 下的 Redis 配置文件：<code>redis.windows.conf</code></p><h3 id="Redis-数据的形式"><a href="#Redis-数据的形式" class="headerlink" title="Redis 数据的形式"></a>Redis 数据的形式</h3><p>Redis 存储的是 key+value 格式的数据，其中 key 固定为字符串 ，value 则有 5 种数据类型</p><h4 id="value-的数据类型"><a href="#value-的数据类型" class="headerlink" title="value 的数据类型"></a>value 的数据类型</h4><p><strong>字符串： string</strong>（二进制安全）<br>二进制安全的意思是 Redis 的 string 可以包含任何数据，比如 jpg 图片或者序列化的对象，string 类型是 Redis 最基本的数据类型， 最大能存储 512MB</p><p><strong>哈希： hash</strong>（类似<code>map</code>类型） 场景：查、增、改用户的属性</p><p><strong>有序列表： list</strong>（类似<code>LinkedList</code>格式，双向链表，元素可重复）场景：消息队列</p><p><strong>无序集合： set</strong>(类似<code>HashSet</code>格式，哈希表实现，元素不允许重复，无序) 场景：两个用户之间的共同好友数</p><p><strong>有序集合： zset(sorted set)</strong>(不允许重复，通过增加权重 score， 使存储元素从小到大排序) 场景：排行榜</p><h3 id="Redis-常见命令操作"><a href="#Redis-常见命令操作" class="headerlink" title="Redis 常见命令操作"></a>Redis 常见命令操作</h3><h4 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h4><p><code>keys *</code> : 查询所有键<br><code>type key</code> ： 获取键对应值的数据类型<br><code>del key</code>：删除指定键</p><h4 id="操作字符串类型数据"><a href="#操作字符串类型数据" class="headerlink" title="操作字符串类型数据"></a>操作字符串类型数据</h4><p><strong>存储</strong>：<code>set key value</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set username zhangsan</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><p><strong>获取</strong>：<code>get key</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; get username</span><br><span class="line">"zhangsan"</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<code>del key</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del username</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="操作哈希类型数据"><a href="#操作哈希类型数据" class="headerlink" title="操作哈希类型数据"></a>操作哈希类型数据</h4><p><strong>存储</strong>：<br><code>hset key field value</code> 存储一个 field 和 value 到指定 key<br><code>hmset key field1 value1 field2 value2 ... field(n) value(n)</code> 存储多个 field 和 value 到指定 key</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hset myhash password 1234</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>获取</strong>：<br><code>hget key field</code> 获取指定的field对应的值<br><code>hmget key field</code> 获取指定的 field 多个对应的值</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">"lisi"</span><br></pre></td></tr></table></figure><p><code>hgetall key</code> 获取指定 key 所有的 field 和 value</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall myhash</span><br><span class="line">1) "username"</span><br><span class="line">2) "lisi"</span><br><span class="line">3) "password"</span><br><span class="line">4) "123"</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<code>hdel key field</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash password</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="操作有序列表类型数据"><a href="#操作有序列表类型数据" class="headerlink" title="操作有序列表类型数据"></a>操作有序列表类型数据</h4><p><strong>添加</strong>：<br><code>lpush key value</code> 将元素加入列表的左边</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush myList a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; lpush myList b</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><p><code>rpush key value</code> 将元素加入列表的右边</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush myList c</span><br><span class="line">(integer) 3</span><br><span class="line">```					</span><br><span class="line">**获取**：</span><br><span class="line">`lrange key <span class="keyword">start</span> <span class="keyword">end</span><span class="string">` 范围获取</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">sql</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; lrange myList <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">"b"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"a"</span></span><br><span class="line"><span class="number">3</span>) <span class="string">"c"</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<br><code>lpop key</code> 删除列表最左边的元素，并将元素返回<br><code>rpop key</code> 删除列表最右边的元素，并将元素返回</p><h4 id="操作无序集合类型数据"><a href="#操作无序集合类型数据" class="headerlink" title="操作无序集合类型数据"></a>操作无序集合类型数据</h4><p><strong>存储</strong>：<code>sadd key value</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p><strong>获取</strong>:<br><code>smembers key</code> 获取set集合中所有元素</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) "a"</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<br><code>srem key value</code> 删除set集合中的某个元素</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h4 id="操作有序集合类型数据"><a href="#操作有序集合类型数据" class="headerlink" title="操作有序集合类型数据"></a>操作有序集合类型数据</h4><p><strong>存储</strong>：<br><code>zadd key score value</code> 存储元素时指定权重 ， score:分数</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd mysort 60 zhangsan</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 50 lisi</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd mysort 80 wangwu</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><p><strong>获取</strong>：<code>zrange key start end [withscores]</code> 可通过携带 withscores 查看对应元素权重</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1</span><br><span class="line">1) "lisi"</span><br><span class="line">2) "zhangsan"</span><br><span class="line">3) "wangwu"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; zrange mysort 0 -1 withscores</span><br><span class="line">1) "zhangsan"</span><br><span class="line">2) "60"</span><br><span class="line">3) "wangwu"</span><br><span class="line">4) "80"</span><br><span class="line">5) "lisi"</span><br><span class="line">6) "500"</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：<code>zrem key value</code></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem mysort lisi</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h3><p>Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB (快照)持久化：保存某个时间点的全量数据快照<br>默认持久化方式，不需要进行配置，默认就使用这种机制，原理就是：在一定的间隔时间中，检测 key 的变化情况，然后持久化到一个<code>dump.rdb</code>文件中，对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)</p><p><label style="color:#4285f4">编辑</label><code>redis.windwos.conf</code> 文件：找到下面的配置，它们设置了在某个时间段内多少个 key 发生改变就会触发 RDB 持久化，我们按需求改变某种触发机制</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#   after 900 sec (15 min) if at least 1 key changed  #15分钟内有1个键发生改变则触发 RDB</span><br><span class="line">save 900 1</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed #5分钟内有10个键发生改变则触发 RDB</span><br><span class="line">save 300 10</span><br><span class="line">#  after 60 sec if at least 10000 keys changed        #1分钟内有10000个键发生改变则触发 RDB</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p><label style="color:red">重启</label>Redis 服务器：根目录下进入 cmd 输入以下命令(指定 Redis 服务器加载时的配置文件)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D:\work\Redis&gt;redis-server.exe redis.windows.conf</span><br></pre></td></tr></table></figure><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF(Append-Only-File) 持久化：可以记录每条命令的操作，以日志形式追加保存到一个 AOF 文件中（增量形式）</p><p><label style="color:#4285f4">编辑</label><code>redis.windwos.conf</code> 文件：找到 appendonly no（关闭 AOF ） 修改为 appendonly yes （开启 AOF ），同步改为每一秒执行一次持久化。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">appendonly no &#x3D;&gt; appendonly yes</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># appendfsync always         # 每一次操作都进行持久化</span><br><span class="line">appendfsync everysec         # 每隔一秒进行一次持久化</span><br><span class="line"># appendfsync no &#x3D;&gt; appendfsync yes</span><br></pre></td></tr></table></figure><h3 id="Java-连接-Redis"><a href="#Java-连接-Redis" class="headerlink" title="Java 连接 Redis"></a>Java 连接 Redis</h3><ol><li>导入 jar 包</li><li>创建 Jedis 对象</li><li>操作 Redis 数据库</li><li>断开连接</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>存储：set(K,V)</p><p>获取：V get(K)</p><p>设置键的过期时间：setex(K,outtime,V)</p><h5 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h5><p>存储：hset(K,Field,V)</p><p>获取：V hget(K,Field)</p><p>获取所有：Map&lt; String,String &gt; hgetAll(K)</p><h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>从列表左边依次开始存储（ Vn 为最左边的元素）：lpush(K,V1,V2…Vn)</p><p>从列表左边依次开始存储（ Vn 为最右边的元素）：rpush(K,V1,V2…Vn)</p><p>范围获取（ 0 到 -1 代表获取所有）：List&lt; String &gt; lrange(K,0,-1)</p><p>弹出最左边的元素：V lpop(K)</p><p>弹出最右边的元素：V rpop(K)</p><h5 id="无序集合"><a href="#无序集合" class="headerlink" title="无序集合"></a>无序集合</h5><p>存储：sadd(K,V1,V2…Vn)</p><p>获取所有：Set&lt; String &gt; smembers(K)</p><h5 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h5><p>存储：zadd(K,SCORE,V)</p><p>范围获取（ 0 到 -1 代表获取所有）：Set&lt; String &gt; zrange(K,0,-1)</p><h4 id="JedisPool-连接池"><a href="#JedisPool-连接池" class="headerlink" title="JedisPool 连接池"></a>JedisPool 连接池</h4><p>1.导入 commons-poolx-x.x.jar 包<br>2.创建 JedisPool 连接池对象<br>3.调用方法 getResource() 获取 Jedis 连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//0.创建一个配置对象</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">config.setMaxTotal(<span class="number">60</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//1.创建 Jedis 连接池对象</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="comment">//2. 获取连接</span></span><br><span class="line">Jedis jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">//3. 操作 Redis</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>,<span class="string">"honey"</span>);</span><br><span class="line"><span class="comment">//4. 归还到连接池中</span></span><br><span class="line">jedis.close();</span><br></pre></td></tr></table></figure><p>可以发现每次使用连接池时都要新建连接池，为了避免频繁创建造成不必要的开销，便于管理，可以使用连接池工具类优化</p><p>1)<label style="color:green">创建</label>配置文件 <code>jedis.properties</code></p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机IP</span></span><br><span class="line"><span class="attr">host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># 最大连接数</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="comment"># 最大闲置连接数</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure><p>2)<label style="color:green">创建</label>工具类 <code>JedisPoolUtil</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">  <span class="comment">// 类加载时读取配置文件</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      InputStream is = JedisPoolUtil.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">      Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          prop.load(is);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">int</span> maxIdle = Integer.parseInt(prop.getProperty(<span class="string">"maxIdle"</span>));</span><br><span class="line">      <span class="keyword">int</span> maxTotal = Integer.parseInt(prop.getProperty(<span class="string">"maxTotal"</span>));</span><br><span class="line">      <span class="keyword">int</span> port = Integer.parseInt(prop.getProperty(<span class="string">"port"</span>));</span><br><span class="line">      String host = prop.getProperty(<span class="string">"host"</span>);</span><br><span class="line"></span><br><span class="line">      config.setMaxIdle(maxIdle);</span><br><span class="line">      config.setMaxTotal(maxTotal);</span><br><span class="line">      jedisPool = <span class="keyword">new</span> JedisPool(config, host, port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 Jedis 连接</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3)<label style="color:#1cb7ff">使用</label>连接池工具类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Jedis jedis = JedisPoolUtil.getJedis();</span><br><span class="line">    jedis.set(<span class="string">"Hello"</span>,<span class="string">"World"</span>);</span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><h4 id="Redis-的数据结构及使用场景"><a href="#Redis-的数据结构及使用场景" class="headerlink" title="Redis 的数据结构及使用场景"></a>Redis 的数据结构及使用场景</h4><ul><li><p>String字符串:字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，而且 其他几种数据结构都是在字符串类型基础上构建的，我们常使用的 set key value 命令就是字符串。常用在缓存、计数、共享Session、限速等。</p></li><li><p>Hash哈希:在Redis中，哈希类型是指键值本身又是一个键值对结构，哈希可以用来存放用户信息，比如实现购物车。</p></li><li><p>List列表（双向链表）:列表（list）类型是用来存储多个有序的字符串。可以做简单的消息队列的功能。</p></li><li><p>Set集合：集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。</p></li><li><p>Sorted Set有序集合（跳表实现）：Sorted Set 多了一个权重参数 Score，集合中的元素能够按 Score 进行排列。可以做排行榜应用，取 TOP N 操作。</p></li></ul><h4 id="Redis-缓存雪崩问题"><a href="#Redis-缓存雪崩问题" class="headerlink" title="Redis 缓存雪崩问题"></a>Redis 缓存雪崩问题</h4><p>什么情况下会出现?</p><p>缓存雪崩是因为缓存失效导致数据未加载到内存中，或者缓存时间大面积地过期失效，从而导致所有请求都会去查数据库，导致数据库、CPU和内存负载过高，甚至宕机。</p><p>解决方法：</p><ul><li><strong>Redis集群</strong>: 使用<code>Redis</code>高可用架构，使用来保证其缓存服务不会挂掉</li><li><strong>设置不同的过期时间</strong>: 在即将发生大并发访问前手动触发加载缓存不同的key，让缓存失效的时间点尽量均匀。热点缓存永不过期。</li><li><strong>限流降级</strong>: 在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个<code>key</code>只允许一个线程查询数据和写缓存，其他线程等待。</li></ul><h4 id="Redis-缓存穿透问题"><a href="#Redis-缓存穿透问题" class="headerlink" title="Redis 缓存穿透问题"></a>Redis 缓存穿透问题</h4><p>什么情况下会出现?</p><p>当查询一个数据库<strong>必不存在的数据</strong>时，此时首先到<code>redis</code>查，发现没有（缓存未命中），然后直接通过持久层向数据库查询，发现也没有，当用户很多的时候，这些缓存都没有命中，于是压力都到了数据库，这时候就出现了缓存穿透。</p><p>解决方法：</p><ul><li><strong>接口校验</strong>：如用户鉴权校验，id做基础校验，id&lt;=0 的直接拦截</li><li><strong>缓存 null 值</strong>：从缓存取不到的数据，如果在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置为 t，如t &lt;= 30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</li><li><strong>布隆过滤器拦截</strong>:布隆过滤器是一种数据结构，我们将所有可能的查询<code>key</code>以哈希形式映射到布隆过滤器中，查询时先判断<code>key</code>是否存在布隆过滤器中，存在才继续向下执行，如果不存在，则直接返回。布隆过滤器将值进行多次哈希存储，布隆过滤器说某个元素在，可能会被误判。布隆过滤器说某个元素不在，那么一定不在。</li></ul><h4 id="Redis-缓存击穿问题"><a href="#Redis-缓存击穿问题" class="headerlink" title="Redis 缓存击穿问题"></a>Redis 缓存击穿问题</h4><p>这里需要注意和缓存穿透的主要区别缓存击穿指的是<strong>查询缓存中没有而数据库里面有的目标数据</strong>，而缓存穿透是<strong>查询二者都没有的目标数据</strong></p><p>什么情况下会出现?</p><p>当一个热点<code>key</code>，在不停的扛着高并发，集中对这一个<code>key</code>进行访问，当这个<code>key</code>在失效的瞬间，都去直接请求数据库，就像在一个缓存屏障上凿开了一个洞，引起数据库压力瞬间增大。</p><p>解决方法：</p><ul><li><strong>热点数据永远不过期</strong></li><li><strong>互斥锁</strong></li></ul><h4 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h4><p>什么是”双活”?<br>主备数据中心之间一般有热备、冷备、双活三种备份方式。</p><p>热备<br>热备的情况下，只有主数据中心承担用户的业务，此时备数据中心对主数据中心进行实时的备份，当主数据中心挂掉以后，备数据中心可以自动接管主数据中心的业务，用户的业务不会中断，所以也感觉不到数据中心的切换。</p><p>冷备<br>冷备的情况下，也是只有主数据中心承担业务，但是备用数据中心不会对主数据中心进行实时备份，这时可能是周期性的进行备份或者干脆不进行备份，如果主数据中心挂掉了，用户的业务就会中断。</p><p>双活<br>双活是觉得备用数据中心只做备份太浪费了，所以让主备两个数据中心都同时承担用户的业务，此时，主备两个数据中心互为备份，并且进行实时备份。一般来说，主数据中心的负载可能会多一些，比如分担60<del>70%的业务，备数据中心只分担40%</del>30%的业务。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库与缓存</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Web04-Ajax</title>
    <url>/sr/post/2020-01-03-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-Web-2020-01-03-Web04-Ajax/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Ajax-简介"><a href="#Ajax-简介" class="headerlink" title="Ajax 简介"></a>Ajax 简介</h2><h3 id="Ajax-是什么"><a href="#Ajax-是什么" class="headerlink" title="Ajax 是什么"></a>Ajax 是什么</h3><p>Ajax = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br>Ajax 不是新的编程语言，而是一种使用现有标准的新方法，它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术</p><p>联合使用：<br>XMLHttpRequest 核心对象 (异步的与服务器交换数据)<br>JavaScript/DOM (信息显示/交互)<br>CSS (给数据定义样式)<br>XML/JSON (作为转换数据的格式)</p><h3 id="使用-Ajax-利弊"><a href="#使用-Ajax-利弊" class="headerlink" title="使用 Ajax 利弊"></a>使用 Ajax 利弊</h3><p>优点：能在不更新整个页面的前提下维护数据，并避免了在网络上发送那些没有改变的信息<br>缺点：可能破坏浏览器的后退与加入收藏书签功能，解决方案：H5 之前使用锚点来保持追踪，H5 之后可以直接操作浏览器历史，这两个方法都可以解决无法后退的问题</p><h3 id="原生-js-发送异步请求"><a href="#原生-js-发送异步请求" class="headerlink" title="原生 js 发送异步请求"></a>原生 js 发送异步请求</h3><hr><h3 id="JQuery-发送异步请求"><a href="#JQuery-发送异步请求" class="headerlink" title="JQuery 发送异步请求"></a>JQuery 发送异步请求</h3><h4 id="ajax"><a href="#ajax" class="headerlink" title="$.ajax()"></a>$.ajax()</h4><p><strong>方法定义</strong>：<code>jQuery.ajax(url,[settings])</code><br>ajax() 是 jQuery 底层 Ajax 实现，一般不使用，<code>$.ajax()</code> 返回其创建的 XMLHttpRequest 对象，可以不带任何参数直接使用</p><p><strong>参数介绍</strong>:<br>url: 发送请求地址<br>settings: Ajax 请求设置,所有选项都是可选的,都可以通过 <code>$.ajaxSetup()</code>函数来全局设置</p><p>一般使用简单易用的高层实现: <code>$.get()</code>, <code>$.post()</code></p><h4 id="get"><a href="#get" class="headerlink" title="$.get()"></a>$.get()</h4><p><strong>方法定义</strong>：<code>jQuery.get(String url, Map [data],Function [callback],String [type])</code></p><p><strong>参数介绍</strong>:<br>url: 发送请求地址<br>data: 待发送 Key/value 参数<br>callback: 载入成功时回调函数<br>type: 返回内容格式 ,xml, html, script, json, text, _default</p><h4 id="post"><a href="#post" class="headerlink" title="$.post()"></a>$.post()</h4><p><strong>方法定义</strong>：<code>jQuery.post(String url, Map [data],Function [callback],String [type])</code></p><p><strong>参数介绍</strong>:</p><p>url: 发送请求地址<br>data: 待发送 Key/value 参数<br>callback: 发送成功时回调函数<br>type: 返回内容格式,xml, html, script, json, text, _default</p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON = JavaScript Object Notation(JavaScript 对象表示法)<br>JSON 是一种轻量级的数据交换格式，使用 js 的语法来描述数据，它是 ECMAScript 的子集，但是仍然独立于 js 和平台</p><p><strong>与 XML 的相同点</strong><br>JSON 是纯文本<br>JSON 具有”自我描述性”<br>JSON 具有层级结构（值之间可嵌套）<br>JSON 可通过 JavaScript 进行解析<br>JSON 数据可使用 AJAX 进行传输</p><p><strong>与 XML 的不同点</strong><br>无结束标签<br>读写的速度更快<br>能够使用内建的 JavaScript eval() 方法进行解析<br>使用数组<br>不使用保留字</p><h3 id="JSON-的使用"><a href="#JSON-的使用" class="headerlink" title="JSON 的使用"></a>JSON 的使用</h3><h4 id="JSON-的形式"><a href="#JSON-的形式" class="headerlink" title="JSON 的形式"></a>JSON 的形式</h4><p><strong>对象（object）</strong> 是键值对的无序集合，<code>{K1:V1，K2:V2，K3:V3...}</code>，对应 Java 中的 pojo 对象</p><p><strong>数组（array）</strong> 是值的有序集合，<code>[V1,V2,V3...]</code>，对应 Java 中的 List&lt; pojo &gt;</p><h4 id="JSON-的值"><a href="#JSON-的值" class="headerlink" title="JSON 的值"></a>JSON 的值</h4><p>值可以是数字（整数或<br>浮点数） 、字符串（在双引号中） 、逻辑值（true 或 false） 、数组（在方括号 [] 中） 、对象（在花括号 {} 中） 、null</p><h3 id="JSON-与-Java-的转换"><a href="#JSON-与-Java-的转换" class="headerlink" title="JSON 与 Java 的转换"></a>JSON 与 Java 的转换</h3><p>常用 JSON 解析器： Jackson、fastJson …</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Web03-jQuery</title>
    <url>/sr/post/2020-01-02-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-Web-2020-01-02-Web03-jQuery/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE08-Filter和Listener</title>
    <url>/sr/post/2019-12-29-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-31-EE08-Filter%E5%92%8CListener/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Filter-Java-过滤器"><a href="#Filter-Java-过滤器" class="headerlink" title="Filter Java 过滤器"></a>Filter Java 过滤器</h2><h3 id="Filter-作用"><a href="#Filter-作用" class="headerlink" title="Filter 作用"></a>Filter 作用</h3><ul><li><p>能对客户端的请求进行过滤处理，然后再将请求转发给其他 Web 组件（servlet）</p></li><li><p>对 Web 组件的 ServletRequest 和 ServletResponse 进行检查和修改</p></li><li><p>在 Web 组件调用之前检查 Request ,并修改请求头和请求正文</p></li><li><p>在 Web 组件调用之前检查 Response ,并修改响应头和响应正文</p></li></ul><h3 id="Filter-配置"><a href="#Filter-配置" class="headerlink" title="Filter 配置"></a>Filter 配置</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml 文件配置过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>过滤器名称<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>过滤器类全名<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>过滤器名称<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 拦截路径 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>过滤器拦截规则<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多个过滤器的执行顺序:</p><ol><li>如果采用配置文件方式配置过滤器，那么就按照过滤器的配置先后顺序执行</li><li>如果采用注解方式配置过滤器，那么就按照类名的排序执行</li></ol><h2 id="Listener-Java-监听器"><a href="#Listener-Java-监听器" class="headerlink" title="Listener Java 监听器"></a>Listener Java 监听器</h2><ul><li>ServletContext 对象监听器</li><li>HttpSession 对象监听器</li><li>ServletRequest 对象监听器</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE07-EL和JSTL</title>
    <url>/sr/post/2019-12-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-29-EE07-EL%E5%92%8CJSTL/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="EL"><a href="#EL" class="headerlink" title="EL"></a>EL</h2><h3 id="EL-是什么"><a href="#EL-是什么" class="headerlink" title="EL 是什么"></a>EL 是什么</h3><p>EL = Expression Language ,是 JSP 表达式语言,用于替代 JSP 页面中 Java 代码的编写 ，书写语法：<code>${表达式}</code></p><ul><li><strong>注意</strong>：JSP 默认支持 EL 表达式，如果要忽略 EL 表达式可以进行以下设置<ul><li>设置 JSP 中 page 指令中：isELIgnored=”true” 忽略当前 JSP 页面中所有的 EL 表达式</li><li>${表达式} ：忽略当前这个el表达式</li></ul></li></ul><h3 id="EL-的使用"><a href="#EL-的使用" class="headerlink" title="EL 的使用"></a>EL 的使用</h3><h4 id="用于运算"><a href="#用于运算" class="headerlink" title="用于运算"></a>用于运算</h4><p>EL 相关运算符：</p><ol><li>算数运算符： <code>+</code> <code>-</code> <code>*</code> <code>/</code>(div) <code>%</code>(mod)</li><li>比较运算符： <code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code> <code>==</code> <code>!=</code></li><li>逻辑运算符： <code>&amp;&amp;</code>(and) <code>||</code>(or) <code>!</code>(not)</li><li><strong>空运算符</strong>： <code>empty</code><ul><li>功能：用于判断字符串、集合、数组对象是否为<strong>空字符串(“”)</strong>、 <strong>null</strong> 以及<strong>长度是否为 0</strong></li><li>${empty list}:表示判断域对象中此集合是否为 <strong>null</strong> 以及<strong>长度是否为 0</strong></li><li>${not empty str}:表示判断域对象中此字符串是否不为<strong>空字符串(“”)</strong>、 <strong>null</strong> 以及<strong>长度是否为 0</strong></li></ul></li></ol><h4 id="用于获取值"><a href="#用于获取值" class="headerlink" title="用于获取值"></a>用于获取值</h4><p>注意：EL 表达式只能从<strong>域对象</strong>中获取值</p><ul><li>从指定域中获取指定键的值：<code>${域名称.键名}</code></li></ul><table><thead><tr><th>EL 中域名称</th><th>对应 java域名称</th></tr></thead><tbody><tr><td>pageScope</td><td>pageContext ( PageContext )</td></tr><tr><td>requestScope</td><td>request ( HttpServletRequest )</td></tr><tr><td>sessionScope</td><td>session ( HttpServletResponse )</td></tr><tr><td>applicationScope</td><td>application ( ServletContext )</td></tr></tbody></table><p>举例：在 request 域中存储了 name = jay —–&gt;获取：<code>${requestScope.name}</code></p><ul><li><p>获取对象、List 、Map 的值</p><ol><li><p>对象：（本质上会去调用对象的对应属性名的 Getter 方法）</p><ul><li>${域名称.键名.属性名}</li><li>${域名称.键名[索引]}</li></ul></li><li><p>List集合：${域名称.键名[索引]}</p></li><li><p>Map集合：</p><ul><li>${域名称.键名.Map中的key名称}</li><li>${域名称.键名[索引]}</li></ul></li></ol></li><li><p>直接获取某个键的值：<code>${键名}</code> ， 表示依次从最小的域中查找是否有该键对应的值，直到找到为止。</p></li><li><p>获取某个 cookie 的值：<code>${cookie.cookie名.value}</code></p></li></ul><h3 id="EL-的隐式对象"><a href="#EL-的隐式对象" class="headerlink" title="EL 的隐式对象"></a>EL 的隐式对象</h3><p>EL 的隐式对象共 11 个</p><p>pageContext 可以获取其它 10 个隐式对象</p><p>param 和 param Values 适用于获取请求参数的隐式对象</p><p>header 和 headerValues 适用于获取 HTTP 请求消息头的隐式对象</p><p>cookie 适用于获取 Cookie 信息的隐式对象</p><p>initParam 适用于获取 Web 应用初始化信息的隐式对象</p><p>以下四个适用于获取指定域的隐式对象</p><p>pageScope<br>requestScope<br>sessionScope<br>applicationScope</p><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><h3 id="JSTL-是什么"><a href="#JSTL-是什么" class="headerlink" title="JSTL 是什么"></a>JSTL 是什么</h3><p>JSTL = JavaSeverPages Standard Tag Libary ,是 JSP 标准标签,用于简化<br>JSP 页面上的 Java 代码</p><h3 id="JSTL-的使用"><a href="#JSTL-的使用" class="headerlink" title="JSTL 的使用"></a>JSTL 的使用</h3><ul><li>导入 jstl 相关 jar 包</li><li>引入 core 标签库 <code>&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></li><li>使用标签</li></ul><h3 id="常用的-JSTL-标签"><a href="#常用的-JSTL-标签" class="headerlink" title="常用的 JSTL 标签"></a>常用的 JSTL 标签</h3><ul><li><p>if :相当于 java 代码的 if 语句</p><ol><li>属性：<ul><li>test 必须指定的属性，接受boolean表达式<ul><li>如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容</li><li>一般情况下，test属性值会结合el表达式一起使用</li></ul></li><li>var 判断结果存储进域对象的键名，默认存到 page 域</li><li>scope 指定判断结果要存放的域：page、application、request、session</li></ul></li><li>注意：<ul><li>c:if 标签没有 else 情况，想要 else 情况，则可以后面再定义一个 c:if 标签</li></ul></li></ol></li><li><p>choose:相当于 java 代码的 switch 语句</p><ol><li>使用 choose 标签声明 相当于 switch 声明</li><li>使用 EL 配合 when 标签做判断 相当于 case</li><li>使用 EL 配合 otherwise 标签做其他情况的声明 相当于 default</li></ol></li><li><p>foreach :相当于 java 代码的 for 语句</p><ol><li>begin 指定遍历开始下标，默认为 0</li><li>end 指定遍历结束下标，默认为 0</li><li>step 指定遍历步长，默认为 1</li><li>items 指定遍历目标</li><li>var 指定遍历每个元素的键名，此键只能在循环里面使用</li><li>varStatus 指定遍历每个元素状态的键名<ul><li>index</li><li>count</li><li>current</li><li>first</li><li>last</li></ul></li></ol></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE06-JSP</title>
    <url>/sr/post/2019-12-27-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-28-EE06-JSP/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><h3 id="JSP-是什么"><a href="#JSP-是什么" class="headerlink" title="JSP 是什么"></a>JSP 是什么</h3><p>JSP = Java Server Pages： java服务器端页面,JSP 本质上就是一个 Servlet，是一种基于文本的程序，其特点就是HTML和Java代码共同存在！JSP是为了简化Servlet的工作出现的替代品，Servlet输出HTML非常困难，JSP就是替代Servlet输出HTML的。</p><p>在Tomcat博客中我提到过：Tomcat访问任何的资源都是在访问Servlet！，当然了，JSP也不例外！JSP本身就是一种Servlet。为什么我说JSP本身就是一种Servlet呢？其实JSP在第一次被访问的时候会被编译为HttpJspPage类（该类是HttpServlet的一个子类），一般使用方式：在Servlet处理好的数据，转发到JSP，JSP只管对小部分的数据处理以及JSP本身写好的页面。</p><h4 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h4><p>JSTL全称为 JSP Standard Tag Library 即JSP标准标签库。JSTL作为最基本的标签库，提供了一系列的JSP标签，实现了基本的功能：集合的遍历、数据的输出、字符串的处理、数据的格式化等等！</p><p>为什么要使用JSTL？</p><p>EL表达式不够完美，需要JSTL的支持！在JSP中，我们前面已经用到了EL表达式，体会到了EL表达式的强大功能：使用EL表达式可以很方便地引用一些JavaBean以及其属性，不会抛出NullPointerException之类的错误！但是，EL表达式非常有限，它不能遍历集合，做逻辑的控制。这时，就需要JSTL的支持了！</p><p>Scriptlet的可读性，维护性，重用性都十分差！JSTL与HTML代码十分类似，遵循着XML标签语法，使用JSTL让JSP页面显得整洁，可读性非常好，重用性非常高，可以完成复杂的功能！</p><p>之前我们在使用EL表达式获取到集合的数据，遍历集合都是用scriptlet代码循环，现在我们学了forEach标签就可以舍弃scriptlet代码了。</p><h4 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h4><p>表达式语言（Expression Language，EL）,EL表达式是用${}括起来的脚本，用来更方便的读取对象！EL表达式主要用来读取数据，进行内容的显示！</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE05-Cookie和Session</title>
    <url>/sr/post/2019-12-26-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-26-EE05-Cookie%E5%92%8CSession/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>HTTP协议是无状态(Stateless)的协议。一旦数据交换完毕，客户端与服务器端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话,从而识别用户。要跟踪该会话，必须引入一种机制，而 Cookie 就是这样的一种机制。它可以弥补 HTTP协议无状态的不足。理论上，<strong>一个用户的所有请求操作都应该属于同一个会话</strong>,而另一个用户的所有请求操作则应该属于另一个会话</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie-简介"><a href="#Cookie-简介" class="headerlink" title="Cookie 简介"></a>Cookie 简介</h3><p><strong>什么是 cookie?</strong></p><p>Cookie 是具有名称、单个值和可选属性(如注释、路径和域限定符、有效期和版本号)的不超过 4KB 的小型文本数据,由服务器创建,由浏览器保存,然后再发送回服务器()</p><p><strong>cookie 的作用？</strong></p><p>由于 HTTP 协议本身是无状态（服务器无法判断用户身份）。Cookie 英语直译为小饼干的意思，到了我们 web 项目上实际上是一小段的文本信息（键值对格式）。若客户端向服务器发起请求，如果服务器需要记录该用户状态，就在服务器端（使用 response ）向客户端浏览器添加一个 cookie（这个 cookie 是存放在客户端的）。当客户端再次请求该网站时，会将请求的网址连同这个 cookie 信息一同提交给服务器，因此它可以帮助我们实现记录用户个人信息的功能。</p><h3 id="cookie的基本属性（4个）"><a href="#cookie的基本属性（4个）" class="headerlink" title="cookie的基本属性（4个）"></a>cookie的基本属性（4个）</h3><table><thead><tr><th>属性项</th><th>属性项介绍</th></tr></thead><tbody><tr><td>Name/Value</td><td>设置Cookie的名称及相对应的值，对于认证Cookie，Value值包括Web服务器所提供的访问令牌</td></tr><tr><td>Expires</td><td>设置 Cookie 的存活时间（会话性/持久性）</td></tr><tr><td>Path</td><td>定义了 Web 站点上可以访问该 Cookie 的目录</td></tr><tr><td>Domain</td><td>指定了可以访问该 Cookie 的 Web 站点或域</td></tr></tbody></table><h3 id="使用-cookie"><a href="#使用-cookie" class="headerlink" title="使用 cookie"></a>使用 cookie</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">// 向客户端添加 cookie</span></span><br><span class="line"><span class="comment">// 1.创建一个 Cookie 对象 （k/v 中不能包含 [ ] ( ) = , " / ? @ : ;）</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"key"</span>,<span class="string">"value"</span>); </span><br><span class="line"><span class="comment">// 2.设置最大生存周期(单位 s)</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>); </span><br><span class="line"><span class="comment">// 3.发送 Cookie 到 HTTP 响应头</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取客户端 cookie</span></span><br><span class="line">cookies = request.getCookies();</span><br></pre></td></tr></table></figure><h3 id="修改-删除-cookie"><a href="#修改-删除-cookie" class="headerlink" title="修改/删除 cookie"></a>修改/删除 cookie</h3><p>Cookie 自身并不提供修改、删除操作。如果要修改某个 Cookie，只需要新建一个同名的 Cookie，添加到 response 中覆盖原来的 Cookie 即可。</p><p>如果要删除某个 Cookie，只需要新建一个同名的 Cookie，并将 maxAge 设置为0，并添加到 response 中覆盖原来的 Cookie 。注意是 0 而不是负数。负数代表其他的意义。</p><div class="note primary"><p>注意：修改、删除 Cookie 时，新建的 Cookie 除 value、maxAge 之外的所有属性，例如 name、path、domain 等，都要与原 Cookie 完全一样。否则，浏览器将视为两个不同的 Cookie 不予覆盖，导致修改、删除失败。</p></div><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="Session-简介"><a href="#Session-简介" class="headerlink" title="Session 简介"></a>Session 简介</h3><p><strong>什么是 session?</strong></p><p>session 是服务器端使用的一种记录客户端状态的机制，session 保存在服务器上,使用上比 Cookie 简单一些，相应的也增加了服务器的存储压力。session 会话技术是基于 cookie 的, 默认在一次会话中，也就是说，一次会话中任何资源共用一个 session 对象 。</p><h3 id="Session-的生命周期"><a href="#Session-的生命周期" class="headerlink" title="Session 的生命周期"></a>Session 的生命周期</h3><p><strong>Session在用户第一次访问服务器的时候自动创建</strong>。需要注意只有访问 JSP、Servlet 等程序时才会创建 Session，只访问 HTML、IMAGE 等静态资源并不会创建 Session。如果尚未生成 Session，也可以使用 request.getSession(true) 强制生成 Session 。</p><p>Session 生成后，只要用户继续访问，服务器就会更新 Session 的最后访问时间，并维护该 Session 。用户每访问服务器一次，无论是否读写 Session ，服务器都认为该用户的Session “活跃（active）”了一次</p><p>由于会有越来越多的用户访问服务器，因此 Session 也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的 Session 从内存删除。这个时间就是 Session 的超时时间。如果超过了超时时间没访问过服务器，Session 就自动失效了</p><h3 id="获取-session"><a href="#获取-session" class="headerlink" title="获取 session"></a>获取 session</h3><p>使用 request.getSession() 方法，此底层会判断该客户端是否在服务器端已经设置过 session</p><ul><li>如果不存在，那么就会创建一个新的 session 对象</li><li>如果该客户端在此服务器上已经存在，则会获得已经存在的该 session 对象返回（其实质就是根据 JSESSIONID 判断客户端是否在服务器上已经存在 session）</li></ul><h3 id="使用-session"><a href="#使用-session" class="headerlink" title="使用 session"></a>使用 session</h3><p>setAttribute(String name, Object o) // 存储 K/V 数据到 session 域<br>getAttribute(String name) // 通过 K 获取到 V<br>removeAttribute(String name) // 移除指定 K<br>session.invalidate() // 销毁 session</p><h3 id="session-活化-钝化"><a href="#session-活化-钝化" class="headerlink" title="session 活化/钝化"></a>session 活化/钝化</h3><p>// TODO</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis CI</title>
    <url>/sr/post/2019-12-24-%E6%9D%82%E9%A1%B9-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7-2019-12-24-TravisCI/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>问题：一次触发构建时，查看joblog明明以0正常构建完成退出，却导致GitHubPage访问空白</p><p>想到可能是前端资源加载有问题（之前碰到过），于是打开F12，发现一个错都没有！！！然后开启本地调试，发现本地页面展示一切正常。<br>于是将问题定位到线上环境，检查<code>.travis.yml</code>配置，还是无果。最后在joblog中发现最新的稳定版node.js跟某个依赖库不兼容，导致前端页面写入失败，所以显示空白。</p><p>报的是警告大概是这个样子的</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">in The Web Developer Bootcamp course from section 29,304 module</span><br><span class="line">(node:15807) Warning: Accessing non-existent property &#39;count&#39; of module exports inside circular dependency</span><br><span class="line">(Use node --trace-warnings ... to show where the warning was created)</span><br><span class="line">(node:15807) Warning: Accessing non-existent property &#39;findOne&#39; of module exports inside circular dependency</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决办法：修改<code>.travis.yml</code>，指定node.js为较新版本，这里指定为 12.xxx 就行，然后重新构建，一切ok。</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node js:</span> <span class="string">'12.13.1'</span> <span class="comment">#将原来的最新稳定版改为12.13.1</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title>EE04-Resquest和Response</title>
    <url>/sr/post/2019-12-24-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-24-EE04-Resquest%E5%92%8CResponse/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>// TODO</p><h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>// TODO</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="前端发送请求到服务端的中文乱码问题"><a href="#前端发送请求到服务端的中文乱码问题" class="headerlink" title="前端发送请求到服务端的中文乱码问题:"></a>前端发送请求到服务端的中文乱码问题:</h3><p>对于get请求:参数追加到地址栏,会使用 utf-8 编码,服务器(tomcat7)接受到请求之后,使用 iso-8859-1 解码,所以会出现乱码<br>对于post请求,参数是放在请求体中,服务器获取请求体的时候使用 iso-8859-1 解码,也会出现乱码</p><p>通用的方法: new String(获取到的字符串参数.getBytes(“iso-8859-1”),”utf-8”);</p><p>针对于post请求来说:只需要将请求流的编码设置成 utf-8 即可 ==&gt; request.setCharacterEncoding(“utf-8”);</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE03-Servlet</title>
    <url>/sr/post/2019-12-22-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-22-EE03-Servlet/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><h3 id="Servlet-简介"><a href="#Servlet-简介" class="headerlink" title="Servlet 简介"></a>Servlet 简介</h3><p><strong>常见 Servlet 容器</strong></p><div class="note success"><p>Servlet 容器与 Servlet 的关系像枪和子弹的关系，枪是为子弹而生，而子弹又让枪具有了杀伤力。虽然它们是相互彼此依存的，但又相互独立发展，这一切都是为了适应工业化生产的结果。它们通过标准化接口来相互协作。</p></div><p>Tomcat, Jetty, resin, Oracle Application server, WebLogic Server, Glassfish, Websphere, JBoss 等等。(提供了 Servlet 功能的服务器，叫做 Servlet 容器。对 Web 程序来说，Servlet 容器的作用就相当于桌面程序里操作系统的作用，都是提供一些编程基础设施)</p><p><strong>Tomcat 容器模型</strong></p><p><img data-src="https://s2.ax1x.com/2020/02/15/1vqZgx.jpg" alt=""></p><p>容器可以执行接收的请求，并返回响应。容器之间是一种一对多的包含关系，在运行时，它们通过内部的 pipeline（管道） 串联起来。容器主要有以下几种：</p><p>Engine - 顶级容器，不能被其他容器包含，它接受处理连接器的所有请求，并将响应返回相应的连接器，子容器通常是 Host 或 Context<br>Host - 类似 Apache 虚拟主机的概念，包含主机名称和IP地址，这里默认是localhost，父容器是 Engine，子容器是 Context<br>Context - 表示一个 Web 应用程序，是 Servlet、Filter 的父容器<br>Wrapper - 表示一个 Servlet，它负责管理 Servlet 的生命周期，并提供了方便的机制使用拦截器，没有子容器</p><p><strong>什么是 Servlet?</strong></p><p>Servlet ＝ Server + Applet, Servlet 是一个运行在 Web服务器中的 Java 程序,Servlet 通常通过超文本传输协议 HTTP 接收和响应来自 Web 客户端的请求,说白了 Servlet 就是一种用来处理网络请求的一套规范，Servlet 基于 HTTP 协议，HTTP 协议基于 TCP/IP 协议</p><p><code>javax.servlet.http</code>包下存在大量的类和接口,这些类和接口描述并定义了在 http 协议下运行的 Servlet 类与符合规范的 Servlet 容器为此类实例提供的运行时环境之间的契约</p><p><strong>在 web.xml 中配置 Servlet</strong></p><pre><code class="xml">
<span class="tag">&lt;<span class="name">servlet</span>&gt;</span>
    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>cc.juejun.web.servlet.ServletDemo1<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span>
<span class="tag">&lt;/<span class="name">servlet</span>&gt;</span>

<span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span>
    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>demo1<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span>
    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/demo1<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span>
<span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span>
</code></pre><p><strong>web.xml 配置的组件在容器中的加载顺序是: <code>&lt;context-param&gt;</code>-&gt;<code>&lt;listener&gt;</code>-&gt;<code>&lt;filter&gt;</code>-&gt; <code>&lt;servlet&gt;</code>。其中，如果 web.xml 中出现了相同的元素，则按照在配置文件中出现的先后顺序来加载。</strong></p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="Servlet-执行流程"><a href="#Servlet-执行流程" class="headerlink" title="Servlet 执行流程"></a>Servlet 执行流程</h4><p>step1: Server 在第一个客户端请求到达 Server 时，加载目标 Servlet 类到内存;<br>step2: Servlet 容器(tomcat)实例化此 Servlet 并调用此 Servlet 的 init() 方法;<br>step3: Server 激活 Servlet 的 service() 方法，传递此次的请求的 request 和 response 作为参数;<br>step4: service() 方法获得关于 request 的信息，处理请求，访问其他资源，获得需要的信息;<br>step5: service() 方法使用响应对象的方法，将响应传回 Server,最终到达客户端;(service() 方法一般会分发到其它方法以处理请求，如 doGet() 或 doPost()…)</p><p>对于更多的客户端请求, Server 将重新创建新的 request 和 response 作为参数,仍然传入并激活此 Servlet 的 service() 方法,如此重复以上的循环，但无需再次调用 init() 方法。一般 Servlet 只初始化一次(只有一个对象)，当 Server 不再需要 Servlet 时（一般当 Server 正常关闭时），Server 调用 Servlet 的 destroy() 方法。</p><div class="note info"><p>web.xml 的 <code>&lt;load-on-startup&gt;</code> 标签</p><p>load-on-startup 标签用于标记 Servlet 容器是否应该在 Web 应用程序启动的时候就加载这个 Servlet，(实例化并调用其 init()方法)<br>它的值必须是一个整数，表示 Servlet 被加载的先后顺序<br>如果该标签的值<strong>为负数或者没有设置，则容器会当 Servlet 首次被请求时才加载</strong><br>如果值为<strong>正整数或者 0 时，表示容器在应用启动时就加载并初始化这个 Servlet</strong>,值越小, Servlet 的优先级越高，就越先被加载</p></div><h4 id="Servlet-生命周期方法"><a href="#Servlet-生命周期方法" class="headerlink" title="Servlet 生命周期方法"></a>Servlet 生命周期方法</h4><p><strong>被创建</strong>：Servlet 通过调用 init () 方法进行初始化,只会执行一次</p><p><strong>提供服务</strong>：Servlet 调用 service() 方法来处理客户端的请求,可执行多次(每次访问此 Servlet 时)</p><p><strong>被销毁</strong>：Servlet 通过调用 destroy() 方法终止（结束）</p><h3 id="HttpServlet"><a href="#HttpServlet" class="headerlink" title="HttpServlet"></a>HttpServlet</h3><p>HTTPServlet 使用一个 HTML 表单来发送和接收数据。要创建一个 HTTPServlet，请扩展 HttpServlet 类， 该类是用专门的方法来处理 HTML 表单的 GenericServlet 的一个子类。 HTML 表单是由</p><form>和</form>标记定义的。表单中典型地包含输入字段（如文本输入字段、复选框、单选按钮和选择列表）和用于提交数据的按钮。当提交信息时，它们还指定服务器应执行哪一个Servlet（或其它的程序）。 HttpServlet 类包含 init()、destroy()、service() 等方法。其中 init() 和 destroy() 方法是继承的。<p></p><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><p>ServletConfig 对象用来返回初始化参数和 ServletContext ,<strong>ServletConfig 在 servlet 容器初始化 Servlet 时被传入 init() 方法</strong>,使得 Servlet 能够从 web application 中获取初始化参数和环境信息。</p><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><p>ServletContext 接口提供有关 servlet 的环境信息,可以通过直接调用 getServletContext() 获取 ServletContext 对象</p><p><strong>ServletContext 的作用</strong></p><ul><li>作为公共的容器，实现在各个 Servlet 中共享数据<ul><li>setAttribute() 存储键值对</li><li>getAttribute() 通过键获取值</li></ul></li><li>获取文件的 MIMEType<ul><li>getMimeType(String file) 获取文件的 MIMEType</li></ul></li><li>获取全局的初始化参数<ul><li>getInitParameter(String name) 获取全局初始化参数</li></ul></li><li>获取 web 资源文件的真实路径，默认返回项目的真实运行路径<ul><li>getRealPath()</li></ul></li><li>将 web 资源文件转转成字节流<ul><li>getResourceAsStream(String path) 获取 web 文件夹下的资源文件</li></ul></li></ul><div class="note info"><p>注意：<br>getContextPath返回的是相对路径，工程的项目的相对路径<br>getRealPath返回的绝对路径，就是在文件系统的实际路径</p></div><h3 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h3><h4 id="登录案例遇到的异常"><a href="#登录案例遇到的异常" class="headerlink" title="登录案例遇到的异常"></a>登录案例遇到的异常</h4><ul><li><p>NoClassDefFoundError 解决办法：jar 包资源放入 web 下的 WEB-INF 文件夹下</p></li><li><p>QueryRunner requires a DataSource to be invoked in this way, or a Connection should be passed in<br>解决办法：数据源未配置，检查配置文件</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Web02-Tomcat</title>
    <url>/sr/post/2019-12-21-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-Web-2019-12-21-Web02-Tomcat/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Apache 软件基金会顶级项目之一,Tomcat 服务器是一个免费的开放源代码 Java 语言开发的 Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用,用于处理动态资源</p><h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><p>// TODO</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Web01-前端入门</title>
    <url>/sr/post/2019-12-20-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-Web-2019-12-20-Web01-%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 是一种无状态的协议，无状态是指 Web 浏览器与 Web 服务器之间不需要建立持久的连接，这意味着当一个客户端向服务器端发出请求，然后Web服务器返回响应（Response），连接就被关闭了，在服务器端不保留连接的有关信息。也就是说，HTTP请求只能由客户端发起，而服务器不能主动向客户端发送数据</p><p>常见的状态码描述如下：</p><p>200：客户端请求成功，是最常见的状态<br>302：未知原因重定向<br>302：临时重定向<br>404：请求资源不存在，是最常见的状态<br>400：客户端请求有语法错误，不能被服务器所理解<br>401：请求未经授权<br>403：服务器收到请求，但是拒绝提供服务<br>500：服务器内部错误，是最常见的状态<br>503：服务器当前不能处理客户端的请求</p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h2 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>EE02-JDBC</title>
    <url>/sr/post/2019-12-18-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-18-EE02-JDBC/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>JDBC ( Java DataBase Connectivity ) 是 Java 和关系型数据库之间的桥梁 ， 是一个规范而不是一个实现，由 sun 公司编写的类和接口组成，不同的数据库厂商只需写好对应的驱动，通过<strong>JDBC</strong>让Java程序和数据库驱动实现了松耦合，使得切换不同的数据库变得更加简单。</p><h3 id="JDBC-使用步骤"><a href="#JDBC-使用步骤" class="headerlink" title="JDBC 使用步骤"></a>JDBC 使用步骤</h3><p>注册驱动（DriverManager） ==&gt; 获取连接（Connection） ==&gt; 获取处理对象（Statement/PreparedStatement） ==&gt; 执行 SQL ==&gt; 处理结果集（Resultset） ==&gt; 反向释放资源，防止内存泄漏</p><h3 id="JDBC-常用对象"><a href="#JDBC-常用对象" class="headerlink" title="JDBC 常用对象"></a>JDBC 常用对象</h3><p><strong>DriverManager</strong></p><p><strong>Connection</strong></p><p><strong>Statement/PreparedStatement</strong></p><p><strong>Resultset</strong></p><h3 id="JDBC-事务管理"><a href="#JDBC-事务管理" class="headerlink" title="JDBC 事务管理"></a>JDBC 事务管理</h3><h4 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h4><p>数据库事务 (Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br>事务是必须满足4个条件（ACID）<br>事务的原子性（ Atomicity）：一组事务，要么全部成功；要么全部失败。<br>一致性 （Consistency）：事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。比如一个学生表中新插入了一条记录，这个学生的class_id必须是一个已经存在的正确的，A账户向B账户转账，不能出现负数，如果不做任何保障，出现了负数，这就是破坏了一致性可以认为是一致性表示数据本来是正确的，经过了事务，转换为了另外的一个状态，仍旧是正确的。<br>隔离性（Isolation）：由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。也就是说另一并发事务要么读取的是事务前的状态，要么是事务后的状态，不会是这个事务的中间状态。<br>持久性（Durability）：事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</p><h4 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h4><p>在默认情况下，MySQL 每执行一条 SQL 语句，都是一个单独的事务<br>如果需要将多条SQL语句设在在同一个事务中，那么需要开启事务和结束事务</p><p>Connection 与事务有关的主要方法：<br>setAutoCommit（boolean）：设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务；如果设置为false，那么相当于开启了事务，con.setAutoCommit(false) 表示开启事务<br>commit（）：提交结束事务<br>rollback（）：回滚结束事务<br>setSavepoint（）：设置保存点</p><div class="note primary"><p>在执行前开启事务，conn.setAutoCommit(false);<br>注意：一定是执行前</p></div><h4 id="事务保存点"><a href="#事务保存点" class="headerlink" title="事务保存点"></a>事务保存点</h4><p>大型或复杂事务控制中,有的时候可能并不需要将整个事务操作全部进行回滚，因为一个复杂的事务可能由几个一致性的阶段组成，保存点就是在一个事务中，插入几个还原点，再出现问题时，可以及时的撤回到这个地方来,当撤回到一个还原点时通过调用 <code>连接名.rollback(还原点名称)</code>，原有事务还在，仍在进行中，所以还需要再次的 COMMIT，这次的 COMMIT，保存点以下的相关操作相当于未执行，<strong>事务保存点作用说白了就是分步回滚</strong></p><h3 id="JDBC-连接池"><a href="#JDBC-连接池" class="headerlink" title="JDBC 连接池"></a>JDBC 连接池</h3><p>我们为什么要使用连接池？<br>池化技术在多线程时就已经接触到，使用 JDBC 连接池可以避免</p><ul><li>降低频繁创建和销毁数据库连接而产生的一系列消耗，从而提高对资源的利用率</li><li>连接池可以提高连接的可管理性，便于资源优化</li><li>合理规划连接数量 ， 避免 OOM</li></ul><h3 id="自定义连接池"><a href="#自定义连接池" class="headerlink" title="自定义连接池"></a>自定义连接池</h3><p><strong>v1.0 创建指定容量连接池，获取连接并归还连接</strong><br><strong>v2.0 创建指定容量连接池，销毁连接</strong><br><strong>v3.0 创建指定容量连接池，装饰者模式</strong></p><p>装饰者模式：</p><ul><li>装饰类和被装饰类实现同一接口</li><li>装饰类里面拿到被装饰类的引用</li><li>增强方法</li></ul><h2 id="第三方连接池"><a href="#第三方连接池" class="headerlink" title="第三方连接池"></a>第三方连接池</h2><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><p>有自动回收空闲连接的功能<br>首先导入相关 jar 包 ，配置文件中设置连接池的参数，文件规定命名为 <code>c3p0-config.xml</code></p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--c3p0的配置信息--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql:///db1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>数据库名<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>数据库密码<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--初始化连接数--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>15<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       ComboPooledDataSource source = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">       Connection conn = source.getConnection();</span><br><span class="line">       <span class="comment">// com.mchange.v2.c3p0.impl.NewProxyConnection@6356695f</span></span><br><span class="line">       println(conn);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h3><h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h2><p>轻量级数据库工具集合框架</p><h3 id="QueryRunner"><a href="#QueryRunner" class="headerlink" title="QueryRunner"></a>QueryRunner</h3><h3 id="结果集-Handler"><a href="#结果集-Handler" class="headerlink" title="结果集 Handler"></a>结果集 Handler</h3><ul><li><p>单个数据结果集处理：ScalarHandler</p></li><li><p>单行多列数据结果集处理：MapHandler / BeanHandler</p></li><li><p>多行多列数据结果集处理：MapListHandler / BeanListHandler</p></li></ul><h2 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h2><h3 id="DatabaseMetaData"><a href="#DatabaseMetaData" class="headerlink" title="DatabaseMetaData"></a>DatabaseMetaData</h3><p>获取数据库的环境信息<br>获取用户名、驱动、url…</p><h3 id="ParameterMetaData"><a href="#ParameterMetaData" class="headerlink" title="ParameterMetaData"></a>ParameterMetaData</h3><p>获取参数信息</p><ul><li>参数个数</li></ul><h3 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h3><p>获取结果集信息</p><ul><li>字段名</li><li>字段数据类型</li></ul><h2 id="自定义-DBUtils"><a href="#自定义-DBUtils" class="headerlink" title="自定义 DBUtils"></a>自定义 DBUtils</h2><h2 id="JDBCTemplate"><a href="#JDBCTemplate" class="headerlink" title="JDBCTemplate"></a>JDBCTemplate</h2><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>DB02-MySQL进阶</title>
    <url>/sr/post/2019-12-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98-2019-12-16-DB02-MySQL%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="MySQL-进阶"><a href="#MySQL-进阶" class="headerlink" title="MySQL 进阶"></a>MySQL 进阶</h2><h2 id="数据类型（字段）"><a href="#数据类型（字段）" class="headerlink" title="数据类型（字段）"></a>数据类型（字段）</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><h4 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h4><table><thead><tr><th>类型名</th><th>字节长度</th><th>范围( 有符号位 )</th></tr></thead><tbody><tr><td>tinyint</td><td>1 字节</td><td>-128 ~ 127</td></tr><tr><td>smallint</td><td>2 字节</td><td>-32768 ~ 32768</td></tr><tr><td>mediumint</td><td>3 字节</td><td>-8388608 ~ 8388607</td></tr><tr><td>int</td><td>4 字节</td><td></td></tr><tr><td>bigint</td><td>8 字节</td><td></td></tr><tr><td>int(M)</td><td>M bit</td><td></td></tr></tbody></table><ul><li>整形默认存在符号位 ， 可以使用 unsigned 修改成无符号</li><li>整形数据在满足要求的情况下，尽量使用字节长度小的</li></ul><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><table><thead><tr><th>类型名</th><th>字节长度</th><th>范围( 有符号位 )</th></tr></thead><tbody><tr><td>float</td><td>4 字节</td><td></td></tr><tr><td>double</td><td>8 字节</td><td></td></tr></tbody></table><ul><li>浮点型存在符号位 ， 可以使用 unsigned 修改成无符号</li><li>定义浮点型字段时，需指定总位数和小数位数（ M ，D ） ， M 表示总位数 D 表示小数位数 ， 浮点数的范围由 M 和 D 来确定，不同于整形的固定范围</li></ul><h4 id="定点型"><a href="#定点型" class="headerlink" title="定点型"></a>定点型</h4><p>定点型 decimal ( M ， D )， M 表示总位数 D 表示小数位数</p><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table><thead><tr><th>类型名</th><th>是否可变长</th><th>能表示的字符个数</th></tr></thead><tbody><tr><td>char</td><td>定长</td><td>0 ~ 255 ( 与编码无关 )</td></tr><tr><td>varchar</td><td>不定长</td><td>0 ~ 65536 ( 与编码有关 )</td></tr></tbody></table><ul><li>varchar 类型使用时需指定长度 varchar()</li></ul><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table><thead><tr><th>类型名</th><th>字节长度</th><th>含义</th></tr></thead><tbody><tr><td>datetime</td><td>8 字节</td><td>日期及时间</td></tr><tr><td>date</td><td>3 字节</td><td>日期</td></tr><tr><td>timestamp</td><td>4 字节</td><td>时间戳</td></tr><tr><td>time</td><td>3 字节</td><td>时间</td></tr><tr><td>year</td><td>1 字节</td><td>年份</td></tr></tbody></table><h3 id="枚举和集合"><a href="#枚举和集合" class="headerlink" title="枚举和集合"></a>枚举和集合</h3><ul><li>枚举 ( enum ) ：在建表时使用，用于添加时<strong>限定添加数据的可能性</strong>，枚举列表内可以预存 65536 个值，值的类型只能是字符串类型，但在底层是列表顺序以从 1 开始依次自增 1 的整形值存储<br>定义格式 ：<code>字段名 enum(枚举值1 ， 枚举2 ，...枚举值n) DEFAULT 默认值</code></li><li>集合 ( set ) ：在建表时使用，用于在添加时<strong>可以添加一批集合内的数据</strong>，集合列表内可以预存 64 个值，值的类型值的类型只能是字符串类型，但在底层是列表顺序以从 1 开始依次自增两倍的整形值存储<br>定义格式 ：<code>字段名 set(值1 ，值2 ，...值n)</code></li></ul><h4 id="set-建表案例"><a href="#set-建表案例" class="headerlink" title="set 建表案例"></a>set 建表案例</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE set_table ( id INT auto_increment PRIMARY KEY， hobby SET ( 'music'， 'movie'， 'swimming'， 'footbal' ) );</span><br><span class="line">mysql&gt; INSERT INTO set_table ( id， hobby ) VALUES ( NULL， 'music' );</span><br><span class="line">mysql&gt; INSERT INTO set_table ( id， hobby ) VALUES ( NULL， 'movie' );</span><br><span class="line">mysql&gt; INSERT INTO set_table ( id， hobby ) VALUES ( NULL， 'swimming，footbal' );</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM set_table;</span><br><span class="line">+<span class="comment">----+------------------+</span></span><br><span class="line">| id | hobby            |</span><br><span class="line">+<span class="comment">----+------------------+</span></span><br><span class="line">|  1 | music            |</span><br><span class="line">|  2 | movie            |</span><br><span class="line">|  3 | swimming，footbal |</span><br><span class="line">+<span class="comment">----+------------------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>范式( Normal form )：为了减少不必要的数据冗余，我们在设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小</p><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>第一范式：表内的字段不能再拆分，确保表中每列的原子性</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>第二范式：满足第一范式的前提下 ， 不能出现部分依赖 ， 确保表中每列都与主键相关联</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>第三范式：满足第二范式的前提下 ， 不能出现传递依赖 ， 确保表中每列都与主键直接关联</p><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><p>笛卡尔积：集合 A 、B ， 取这两个集合的元素的所有组成情况</p><h3 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h3><p>一对一<br>一对多<br>多对多（一对多+一对多）</p><h3 id="级联"><a href="#级联" class="headerlink" title="级联"></a>级联</h3><p>级联删除：</p><p>如果数据库外键关联设置为 CASEADE:</p><p>如果要删除多的一方，则可直接删除，并且与之关联的一方也删除了</p><p>如果数据库关联外键没有设置为CASEADE</p><p>在删除时需要先把引用外键的一方设置为null,然后在删除。</p><p>级联插入：</p><p>先插入一条一的记录，然后得到其主键</p><p>然后查找出刚插入进去的记录，通过多的一方的SET方法将其SET进去</p><p>然后将多的一方的对象统一插入进去</p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><h4 id="内连接查询"><a href="#内连接查询" class="headerlink" title="内连接查询"></a>内连接查询</h4><ul><li>隐式内连接查询：<code>SELECT * FROM 主表，副表 WHERE 连接条件</code></li><li>显式内连接查询：<code>SELECT * FROM 主表 [INNER] JOIN 副表 ON 连接条件</code></li></ul><p><strong>特点</strong>：查询出<strong>满足连接条件的数据</strong>，过滤掉不满足连接条件的，两表交集</p><h4 id="外连接查询"><a href="#外连接查询" class="headerlink" title="外连接查询"></a>外连接查询</h4><ul><li>左外连接查询：用法：<code>SELECT * FROM 主表 LEFT [OUTER] JOIN 副表 ON 连接条件</code><ul><li>以 JOIN <strong>左边的表</strong>作为主表，查询出主表的全部数据 ， 以及满足连接条件的副表数据</li></ul></li><li>右外连接查询：用法：<code>SELECT * FROM 副表 RIGHT [OUTER] JOIN 主表 ON 连接条件</code><ul><li>以 JOIN <strong>右边的表</strong>作为主表，查询出主表的全部数据 ， 以及满足连接条件的副表数据</li></ul></li></ul><p><strong>特点</strong>：查询出<strong>主表的所有数据以及满足条件的副表数据</strong>，过滤掉不满足连接条件的</p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>将 SELECT 语句 A ， 作为 SELECT 语句 B 的 WHERE 子句的条件体<br>例如：<code>SELECT 字段 FROM 表名 WHERE (SELECT 字段 FROM 表名);</code> 这条 sql 语句括号里面的 SELECT 子句就是子查询</p><p>子查询的结果：</p><ul><li>单行单列：可作为条件体，代表只有一条数据 ，直接在 WHERE 后面作为条件提供给外部查询 ，搭配比较运算符使用 ，如：&gt; 、&lt; 、&lt;&gt; 、=</li><li>单行单列：可以作为 where 条件</li><li>单行多列：可以映射为一个 POJO 实例</li><li>多行单列：可作为条件体，代表子查询的结果是一个数组 ，可通过 IN 子句将结果提供给外部查询</li><li>多行多列：不可作为条件体，代表子查询的结果是一张虚拟表 ，可通过 FROM 子句将此表提供给外部查询</li></ul><p><strong>特点</strong>：<strong>查询中嵌套别的查询</strong></p><p>会导致全表扫描的sql：</p><ul><li><p>判断null</p></li><li><p>or条件</p></li><li><p>前置%的like（如：like ‘%abc’）</p></li><li><p>where条件中存在表达式</p></li><li><p>WHERE 子句中使用!=或&lt;&gt;操作符2.IN 和 NOT IN 也要慎用，否则会导致全表扫描</p></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库与缓存</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>DB01-MySQL基础</title>
    <url>/sr/post/2019-12-16-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E7%BC%93%E5%AD%98-2019-12-16-DB01-MySQL%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><p>安装部分就不介绍了，太简单…</p><h2 id="环境启动"><a href="#环境启动" class="headerlink" title="环境启动"></a>环境启动</h2><p>Windows 下开启 MySQL 服务项，这里使用管理员模式进入 cmd 的模式</p><ul><li>开启 MySQL 服务 <code>net start mysql</code></li><li>关闭 MySQL 服务 <code>net stop mysql</code></li></ul><p>开启之后使用默认的 root 权限进入数据库 <code>mysql -uroot -proot</code>,接下来就进入到数据库内部，这里可以查看所有的数据库和表信息</p><h2 id="DDL-数据定义语言"><a href="#DDL-数据定义语言" class="headerlink" title="DDL 数据定义语言"></a>DDL 数据定义语言</h2><p>DDL ( Data Definition Language ) 数据定义语言 ： 用于创建、查询、修改、删除数据库或表 ， 关键字包括 ： CREATE 、 SHOW 、 ALTER 、 DROP</p><h3 id="DDL-数据库"><a href="#DDL-数据库" class="headerlink" title="DDL-数据库"></a>DDL-数据库</h3><p>数据库 DDL 操作时的可选选项：</p><table><thead><tr><th><em>可选项</em></th><th>字符集</th><th>排序规则</th></tr></thead><tbody><tr><td><strong><em>关键字</em></strong></td><td>CHARACTER SET</td><td>COLLATE</td></tr></tbody></table><h4 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h4><ul><li>创建数据库 db1 ：<code>CREATE DATABASE db1;</code></li><li>创建数据库时检查是否存在（存在则不创建,反之创建）：<code>CREATE DATABASE IF NOT EXISTS 数据库名;</code></li><li>创建数据库并指定选项的值：<code>CREATE DATABASE 数据库名 CHARACTER SET utf8 COLLATE utf8_general_ci;</code></li></ul><h4 id="查询库"><a href="#查询库" class="headerlink" title="查询库"></a>查询库</h4><ul><li>查询数据库系统内的所有数据库：<code>SHOW DATABASES;</code><br>注：系统自带的数据库 information_schema 、 mysql 、 performance_schema 、 sys</li><li>查询当前正在使用的数据库：<code>SELECT DATABASE();</code></li><li>查询当前时间（精确到秒）,用户,数据库系统版本：<code>SELECT now(),user(),version();</code></li><li>查询指定数据库的信息：<code>SHOW CREATE DATABASE 数据库名;</code></li></ul><h4 id="修改库"><a href="#修改库" class="headerlink" title="修改库"></a>修改库</h4><ul><li>修改数据库指定选项的值：<code>ALTER DATABASE 数据库名 CHARACTER SET gbk;</code></li></ul><h4 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h4><ul><li>删除指定数据库：<code>DROP DATABASE 数据库名;</code></li><li>删除指定数据库时检查是否存在（存在则删除,反之不操作）：<code>DROP DATABASE IF NOT EXISTS 数据库名;</code></li></ul><h3 id="DDL-表"><a href="#DDL-表" class="headerlink" title="DDL-表"></a>DDL-表</h3><p>表在 DDL 操作时的可选选项：</p><table><thead><tr><th><em>可选项</em></th><th>字符集</th><th>存储引擎</th><th>自增起始数</th><th>数据文件目录</th><th>索引文件</th><th>表注释</th><th>分区选项(详见数据库手册)</th></tr></thead><tbody><tr><td><strong><em>关键字</em></strong></td><td>CHAR SET</td><td>ENGINE</td><td>AUTO_INCREMENT</td><td>DATA DIRECTORY</td><td>INDEX DIRECTORY</td><td>COMMENT</td><td>PARTITION BY</td></tr></tbody></table><h4 id="表内字段的约束（属性）"><a href="#表内字段的约束（属性）" class="headerlink" title="表内字段的约束（属性）"></a>表内字段的约束（属性）</h4><p>1、<strong>非空</strong>：<code>NOT NULL</code><br>含义：此字段不可为 NULL</p><p>2、<strong>唯一</strong>：<code>UNIQUE</code><br>含义：此字段的值不可重复</p><p>3、<strong>主键</strong>：<code>PRIMARY KEY</code><br>含义：<br>a). 此字段唯一且非空<br>b). 每张表只能拥有一个此约束（主键一张表只有一个）<br>c). 删除时只能使用 <code>DROP PRIMARY KEY</code><br>d). 若字段为整形可以使用 <code>AUTO_INCREMENT</code> 修饰 ，使其每次插入时此字段默认自动加 1</p><p>4、外键：<code>FOREIGN KEY</code><br>含义：<br>a). 外键是另一张表的主键，用于多表之间数据关联<br>b). 外键与主键的数据类型必须一致<br>c). 定义格式：<code>CONSTRAINT A 表外键名 FOREIGN KEY ( A 表外键字段名) REFERENCES B 表名(B 表主键)</code></p><p>5、空：<code>NULL</code><br>含义：<br>a). 此字段允许为空，所有字段的默认约束<br>a). NULL 不是数据类型，是字段的一个属性</p><p>6、默认值：<code>DEFAULT</code><br>含义：添加数据时，此字段默认值为 DEFAULT 后跟的值，用法：<code>CREATE TABLE tab1 (id int,class varchar(20) DEFAULT &quot;1001&quot;);</code></p><p>7、注释：<code>COMMENT</code><br>含义：此字段注释为 COMMENT 后跟的字符串，用法：<code>CREATE TABLE tab2 (id int COMMENT &#39;用户ID&#39;) ;</code></p><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li>创建表： `CREATE TABLE 表名(字段1 数据类型,字段2 数据类型,…字段n 数据类型) [可选选项]<br>注：每个字段必须有数据类型，最后一个字段无逗号</li><li>复制指定表的结构：<code>CREATE TABLE 表名 LIKE 目标表名</code></li><li>复制指定表的结构和数据记录：<code>CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</code></li></ul><h4 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h4><ul><li>查询所有表：<code>SHOW TABLES;</code></li><li>查看指定表的建表语句：<code>SHOW CREATE TABLE 表名;</code></li><li>查看指定表的表结构：<code>DESC 表名;</code></li></ul><h4 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h4><ul><li>修改指定表的表名： <code>RENAME TABLE 旧表名 TO 新表名;</code></li><li>修改指定表的表名并移动到另一个数据库： <code>RENAME TABLE 旧表名 TO 另一个数据库名.新表名;</code></li><li>修改指定表的表选项：<code>ALTER TABLE 表名 表选项</code></li><li>修改指定表的表结构：<code>ALTER TABLE 表名 修改表结构的操作名</code></li></ul><table><thead><tr><th>修改表结构的操作名</th><th>使用的关键字</th></tr></thead><tbody><tr><td>增加字段</td><td>ADD[ COLUMN] 字段定义</td></tr><tr><td>创建主键</td><td>ADD PRIMARY KEY(字段名)</td></tr><tr><td>创建唯一索引</td><td>ADD UNIQUE [索引名] (字段名)</td></tr><tr><td>创建普通索引</td><td>ADD INDEX [索引名] (字段名)</td></tr><tr><td>删除字段</td><td>DROP[ COLUMN] 字段名</td></tr><tr><td>删除主键(删除主键前需删除其 AUTO_INCREMENT 属性)</td><td>DROP PRIMARY KEY</td></tr><tr><td>删除索引</td><td>DROP INDEX 索引名</td></tr><tr><td>删除外键</td><td>DROP FOREIGN KEY 外键名</td></tr></tbody></table><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><div class="note danger"><p>建议进行此操作前备份</p></div><ul><li><p>删除指定表：<code>DROP TABLE 表名;</code></p></li><li><p>清空指定表内所有数据（常用于<strong>重置自增 id</strong>：从 1 开始）：<code>TRUNCATE 表名</code></p></li></ul><h2 id="DML-数据处理语言"><a href="#DML-数据处理语言" class="headerlink" title="DML 数据处理语言"></a>DML 数据处理语言</h2><p>DML ( Data Manipulation Language ) 数据处理语言 ： 用于增加、删除、修改表中的数据 ， 关键字包括 ： INSERT 、 DELETE 、 UPDATE</p><h3 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h3><ul><li>向指定字段添加数据：<code>INSERT 表名 ( 字段1,字段2,...字段n ) VALUES ( 值1,值2,...值n )</code></li><li>向所有字段添加数据：<code>INSERT 表名 VALUES ( 值1,值2,...值n )</code><br>注：要求添加的值列表包含所有字段并且顺序一致，此时可以同时添加多条数据至表中</li></ul><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><ul><li>删除指定字段的数据：<code>DELETE FROM 表名 [ 删除条件 ]</code><br>注：若条件为 <code>where 1=1;</code> 或者不加条件，将会删除表中全部数据</li></ul><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><ul><li>修改指定字段的数据：<code>UPDATE 表名 SET 字段1=新值1,字段2=新值2,...字段n=新值n [ 修改条件 ]</code></li></ul><h2 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a>DQL 数据查询语言</h2><p>DQL ( Data Query Language ) 数据查询语言 ： 用于查询表中的数据 ， 关键字包括： SELECT … FROM … WHERE</p><p>主要子句介绍：</p><ul><li>SELECT ：此子句后跟查询字段列表</li><li>FROM ：此子句后跟查询源</li><li>WHERE ：此子句后跟查询条件</li></ul><h3 id="普通查询"><a href="#普通查询" class="headerlink" title="普通查询"></a>普通查询</h3><ul><li>查询<strong>所有字段</strong>：<code>SELECT * FROM 表名</code></li><li>查询<strong>指定字段</strong>：<code>SELECT 字段1,字段2,...字段n FROM 表名 [ 其他子句 ]</code></li><li>查询<strong>指定字段去重后</strong>：<code>SELECT DISTINCT 字段 FROM 表名</code></li><li>查询<strong>指定字段时使其参与数学运算</strong>：<code>SELECT 字段(运算符)数值 FROM 表名</code><br>若参与运算的字段数据类型为字符，则结果为 0</li><li>查询<strong>指定字段时对其进行排序</strong>：<code>SELECT 字段 FROM 表名 ORDER BY 排序目标字段 排序规则;</code><br>若不指定规则默认升序 ( 升序 ：<strong>ASC</strong> | 降序：<strong>DESC</strong> )</li><li>查询<strong>指定字段时使用聚合函数</strong>：</li><li>count(列名)，统计此字段非 NULL 值个数</li><li>max(列名)：求此字段最大值</li><li>min(列名)：求此字段最小值</li><li>sum(列名)：求此字段和</li><li>avg(列名)：求此字段平均值</li></ul><p>mysql 下 select 无 order by 默认排序规则，存储引擎</p><p>innodb 默认按照主键自增排序</p><p>myisam 默认按照物理存储（插入先后顺序）顺序排序</p><h3 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h3><p>WHERE 子句 ，位置：在 FROM 子句后给出<br>比较运算符：&gt; , &lt; , = , !=<br>逻辑运算符：AND , OR , NOT</p><ul><li>AND 查询出<strong>满足所有给定条件</strong>的数据</li><li>OR 查询出<strong>任一给定条件</strong>的数据</li><li>NOT 用来否定其后面跟的任何单个条件 ，从而排除此条件 ，常用于跟 IN 操作符搭配使用过滤</li></ul><h4 id="BETWEEN-…-AND"><a href="#BETWEEN-…-AND" class="headerlink" title="BETWEEN … AND"></a>BETWEEN … AND</h4><p>用于查询出<strong>满足指定范围内（包含边界值）</strong> 的数据 ：<code>SELECT 字段 FROM 表名 WHERE 条件字段 BETWEEN 值 1 AND 值 2 ;</code><br>通常情况下 ， 值 1 小于值 2 ，值 1 &lt;= 查询数据值 &lt;= 值 2</p><h4 id="IN-…"><a href="#IN-…" class="headerlink" title="IN(…)"></a>IN(…)</h4><p>用于查询出<strong>满足指定列表内任一条件</strong>的数据 ：<code>SELECT 字段1，字段2 FROM 表名 WHERE 条件字段 IN(列表值1，列表值2...列表值3);</code></p><p>a). 通常情况下，列表值可能是不明确的，可能是其他的 SELECT 语句<br>b). 一个 IN 只能对一个字段进行列表匹配，若需要指定多个，可搭配 AND 、OR 使用<br>c). 列表内的合法值可以是：字符串值 、 整形值 、日期时间值 、数据集（ <code>SELECT 字段 FROM 表名</code>）</p><h4 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h4><p>用于参与<strong>过滤条件未知</strong>的过滤查询，一般情况下与通配符搭配使用</p><p>通配符进行过滤时，只能用于文本字段（字符串），非文本数据类型字段不能使用通配符过滤</p><ul><li>% ：给出单个百分号字符 % ，用于匹配多个字符 ， 单独出现的话将会匹配所有（不包括 NULL ）</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1.用于查询出 NAME 字段中以"马"开头的指定字段数据</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">NAME</span>,age,address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"马%"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2.用于查询出 NAME 字段中包含"马"的指定字段数据</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">NAME</span>,age,address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"%马%"</span>;</span><br></pre></td></tr></table></figure><ul><li>_：给出单个下划线字符 _, 用于匹配单个任意字符</li></ul><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 用于查询出 NAME 字段中长度为 3 且中第 2 个字符为"马"</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">NAME</span>,age,address</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    students</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    <span class="keyword">NAME</span> <span class="keyword">LIKE</span> <span class="string">"_马_"</span>;</span><br></pre></td></tr></table></figure><h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p>在使用分组查询时：<code>SELECT 字段 FROM 表名 GROUP BY 基于此字段进行分组;</code><br>自 MySQL 5.7.5 以以后版本中，默认开启了 only_full_group_by 模式，可以通过 <code>SELECT @@GLOBAL.sql_mode;</code> 查看<br>此模式下，如果在 SELECT 语句中的字段列表中含有 A 字段，而 A 字段既没有在 GROUP_BY 子句中出现，本身也不是聚合列（使用 SUM ，ANG 等函数修饰的列），那么这句 SQL 是不合法的，因为那一列是不确定的，可能存在多个值 ( 违反了关系型数据库的关系原则 )</p><div class="note danger"><p>group by 后接的是需要分组字段，而 having 后接分组之后的过滤条件，having 语句的存在弥补了<code>WHERE</code>关键字不能与聚合函数联合使用的不足。注意：Mysql 要求 having 子句中的每一个元素也必须出现在 select 后面的查询列表中。<br>查询平均分高于80分的学生记录可以这样写：</p><p>SELECT id, COUNT(course) as numcourse, AVG(score) as avgscore</p><p>FROM student</p><p>GROUP BY id</p><p>HAVING AVG(score)&gt;=80;</p></div><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>LIMIT a,b ：注：a 表示此次查询跳过多少条数据 ， b 表示此次查询多少条数据<br>当前页</p><h2 id="DCL-数据控制语言"><a href="#DCL-数据控制语言" class="headerlink" title="DCL 数据控制语言"></a>DCL 数据控制语言</h2><p>DCL ( Data Query Language ) 数据控制语言 ： 用于授权或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等，关键字包括： GRANT ( 授权 ) 、 REVOKE ( 取消授权 )</p><h2 id="TCL-事务控制语言"><a href="#TCL-事务控制语言" class="headerlink" title="TCL 事务控制语言"></a>TCL 事务控制语言</h2><p>TCL ( Transaction Control Language ) 事务控制语言 ： 关键字包括 ： COMMIT 、 ROLLBACK 、 SAVEPOINT<br><strong>只有 DML 才会产生事务，其他的不会产生事务</strong> ， 当 COMMIT / ROLLBACK / DDL 语句执行完后都会终止当前事务</p><p>事务：逻辑单元执行的一系列操作，用于保持逻辑数据的<strong>一致性</strong>和<strong>可恢复性</strong></p><ul><li>查看事务自动提交的状态 ： <code>SHOW VARIABLES LIKE &quot;autocommit&quot;;</code></li><li>关闭自动提交事务：<code>SET autocommit = 0;</code></li><li>开启事务管理 ：<code>START TRANSACTION;</code></li><li>提交事务：<code>COMMIT</code></li><li>回滚事务: <code>ROLLBACK</code></li></ul><p>事务管理的四大特征 ACID</p><ul><li>原子性(Atomic)：<code>被事务管理的数据操作为原子操作，要么全部成功，要么全部失败</code></li><li>一致性(Consistency)：<code>被事务管理的数据操作执行前后，数据总量保持一致</code></li><li>隔离性(Isolation)：<code>一个未提交的事务是否对其他事务可见</code></li><li>持久性(Durability)：<code>一个事务一旦被提交，那么数据库中的数据的改变就是永久性</code></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>数据库与缓存</category>
      </categories>
      <tags>
        <tag>note</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SE09-常用API注意事项</title>
    <url>/sr/post/2019-12-15-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2020-01-03-SE09-%E5%B8%B8%E7%94%A8API%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2><center>String</center></h2><p>java.lang.String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。Java 程序当中所有的双引号字符串，都是 String 类的对象(即使没有 new 关键字)</p><p><strong>String 类特点：</strong></p><p>1.字符串的内容永不可变(字符串本身不能改变，但字符串变量引用是可以改变的)<br>2.正是因为字符串不可改变，所以字符串是可以共享使用的<br>3.字符串效果上相当于是 char[] 字符数组，但是底层原理是 byte[] 字节数组(被final修饰的数组: private final byte[] value)</p><p><strong>String 类常见方法：</strong></p><p>A.与比较相关的方法<br>对于基本类型来说，==是进行数值的比较。<br>对于引用类型来说，==是进行【地址值】的比较。<br>对应比较字符串内容，可以使用两种方法。<br>boolean equals(Object anObject)<br>将此字符串与指定的对象比较。<br>注意事项：<br>a. 任何对象都能用Object进行接收。<br>b. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。<br>c. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。<br>推荐格式：”abc”.equals(str) 不推荐：str.equals(“abc”)</p><pre><code>boolean equalsIgnoreCase(String anotherString)
        将此 String 与另一个 String 比较，不考虑大小写。</code></pre><p>B.与获取相关的方法<br>char charAt(int index)<br>返回指定索引处的 char 值。<br>String concat(String str)<br>将目标字符串连接到此字符串的结尾返回拼接后新的字符串。<br>int length()<br>返回此字符串的长度。<br>int indexOf(String str)<br>返回指定子字符串在此字符串中第一次出现处的索引。<br>String substring(int beginIndex, int endIndex)<br>返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符<br>C.与截取相关的方法<br>String substring(int beginIndex)<br>截取从参数位置一直到字符串末尾，返回新字符串。<br>String substring(int beginIndex, int endIndex)<br>截取从begin开始，一直到end结束，中间的字符串。备注：[begin,end)，包含左边，不包含右边。</p><p>D.与转换相关的方法<br>char[] toCharArray()<br>将此字符串转换为一个新的字符数组。<br>byte[] getBytes(String charsetName)<br>使用指定的字符集将此String编码为byte序列,并将结果存储到一个新的byte[]中。<br>String replace(CharSequence target, CharSequence replacement)<br>使用 指定的字面值替换序列:replacement 替换 此字符串所有匹配字面值目标序列:target 的子字符串。<br>备注：CharSequence意思就是说可以接受字符串类型。<br>String[] split(String regex)<br>根据给定正则表达式的匹配拆分此字符串<br>基本类型-&gt;字符串（String）</p><p><strong>基本类型与字符串相互转换</strong></p><p>1.基本类型的值+”” 最简单的方法（工作中常用）<br>2.包装类的静态方法toString(参数)，是Object类的toString()重载</p><p>static String toString(int i) ：返回一个表示指定整数的String对象。<br>3.String类的静态方法valueOf(参数)</p><p>static String valueOf(int i) ：返回int参数的字符串表示形式。<br>字符串(String)-&gt;基本类型<br>使用包装类的静态方法parseXXX(“字符串”);</p><p>Integer类：static int parseInt(String s)<br>Double类：static double parseDouble(String s)</p><h2><center>StringBuffer</center></h2><p>append、delete、insert、replace、reverse 方法调用后，返回值都是当前对象自己，所以说，StringBuffer 它可以改变字符序列的长度和内容</p><p>public StringBuffer append(…): 添加任意类型数据的字符串形式，并返回当前对象自身</p><h2><center>StringBuilder</center></h2><p>也是一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快</p><p>public StringBuilder append(…): 添加任意类型数据的字符串形式，并返回当前对象自身</p><div class="note info"><p>StringBuffer 和 StringBuilder 都可以调用 toString() 转为 String</p></div><h2><center>Scanner</center></h2><p>Scanner 类可以解析基本类型和字符串的简单文本扫描器</p><p>步骤1.导包<br>使用import关键字导包，在类的所有代码之前导包，引入要使用的类型，java.lang包下的所有类无需导入。<br>格式：java.util.Scanner;</p><p>步骤2.创建对象<br>使用该类的构造方法，创建一个该类的对象。<br>格式：Scanner sc = new Scanner(System.in);</p><p>步骤3.调用方法<br>调用该类的成员方法，完成指定功能。<br>格式：int i = sc.nextInt(); // 接收一个键盘录入的整数</p><p>Scanner 中的 nextLine() 会获取到回车或者空格，Tab键，next()不会；</p><h2><center>Random</center></h2><p>此类的实例用于生成伪随机数</p><h2><center>Arrays</center></h2><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法。<br>A. static String toString(int[] a)<br>返回指定数组内容的字符串表示形式。将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3…]）<br>B. static void sort(int[] a)<br>对指定的 int 型数组按数字升序进行排序。</p><p>注意：<br>a. 如果是数值，sort默认按照升序从小到大<br>b. 如果是字符串，sort默认按照字母升序<br>c. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。</p><h2><center>Math</center></h2><p>数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作</p><p>static double abs(double num)：获取绝对值。(针对数字量)<br>static double ceil(double num)：向上取整。(小数点后面非零加1)<br>static double floor(double num)：向下取整。(去零)<br>static int round(double num)：四舍五入(返回int)<br>static double PI: 比任何其他值都更接近 pi（即圆的周长与直径之比）的 double 值</p><h2><center>Date</center></h2><p>表示日期和时间的类<br>毫秒：千分之一秒 1000毫秒=1秒</p><p>把日期转换成毫秒：</p><p>当前的日期:2019-07-18<br>时间原点（0毫秒）：1970-01-01 00：00：00（英国格林威治）<br>就是计算当前日期到时间原点之间一共经历了多少毫秒<br>注意：<br>中国属于东八区，会把时间增加8个小时</p><p>1970-01-01 08：00：00<br>把毫秒转换为日期：</p><p>1天 = 24* 60* 60 = 86400秒 = 86400*1000=86400000毫秒</p><h3><center>DateFormat</center></h3><p>java.text.DateFormat: 日期/时间格式化抽象类</p><p>作用：格式化（也就是日期 -&gt; 文本），解析（文本 -&gt; 日期）</p><p>常用成员方法：</p><p>String format(Date date): 按照指定的模式，把Date日期，格式化为符合模式的字符串<br>Date parse(String source): 把符合模式的字符串，解析为Date日期</p><p>DateFormat类是一个抽象类，无法直接创建对象使用，可以使用其子类 <code>SimpleDateFormat</code></p><h3><center>Calendar</center></h3><p>java.util.Calendar：日历抽象类<br>Calendar 类是一个抽象类，里边提供了很多操作日历字段的方法（YEAR、MONTH、DAY_OF_MONTH、HOUR)<br>Calendar 类无法直接创建对象使用，里边有一个静态方法叫 getInstance(), 该方法返回了 Calendar 类的子类对象<br>static Calendar getInstance() 使用默认时区和语言环境获得一个日历。</p><p>常用成员方法:</p><p>public int get(int field);返回给定日历字段的值。<br>public void set(int field,int value);将给定的日历字段设置为给定值<br>public abstract void add(int field, int amount);根据日历的规则，为给定的日历字段添加或减去指定的时间量。<br>public Data getTime();返回一个表示次Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。</p><h3><center>System</center></h3><p>java.lang.System: 该系统类提供的工具包括标准输入、标准输出和错误输出流；访问外部定义的属性和环境变量；加载文件和库的方法；以及快速复制数组一部分的实用方法</p><p>成员变量：<br>public final static PrintStream err “标准”错误输出流。<br>public final static InputStream in “标准”输入流。<br>public final static PrintStream out “标准”输出流。</p><p>常用成员方法:</p><p><strong><em>public static native long currentTimeMillis()</em></strong><br>以毫秒为单位返回当前时间，当前时间与1970年1月1日世界时午夜之间的差，以毫秒为单位。<br>虽然返回值的时间单位是毫秒，但值的粒度取决于底层操作系统，并且可能更大。例如，许多操作系统以几十毫秒为单位测量时间</p><p><strong><em>public static String lineSeparator()</em></strong><br>返回依赖于系统的行分隔符字符串。<br>在UNIX系统上，它返回”\n”; 在Microsoft Windows系统上它返回”\r\n”</p><p><strong><em>public static void exit(int status)</em></strong><br>终止当前运行的Java虚拟机。参数 status 用作状态代码；按照惯例，非零状态代码表示异常终止</p><p><strong><em>public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int Length)</em></strong></p><p>将数组中指定的数据拷贝到另一个数组中。<br>参数介绍：<br>src - 源数据<br>srcPos - 源数据中的起始位置（起始索引）<br>dest - 目标数组<br>destPos - 目标数据中的起始位置<br>Length - 要复制的数组元素的数量</p><p><strong><em>public static void gc()</em></strong><br>运行垃圾收集器，调用该gc方法表明Java虚拟机花费了大量精力来回收未使用的对象，以使其当前占用的内存可用于快速重用。当控制从方法调用返回时，Java虚拟机已尽最大努力从所有丢弃的对象中回收空间<br>等同于：Runtime.getRuntime().GC();</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>Git</title>
    <url>/sr/post/2019-12-13-%E6%9D%82%E9%A1%B9-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7-2019-12-13-Git/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>设置用户名跟邮箱，用于区分开发人员<ul><li>项目级别签名:<br>git config user.name “你的目标用户名”<br>git config user.email “你的目标邮箱名”</li><li>系统级别签名<br>git config –global user.name “你的目标用户名”<br>git config –global user.email “你的目标邮箱名”</li><li>查看签名：<br>git config user.name<br>git config user.email</li></ul></li></ul><h2 id="使用-Git-推送代码"><a href="#使用-Git-推送代码" class="headerlink" title="使用 Git 推送代码"></a>使用 Git 推送代码</h2><h3 id="推送至-Github"><a href="#推送至-Github" class="headerlink" title="推送至 Github"></a>推送至 Github</h3><ul><li>1.Github 新建一个 repositories</li><li>2.进入你需要推送的本地工程代码目录下，右键打开 Git Bash</li><li>3.开始命令行操作<br>step1 初始化：<code>git init</code><br>step2 添加全部文件：<code>git add --all</code>，查看工作区状态 <code>git status</code>(红色的代表未添加)<br>step3 提交：<code>git commit -m &#39;这里书写仓库的描述&#39;</code><br>step4 添加远程仓库路径(ssh/http)：<code>git remote add origin git@github.com:xxx/xxx.git</code><br>step5 推送代码：<code>git push -u origin master</code></li></ul><h3 id="命令小结"><a href="#命令小结" class="headerlink" title="命令小结"></a>命令小结</h3><p>git init：初始化一个Git仓库<br>git status：查看仓库当前状态<br>git diff：查看修改文件内容详情<br>git add .：把修改的文件提交到仓库<br>git commit -m “本次提交的备注信息，修改了什么或完成什么功能”：本次提交的说明<br>git log：显示从最近到最远的提交日志<br>git reset –hard commit_id：选择不同版本<br>git reflog：查看命令历史<br>git checkout – file：撤销（在准备提交前）<br>git reset HEAD file：撤销（git add 后，还未提交）<br>git rm：删除文件<br>git remote add origin git@server-name:path/repo-name.git：关联一个远程仓库<br>git push -u origin master：推送master分支内容<br>git push origin master：推送最新更改<br>git clone：克隆远程仓库<br>git branch -v 查看本地库中的所有分支<br>git branch dev 创建一个新的分支<br>git checkout dev 切换分支<br>git config –local -l 查看仓库级配置</p><h3 id="日常-push-报错"><a href="#日常-push-报错" class="headerlink" title="日常 push 报错"></a>日常 push 报错</h3><h4 id="Cause-Git-或-Git插件更新-引发-TaskCanceledException"><a href="#Cause-Git-或-Git插件更新-引发-TaskCanceledException" class="headerlink" title="Cause: Git 或 Git插件更新,引发 TaskCanceledException"></a>Cause: Git 或 Git插件更新,引发 TaskCanceledException</h4><div class="note danger"><p>Fatal: TaskCanceledException encountered.</p></div><div class="note success"><p>Troubleshooting:</p><p>step1 git config –-global credential.helper manager<br>step2 git push</p></div><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>EE01-XML</title>
    <url>/sr/post/2019-12-11-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-EE-2019-12-11-EE01-XML/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="XML-概述"><a href="#XML-概述" class="headerlink" title="XML 概述"></a>XML 概述</h2><p>XML(Extensible Markup Language)是一种可扩展标记语言</p><p>XML 的发展和 Java 是相互独立的，但是它和 Java 具有的相同目标即平台独立性。通过将 Java 和 XML 的组合，可以得到一个完美的具有平台独立性的解决方案。</p><p>JavaEE 平台全面支持和实施 XML，这种强大的组合可使 XML 具备跨平台的兼容性，甚至用于对 XML 代码进行语法检查和调试的工具也可与平台无关。</p><p>因为 XML 可实施独立于平台的数据，而 JavaEE 平台则可实施独立于平台的解决方案，所以 JavaEE 技术和 XML 技术分别是企业开发的阴阳两极。XML 可通过移植的方式表现数据，，可以得到一个完美的具有平台独立性的解决方案。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>EE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE08-注解</title>
    <url>/sr/post/2019-12-10-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-10-SE08-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>也被称为<code>元数据</code>，它为我们在代码中添加标注信息提供了一种形式化方法，是框架设计的基石</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><p>@Override：检查是否为重写方法</p><p>@SuppressWarnings：压制编译器警告信息</p><p>@Deprecated：标记过时的方法</p><h3 id="注解属性类型"><a href="#注解属性类型" class="headerlink" title="注解属性类型"></a>注解属性类型</h3><ul><li>基本类型（boolean 除外）</li><li>String 类型</li><li>枚举类型</li><li>Class 类型</li><li>注解类型</li><li>以上各类型的一维数组类型</li></ul><h3 id="注解属性赋值"><a href="#注解属性赋值" class="headerlink" title="注解属性赋值"></a>注解属性赋值</h3><p>@注解名{属性名1=值1，属性名2=值2，属性名3=值3…}</p><ul><li>当注解拥有一个且仅有一个属性时，若此属性名为 value ，在赋值操作时无须书写属性名</li><li>注解属性可以拥有默认值，默认值定义方法：<strong>属性类型 属性名() default 默认值;</strong></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解用于注解其他的注解，通常标注在注解声明之上</p><ul><li><p>@Target：设置该注解的使用位置，属性 ElementType<br>可能的可选参数有</p><ul><li>TYPE：类、接口（包括注解类型）、enum 声明</li><li>CONSTRUCTOR：构造器声明处</li><li>FIELD：域声明（包括 enum 实例）</li><li>METHOD：方法声明处</li><li>PARAMETER：参数声明处</li></ul></li><li><p>@Retention：设置在某个级别保留该注解信息，属性 RetentionPolicy<br>可选参数有</p><ul><li>SOURCE：将只存活在源码阶段，编译时丢弃该注解</li><li>CLASS：将只存活在 Class 阶段，运行时 JVM 丢弃该注解</li><li>RUNTIME：将保留至运行阶段</li></ul></li><li><p>@Documented：将此注解包含在 Javadoc 内</p></li><li><p>@Inheriteed：允许子类继承父类中的注解</p></li></ul><p>案例：通过反射获取注解上的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetValue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;User&gt; clazz = User<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        PassWord p = clazz.getAnnotation(PassWord<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        printf(<span class="string">"password：%s\n"</span>， p.value());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**output</span></span><br><span class="line"><span class="comment">     * password：Lqi1001</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PassWord</span>(<span class="string">"Lqi1001"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> PassWord &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE07-反射</title>
    <url>/sr/post/2019-12-10-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-10-SE07-%E5%8F%8D%E5%B0%84/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射：reflex 用来在运行时获取一个字节码对象的所有信息（字段、方法、构造器）</p><p>java.lang.reflect 包下提供了用于获取关于类和对象的反射信息的类和接口，反射允许对封装类的字段，方法和构造函数的信息进行编程访问，以及在封装和安全限制内使用反射的字段，方法和构造函数对其底层进行操作。</p><h3 id="Class-字节码对象"><a href="#Class-字节码对象" class="headerlink" title="Class 字节码对象"></a>Class 字节码对象</h3><p>Class 类定义</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>，</span></span><br><span class="line"><span class="class">                              <span class="title">GenericDeclaration</span>，</span></span><br><span class="line"><span class="class">                              <span class="title">Type</span>，</span></span><br><span class="line"><span class="class">                              <span class="title">AnnotatedElement</span>，</span></span><br><span class="line"><span class="class">                              <span class="title">TypeDescriptor</span>.<span class="title">OfField</span>&lt;<span class="title">Class</span>&lt;?&gt;&gt;，</span></span><br><span class="line"><span class="class">                              <span class="title">Constable</span></span></span><br></pre></td></tr></table></figure><p>Java 基本数据类型（ boolean ， byte ， char ， short ， int ， long ， float ，double ）和关键字 void 也可以获取 Class 对象</p><p>字节码对象获取方式</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一： 类名.class;</span></span><br><span class="line">Class c1 = Object<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"><span class="comment">// 方式二： Class.forName(全限定类名);</span></span><br><span class="line">Class c2 = Class.forName(<span class="string">"java.lang.Object"</span>);</span><br><span class="line"><span class="comment">// 方式三： 对象实例.getClass();</span></span><br><span class="line">Class c3 = <span class="keyword">new</span> Object().getClass();</span><br></pre></td></tr></table></figure><h4 id="通过-Class-对象获取-Constructor"><a href="#通过-Class-对象获取-Constructor" class="headerlink" title="通过 Class 对象获取 Constructor"></a>通过 Class 对象获取 Constructor</h4><p><strong>获取单个 Constructor 对象</strong></p><ul><li><p>public Constructor<t>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) 通过传入指定构造器的参数的 Class 对象，从而返回所匹配构造器对象</t></p></li><li><p><em>获取多个 Constructor 对象*</em><br>如果该 Class 对象表示接口、基本类型、数组类型或 void ，则此方法返回长度为 0 的数组</p></li><li><p>public Constructor&lt;?&gt;[] getDeclaredConstructors()：返回该 Class 对象表示的类声明的所有构造器对象数组(包括公共、受保护、默认（包）访问和私有构造函数)</p></li></ul><h4 id="通过-Class-对象获取-Filed"><a href="#通过-Class-对象获取-Filed" class="headerlink" title="通过 Class 对象获取 Filed"></a>通过 Class 对象获取 Filed</h4><p><strong>获取单个 Filed 对象</strong></p><ul><li>public Field getDeclaredField(String name)：通过指定的字符串获取对应单个 Field 对象</li></ul><p><strong>获取多个 Filed 对象</strong><br>如果该 Class 对象为数组类型、基本类型或 viod ，则以下两个方法返回长度为 0 的数组</p><ul><li>public Field[] getFields()：返回该 Class 对象表示的类或接口声明的所有公开字段对象数组（包括父类和父接口）</li><li>public Field[] getDeclaredFields()：返回该 Class 对象表示的类或接口声明的所有字段对象数组（包括公共、受保护、默认（包）访问和私有字段，但不包括继承的字段）</li></ul><h4 id="通过-Class-对象获取-Method"><a href="#通过-Class-对象获取-Method" class="headerlink" title="通过 Class 对象获取 Method"></a>通过 Class 对象获取 Method</h4><p><strong>获取单个 Method 对象</strong><br>如果该 Class 对象为数组类型或 name 指定为 “ “/“” ，则抛出 NoSuchMethodException</p><ul><li>public Method getDeclaredMethod(String name， Class&lt;?&gt;… parameterTypes)：通过指定的字符串、指定声明顺序的多个或 0 个形参类型 Class 对象获取对应单个 Method 对象</li></ul><p><strong>获取多个 Method 对象</strong><br>如果该 Class 对象为接口、数组类型、基本类型或 viod ，则返回长度为 0 的数组</p><ul><li>public Field[] getMethods()：返回该 Class 对象表示的类或接口声明的所有公共方法对象数组（包括父类和父接口）</li><li>public Method[] getDeclaredMethods()：返回该 Class 对象表示的类或接口声明的所有方法对象数组（包括公共、受保护、默认（包）访问和私有方法，但不包括继承的方法）</li></ul><h3 id="反射相关类"><a href="#反射相关类" class="headerlink" title="反射相关类"></a>反射相关类</h3><p>注意抑制访问权限检查：通过反射类对象.setAccessible(true);</p><h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><p>通过反射技术获取 Constructor 对象，并创建对象<br>Constructor 类定义</p><blockquote><p>public final class Constructor<t>extends Executable</t></p></blockquote><p>常用方法：</p><ul><li>Constructor类的–&gt;newInstance(Object … params)</li></ul><h4 id="Filed"><a href="#Filed" class="headerlink" title="Filed"></a>Filed</h4><p>通过反射获取 Filed 对象，并且能够给对象的属性赋值和取值<br>Filed 类定义</p><blockquote><p>public final class Field extends AccessibleObject implements Member</p></blockquote><p>常用方法：<br>set(Object obj ，Object value)：将指定 obj 对象上此 Filed 表示的字段设置为 value，若此字段是静态的，则将 obj 设置为 null<br>get(obj)：返回指定 obj 对象上此 Filed 表示的字段值</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>通过反射获取 Method 对象，并且调用方法<br>Method 类定义</p><blockquote><p>public final class Method extends Executable</p></blockquote><p>常用方法：</p><ul><li>invoke(Object obj， Object… args) 将指定 obj 对象的方法传入 args 并调用执行，若此方法是静态的，则将 obj 设置为 null</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE06-IO</title>
    <url>/sr/post/2019-12-05-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-05-SE06-IO/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>文件和目录路径名的抽象表示，主要用来文件和目录路径的创建、删除、查找操作</p><p>构造方法：<br>* File​(String pathname) 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例<br>* File​(String parent， String child) 从父路径名字符串和子路径名字符串创建新的 File实例<br>* File​(File parent， String child) 从父抽象路径名和子路径名字符串创建新的 File实例</p><p>常用成员方法：</p><ul><li><p>获取：</p><ul><li>String getAbsolutePath​() 返回此抽象路径名的绝对路径名字符串</li><li>String getName​() 返回由此抽象路径名表示的文件或目录的名称</li><li>String getPath​() 将此抽象路径名转换为路径名字符串</li><li>long length​() 获取文件（无法计算文件夹）字节数</li></ul></li><li><p>判断</p><ul><li>boolean exists​() 测试此抽象路径名表示的文件或目录是否存在</li><li>boolean isFile​() 测试此抽象路径名表示的文件是否为普通文件 (不存在则直接返回 false )</li><li>boolean isDirectory​() 测试此抽象路径名表示的文件是否为目录 (不存在则直接返回 false )</li></ul></li><li><p>创建、删除</p><ul><li>boolean mkdir​() 创建由此抽象路径名命名的目录（单级目录）</li><li>boolean mkdirs​() 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录（创建单级或多级目录）</li><li>boolean createNewFile​() 当且仅当具有该名称的文件尚不存在时，原子地创建新的空文件(已存在则直接返回 false )</li><li>boolean delete​() 删除由此抽象路径名表示的文件或空目录</li></ul></li><li><p>目录遍历：如果获取的抽象路径名不表示目录，或返回 IO 错误，则返回 null</p><ul><li>String[] list​() 返回 String 数组，一个文件夹下的所有子文件和子目录名称的 String</li><li>File[] listFiles​() 返回 File 数组，一个文件夹下的所有子文件和子目录路径的 File</li></ul></li></ul><h2 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h2><p>输入：硬盘—&gt;内存<br>输出：内存—&gt;硬盘<br>Java 中主要利用 java.io 包下的类实现对数据的输入/输出操作，它的总体设计是符合装饰者模式（Decorator）跟适配器模式（Adapter）的。</p><ul><li>装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者模式提供了比继承更有弹性的替代方案。 通俗的解释：装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求<strong>装饰对象和被装饰对象实现同一个接口</strong>，装饰对象持有被装饰对象的实例。体现：将普通FileReader（读取单个）转为BufferedReader（读取一行）</li></ul><hr><ul><li>适配器模式：将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以兼容运行。 适配器模式有三种：类的适配器模式、对象的适配器模式、接口的适配器模式。 通俗的说法：适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。体现：使用<code>InputStreamReader</code>将字节流转为字符流</li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>以字节为读取单位，可以读取任何文件</p><ul><li>字节输入流，顶层父类： InputStream</li><li>字节输出流，顶层父类： OutputStream</li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>以字符为读取单位，只能读取字符文件（文本文件）</p><ul><li>字符输入流，顶层父类： Reader</li><li>字符输出流，顶层父类： Writer</li></ul><p><strong>普通的字符/字节流</strong></p><p>字节字符的输出流都拥有续写开关 append ，可以在原文件基础上追加数据：将其置为 true ，传入构造器即可：<code>FileOutputStream fos = new FileOutputStream(&quot;text.txt&quot;，true);</code></p><ul><li>FileInputStream 读到文件结尾返回 -1</li><li>FileOutputStream 使用时：注意若该路径下文件存在，会清空这个文件的数据。否则将创建一个新的文件</li><li>FileReader 读到文件结尾返回 -1</li><li>FileWriter 注意 flush() 与 close() 的区别</li></ul><p><strong>Properties 的用法</strong></p><ul><li>创建一个空的属性集： Properties prop = new Properties();</li><li>加载文件添加属性至属性集: public void load(InputStream inStream)： 从字节输入流中读取键值对。</li></ul><p>常用方法：</p><ul><li>public Object setProperty(String key， String value) ： 保存一对属性。</li><li>public String getProperty(String key) ：使用此属性列表中指定的键搜索属性值。</li><li>public Set<string>stringPropertyNames() ：所有键的名称的集合。</string></li></ul><h3 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h3><p>需要搭配基本的字节字符流一起使用</p><ul><li><p>缓冲流：是对普通IO流的读写功能增强，底层通过缓冲数组（默认大小为8192）来读取字节</p><ul><li>字节缓冲流： BufferedInputStream 、 BufferedOutputStream ，无特有方法，读到文件末尾返回 -1<br><strong>注意：</strong> 当字节缓冲流输出数据时，会先将数据写到缓冲数组中， close()、flush() 或者缓冲数组满了这三种情况之一发生时，会将数据写出</li><li>字符缓冲流： BufferedReader 、 BufferedWriter<br><strong>特有方法</strong><ul><li>读取一行： readLine() 读到文件末尾将不是返回 -1 ，而是返回 null</li><li>写入换行： newLine() 行分隔符字符串由系统属性 line.separator 定义，并不一定是单个换行符 ‘\n’ 字符。</li></ul></li></ul></li><li><p>转换流</p></li><li><p>InputStreamReader<br>java.io.InputStreamReader ，是 Reader 的子类，是从字节流到字符流的桥梁（硬盘==》内存）。读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集，常用构造方法： InputStreamReader​(InputStream in， String charsetName) 创建指定字符集的 InputStreamReader</p></li><li><p>OutputStreamWriter<br>java.io.OutputStreamWriter ，是 Writer 的子类，是从字符流到字节流的桥梁（内存==》硬盘）。使用指定的 charset 将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集， 常用构造方法： OutputStreamWriter​(OutputStream out， String charsetName) 创建指定字符集的 OutputStreamWriter</p></li><li><p>序列化流<br>实现了 <strong>java.io.Serializable</strong> 接口的类才能被序列化，序列化保存对象时，不能被序列化保存的域 ： static 、transient 关键字修饰的成员变量</p><ul><li>ObjectOutputStream ：通过指定序列化路径，将对象二进制数据输出至硬盘<ul><li>1.指定序列化路径： ObjectOutputStream(OutputStream out)</li><li>2.调用 writeObject(序列化对象) 将对象输出至硬盘</li><li>3.关闭流 close()</li></ul></li><li>ObjectInputStream ：通过指定反序列化路径，将对象二进制数据加载至内存<ul><li>1.指定反序列化路径： ObjectInputStream(InputStream in)</li><li>2.调用 readObject() 将路径下对象加载至内存</li><li>3.关闭流 close()</li></ul></li></ul></li><li><p>打印流</p><ul><li>PrintStream</li><li>PrintWriter</li></ul></li></ul><h2 id="常见-IO-模型"><a href="#常见-IO-模型" class="headerlink" title="常见 IO 模型"></a>常见 IO 模型</h2><h3 id="BIO-同步阻塞-IO"><a href="#BIO-同步阻塞-IO" class="headerlink" title="BIO 同步阻塞 IO"></a>BIO 同步阻塞 IO</h3><h4 id="使用-BIO-进行网络通信的窘境"><a href="#使用-BIO-进行网络通信的窘境" class="headerlink" title="使用 BIO 进行网络通信的窘境"></a>使用 BIO 进行网络通信的窘境</h4><p>如果使用普通IO来建立套接字连接，服务端线程可能阻塞在其中某个客户端套接字的数据连接上，此时另一个套接字即使准备就绪也无法进行与服务端的通信，解决办法就是在服务端开启多条线程访问<br>改善： 使用 NIO</p><h3 id="NIO-简介"><a href="#NIO-简介" class="headerlink" title="NIO 简介"></a>NIO 简介</h3><p>非阻塞式 IO + 多路复用器</p><h4 id="NIO-的三大核心组件"><a href="#NIO-的三大核心组件" class="headerlink" title="NIO 的三大核心组件"></a>NIO 的三大核心组件</h4><h5 id="Buffer-缓冲器"><a href="#Buffer-缓冲器" class="headerlink" title="Buffer 缓冲器"></a>Buffer 缓冲器</h5><p>Buffer 对于每个非布尔类型的基本类型都有一个实现子类</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>LongBuffer</li></ul><p>Buffer 的 4 个属性:</p><ul><li>capacity： Buffer 容量</li><li>limit： Buffer 内可操作数据个数</li><li>position： Buffer 中正在操作的数据位置</li><li>mark： Buffer 通过调用 mark() 来记录 position ，可以通过 reset() 回溯 position</li><li>关系： mark &lt;= position &lt;= limit &lt;= capacity</li></ul><p>使用 Buffer 进行读写的基本步骤：</p><ul><li>1.写入数据 put()</li><li>2.切换成读取模式 flip()</li><li>3.读取数据 get()</li><li>4.清除此缓冲区 clear() / 压缩此缓冲区 compact()</li></ul><h5 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel 通道"></a>Channel 通道</h5><p>Channel 是一个接口，表示到实体（如硬件设备、文件、网络套接字或程序组件）的开放连接，该实体能够执行一个或多个不同的I/O操作，例如读取或写入。<br>Channel 负责传输，Buffer 负责存储，而 Channel 是与 Selector 适配使用</p><p>常用通道实现类：</p><ul><li>FileChannel：从文件中读写数据的</li><li>DatagramChannel： UDP网络协议数据</li><li>SocketChannel： 读写TCP网络协议数据</li><li>ServerSocketChannel： 可以监听TCP连接</li></ul><h5 id="Selector-选择器-多路复用器"><a href="#Selector-选择器-多路复用器" class="headerlink" title="Selector 选择器/多路复用器"></a>Selector 选择器/多路复用器</h5><p>Selector 是 NIO 核心的核心</p><p>使用 Selector 管理在上面注册的 Channel ，监视 Channel 状态是否就绪，从而可以实现单线程下一个选择器管理多个 Channel ，而通道可以绑定端口，相当于单线程下管理多个网络连接。</p><p>好处：通过 Selector 可以同时监听多个 IO 事件，以提高事件处理效率，合理分配资源</p><p>事件：</p><ul><li><p>SelectionKey.OP_READ: 读就绪事件，表示通道中有了可读的数据，可以执行读操作了，如果选择器检测到相应的通道已准备好读取、已到达流的末尾、已远程关闭以进行进一步读取或有错误等待处理，则它将向密钥的就绪操作集添加 OP_READ</p></li><li><p>SelectionKey.OP_WRITE: 写就绪事件，表示已经可以向通道中写数据了(通道目前可以用于写操作)，如果选择器检测到相应的通道已准备好写入、已被远程关闭以进行进一步写入或有一个错误等待处理，则它将向键的准备集添加操作写入</p></li><li><p>SelectionKey.OP_CONNECT：连接就绪事件，表示客户端和服务器的连接已经建立成功，如果选择器检测到对应的套接字通道已准备好完成其连接序列，或有一个错误挂起，则它会将OP_CONNECT添加到密钥的 ready set</p></li><li><p>SelectionKey.OP_ACCEPT : 接收连接就绪事件，表示服务器监听到了客户连接，服务器可以接收这个连接了，如果选择器检测到相应的服务器套接字通道已准备好接受另一个连接，或有一个挂起的错误，则它将向密钥的就绪集添加 OP_accept</p></li></ul><p>简单使用步骤：</p><ul><li>实例化一个 Channel</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServerSocketChannel channel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><ul><li>开启一个选择器：</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><ul><li>将 channel 设置为非阻塞状态，然后注册到选择器</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);<span class="comment">// 非阻塞</span></span><br><span class="line">SelectionKey key =channel.register(selector，SelectionKey.OP_READ);<span class="comment">// 注册</span></span><br></pre></td></tr></table></figure><ul><li>调用选择器的 select() ，此方法会进入阻塞状态，直到有一个或多个 channel 的状态符合条件时才返回，此时返回值为就绪的 channel 数量</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> pass = selector.select(); <span class="comment">//进入阻塞</span></span><br></pre></td></tr></table></figure><ul><li>select() 返回后，调用 selector.selectedKeys(); 获取所有注册成功并就绪的 SelectionKey 对象，此方法返回一个 Set<selectionkey></selectionkey></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; selectorSet = selector.selectedKeys();</span><br></pre></td></tr></table></figure><ul><li>通过遍历得到每个 SelectionKey ，调用 SelectionKey 的静态方法 channel() 返回其创建此密钥的通道实例，然后处理此通道的相关事件…</li></ul><p>关键点：</p><ul><li>注册</li><li>select 阻塞</li><li>处理事件</li></ul><p>注意：FileChannel 没有异步模式，不能注册到选择器</p><p>// TODO</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE05-Lambda和Stream</title>
    <url>/sr/post/2019-12-02-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-02-SE05-Lambda%E5%92%8CStream/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p><strong>函数式编程</strong>：函数式编程是种编程方式，它将电脑运算视为函数的计算。函数编程语言最重要的基础是λ演算（lambda calculus），而且λ演算的函数可以接受函数当作输入（参数）和输出（返回值），其主要思想是把运算过程写成嵌套函数调用，Java 中体现为 Lambda 表达式的使用</p><p><strong>函数式接口</strong>：当接口中有且只有一个抽象方法时，此接口就是函数式接口（可以有其他方法比如：默认方法，静态方法…），可以使用 <code>@FunctionalInterface</code> 注解来标识</p><h3 id="Lambda-使用条件"><a href="#Lambda-使用条件" class="headerlink" title="Lambda 使用条件"></a>Lambda 使用条件</h3><ol><li>必须是函数式接口</li><li>可以语句上下文推断</li></ol><h3 id="Lambda-格式要求："><a href="#Lambda-格式要求：" class="headerlink" title="Lambda 格式要求："></a>Lambda 格式要求：</h3><p>标准格式：()-&gt;{}</p><p>省略格式（3种情况可省）：</p><ul><li>小括号中的形式参数类型可以不写</li><li>当且仅当接口的参数只有一个时，小括号可以省略不写</li><li>当花括号中语句只有一条语句时，花括号、return、分号可以省略(同时省略)</li></ul><h3 id="函数式编程优点"><a href="#函数式编程优点" class="headerlink" title="函数式编程优点"></a>函数式编程优点</h3><ul><li>代码简洁，开发迅速</li><li>不改变输入参数，方便代码管理</li><li>易于“并发编程”</li></ul><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>java.util.Stream 表示能应用在一组元素上执行操的作序列，一般应用于 java.util.Collection 的子类<br>Stream 特点：不改变源操作数的状态，最后必须有终结方法，否则延迟方法不会执行，流不能重复使用。</p><p>怎么获取流?</p><ul><li>获取集合的流： Collection.stream() Collection 集合调用方法 stream 获取一个流</li><li>获取 Map 的流：先通过 keySet 、values 、entrySet 方法获取到集合对象，再获取流</li><li>获取数组的流： Stream.of(数组名)</li></ul><p>延迟方法：方法特征—&gt;方法返回值为 Stream<t>类型</t></p><ul><li>filter 过滤：方法参数 interface Predicate&lt;? super T&gt; p – 过滤条件的接口，需实现抽象方法 test()<br>接口常用默认方法<ul><li>negate()：对过滤条件取反集</li><li>and(条件n)：通过 filter(A.and(B)) 实现 A &amp;&amp; B</li><li>or(条件n)：通过 filter(A.or(B)) 实现 A || B</li></ul></li></ul><ul><li>Sorted 排序：方法参数 interface Comparator&lt;? super T&gt; c – 排序规则的接口，需实现抽象方法 compare()</li><li>limit 取用前几个</li><li>skip 跳过前几个</li><li>map 类型转换：方法参数 interface Function&lt;T， R&gt; 对象映射的接口，需实现抽象方法 apply() ，将 T 类型转换为 R 类型<br>接口常用默认方法</li><li>concat 合并两个 Stream 流</li></ul><p>终结方法：方法特征—&gt;方法返回值不为 Stream<t>类型</t></p><ul><li>count 统计个数</li><li>forEach 逐一消费元素</li></ul><p>元素收集</p><ul><li>收集到 List： collect(Collectors.toList())</li><li>收集到 Set： collect(Collectors.toSet())</li><li>收集到 数组：toArray() ，由于泛型被编译擦除，返回数组类型为 Object</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE04-多线程</title>
    <url>/sr/post/2019-12-01-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-01-SE04-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>并行</strong>：两个或多个事件在<strong>同一时刻</strong>发生 （同时执行）</p><p><strong>并发</strong>：两个或多个事件在<strong>同一时间段</strong>发生（不一定同时执行）</p><p><strong>进程</strong>：是<code>系统资源分配的基本单位</code>，当应用程序启动时，就有一个或多个进程启动<br>特点：拥有独立地址空间，开销大</p><p><strong>线程</strong>：是<code>系统资源调度的基本单位</code>，当我们创建一个 java 程序并加载类文件时就已经开启了一个 main 线程<br>特点：多个线程共享进程的堆和方法区资源，每个线程独立拥有<code>虚拟机栈</code>、程序计数器和本地方法栈，这些开销相较于进程要小得多</p><p>学习完应该要懂得：</p><p>多线程基础（Thread、Runnable）<br>线程状态<br>什么是原子性，CAS算法大致原理<br>了解volatile如何保证内存可见性<br>AtomicXXX类的使用<br>synchronized键字及使用位置<br>Lock锁的使用，与synchronized的区别<br>线程间通信（传统线程技术的wait、notify或者JDK1.5后condition的await和siganl）</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>JVM 允许多个线程并发执行，默认启动 main 和 垃圾回收 两条线程。线程具有优先级，但在初始化时线程优先级都是相同的。线程可能会有守护（后台）线程。<br>导致线程终止的几种情况：</p><ul><li>正常终止：执行完 run()</li><li>意外终止：<ul><li>线程在执行任务时抛出了未捕获异常</li><li>被某线程的 Thread 实例调用了 stop() 强行终止</li><li>执行了 exit()</li></ul></li></ul><p><strong>Java 中线程的生命周期和状态</strong></p><ul><li><strong>新建状态( NEW )</strong>： new 语句创建的线程，未调用 start()</li><li><strong>无限等待状态( WAITING )</strong>：从新建状态后调用 start() 之前或正在运行的线程调用 wait() 之后</li><li><strong>运行状态( RUNNABLE )</strong>：调用 start() 之后，先进入就绪状态（ Java 将<strong>就绪</strong>和<strong>运行</strong>统称为 运行状态）<ul><li>调用 start() ，获取到了 cpu 时间片和锁之后</li><li>处于计时等待的线程计时时间到获取了锁</li><li>处于无限等待的线程被唤醒</li><li>处于阻塞状态的线程获取到了锁</li></ul></li><li><strong>阻塞状态( BLOCKED )</strong>：<ul><li>等待阻塞：线程被唤醒或 wait​(long timeout) 时间到，未获取到锁之后</li><li>同步阻塞：正在运行的程调用同步方法时，未获取到同步锁之后</li><li>其他阻塞：正在运行的线程执行完 sleep() 、 join()（线程加入方法）或者发出了 I/O 请求后</li></ul></li><li><strong>超时等待状态（ TIMED_WAITING ）</strong>：sleep​(long millis) 或者 wait​(long timeout) 被调用后</li><li><strong>死亡状态（ TERMINATED ）</strong>：也称为终止状态。当线程执行完 run() 之后，或遇到未捕获的异常时退出 run() ，进入死亡状态</li></ul><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>主要通过调用 Thread 类的构造方法</p><ul><li><p>一：继承 Thread 类重写 run()，然后创建子类对象，然后调用 start 方法运行线程</p></li><li><p>二：实现 Runnable 接口实现 run()，创建 Thread对象(用实现接口的对象作为参数，实例化 Thread)，然后调用此对象的 start 方法运行线程</p></li><li><p>三：实现 Callable 接口实现 call()，通过 submit()传入线程池，运行线程</p></li><li><p>四：线程池</p></li></ul><div class="note info"><p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险</p></div><h3 id="启动创建相关方法区别"><a href="#启动创建相关方法区别" class="headerlink" title="启动创建相关方法区别"></a>启动创建相关方法区别</h3><p>run() 和 start() 的区别</p><ul><li>run()：线程将要执行的任务，方法体为任务代码，直接调用相当于调用普通方法，不会在创建的线程中执行，而是在 main 线程中执行</li><li>start()：调用此方法将执行线程必须的初始化操作，并将线程添加至线程组通知线程组此线程即将启动，准备运行线程的环境，最终将调用 JVM 执行 run()</li></ul><p>sleep() 和 wait() 有什么区别</p><ul><li>若所在线程拥有某个对象锁 ，wait() 执行后会释放此锁，而 sleep() 不会释放</li><li>sleep() 无需手动唤醒，wait() 需要被其他线程调用同一对象的 notify() 或者 notifyAll() 才能唤醒（或者设置超时等待自动唤醒）</li><li>sleep() 用于暂时停止执行，wait() 常用于线程间通信</li></ul><p>Runnable 接口和 Callable 接口的区别</p><ul><li>线程创建方式区别： Runnable 接口支持 Thread 和 Executors ，而 Callable 仅支持 Executors</li><li>返回值区别： Runnable 接口中的 run() 无返回值，而 Callable 接口中的 call() 返回泛型 V</li><li>异常处理机制：Runnable 接口不能抛出异常，但 Callable 可以</li></ul><p>execute() 和 submit() 的区别</p><ul><li>execute() 提交任务后没有返回值， submit() 提交后返回 Future 对象</li><li>execute() 只能接收 Runnable ，而 submit() 可以接收 Runnable 和 Callable</li></ul><h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源</p><p>产生的必要条件，想要避免/打破死锁只要破坏后面三个条件即可</p><ul><li><p><strong>互斥条件</strong>：在某段时间内某资源只由一个线程占用（互斥排他，一般无法破除）</p></li><li><p><strong>请求与保持条件</strong>：某个线程至少保持有一个资源占用，它又提出了对新的资源请求，但原有资源保持而不释放（一次获取所有资源，设计前期就要避免）</p></li><li><p><strong>不剥夺条件</strong>：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有在使用完后才由自己释放资源（加入超时）</p></li><li><p><strong>环路等待条件</strong>：n个线程之间形成资源请求环形链，n1–&gt;n2，n2–&gt;n3，n3–&gt;n1。（按顺序获取）</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个锁</span></span><br><span class="line">    <span class="keyword">static</span> Object LockA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object LockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类创建 A 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String tName = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.LockA) &#123;</span><br><span class="line">                    <span class="comment">//此处需消耗一下资源（sleep也可以），不加不会出现死锁</span></span><br><span class="line">                    printf(<span class="string">"%s已获取 LockA，正在获取LockB...\n"</span>， tName);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LockB) &#123;</span><br><span class="line">                        printf(<span class="string">"%s已终止\n"</span>， tName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">"A线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类创建 B 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String tName = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.LockB) &#123;</span><br><span class="line">                    <span class="comment">//此处需消耗一下资源（sleep也可以），不加不会出现死锁</span></span><br><span class="line">                    printf(<span class="string">"%s已获取 LockB，正在获取LockA...\n"</span>， tName);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LockA) &#123;</span><br><span class="line">                        printf(<span class="string">"%s已终止\n"</span>， tName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">"B线程"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制原则就是：<strong>当条件不满足时，线程进入无限等待状态；当条件满足时，唤醒线程，继续执行任务</strong></p><p>当正在运行的线程通过锁对象 A ，调用 wait() 时进入无限等待状态， 此时会释放掉锁对象并放弃 cpu 使用权，只有在被同一个锁对象调用 notify() 后，并获取到锁对象时才会重新进入运行状态。</p><p>notify() 随机唤醒此锁对象上的一个等待线程<br>notifyAll() 唤醒此锁对象上的所有等待线程</p><p>wait() 和 notify() 用于多线程协调运行：</p><ul><li>在 synchronized 内部可以调用 wait() 使线程进入等待状态</li><li>必须在已获得的锁对象上调用 wait()</li><li>在 synchronized 内部可以调用 notify() 或 notifyAll() 唤醒其他等待线程</li><li>必须在已获得的锁对象上调用 notify() 或 notifyAll()</li><li>被唤醒的线程需要重新获得锁后才能继续运行</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>什么是线程安全：当程序中有多个线程在访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也无需额外的同步操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>线程安全问题将是 Java 并发编程中最首要解决的问题，因为它将直接导致运行出来的结果和预期值不一致，解决线程安全，本质上就是让线程同步，实际上就是线程间的通信</p><h2 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h2><h3 id="同步代码块-amp-同步方法"><a href="#同步代码块-amp-同步方法" class="headerlink" title="同步代码块&amp;同步方法"></a>同步代码块&amp;同步方法</h3><p>synchronized 是 <strong>重量级锁</strong>，底层原理属于 JVM 层面，它解决对各线程之间访问资源的同步问题，体现了资源的互斥性</p><ul><li>当 synchronized 关键字修饰代码块时，此代码块就是同步代码块，进入此代码块时，需要获取<strong>给定对象的锁</strong>，可以是类对象 (类名.class)</li><li>当 synchronized 关键字修饰成员方法时，此方法就是同步方法，进入此方法时，需要获取<strong>当前实例对象的锁</strong></li><li>当 synchronized 关键字修饰静态方法时，访问静态 synchronized 方法时需获取<strong>当前类对象的锁</strong> (多线程下，静态方法操作静态成员时，可能会出现线程安全问题)</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是用于通过多个线程控制对共享资源的访问的工具，通常，锁提供对共享资源的独占访问：即一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，某些锁可能允许并发访问共享资源，例如 ReadWriteLock 的读取锁。<br>Java 中的 java.util.concurrent.locks 下的 Interface Lock 接口，它提供比 synchronized 更广泛、更灵活的锁操作，其主要的实现类是 <code>ReentrantLock</code></p><p>主要方法：</p><ul><li>void lock​() //获得锁</li><li>void unlock​() // 尝试释放此锁</li></ul><p>代码实例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        count += n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//保证锁被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</p><p>JDK 1.6 之后的锁优化:</p><ul><li>偏向锁</li><li>轻量级锁</li><li>自旋锁</li><li>自适应锁</li><li>锁消除</li><li>锁粗化</li></ul><h3 id="原子性、可见性"><a href="#原子性、可见性" class="headerlink" title="原子性、可见性"></a>原子性、可见性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>执行某一个操作时，此操作不可在向下细分，一步到位。原子性主要表现在对共享变量的操作中，多线程中若某个操作若不是原子性的，就会被其他线程打断操作，导致操作失效。</p><p>Java 的默认原子操作：</p><ul><li>Atomic包下的类操作</li><li>基本类型赋值( long 和 double 看系统而定)，引用类型赋值</li></ul><p>解决办法：<br>使用原子类（ CAS 机制：比较并交换）</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>由于当下的 Java 内存模型下，每个线程读取 a 变量时会将此变量拷贝一份到自己的工作内存（本地内存：可能是机器的寄存器），以后对 a 变量的操作都是这份副本变量，导致了副本变量对其他线程而言都是不可见的，会出现某个线程已经修改了 a 变量的值，而另一个线程还在继续使用原来的旧的 a 变量副本，最终出现数据结果的不一致。</p><p>解决办法：<br>使用<code>volatile</code>关键字指示该变量为易变的，当修饰变量发生修改时，所有线程的都会收到通知（令拷贝副本失效），以保证可见性，使每次使用都是从主内存中读取到最新值，但它<strong>不保证原子性</strong>。<br>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><p>volatile 保证：</p><ul><li>一旦写入修改，任何访问此字段的线程都会是最新数据</li><li>写入前，会保证所有在此之前该发生的副作用都会执行完</li><li>防止指令重排序</li></ul><p>使用 volatile 关键字需要考虑的情况：</p><ul><li>当修改变量时无需参考当前的变量值</li><li>该变量时可变的，不会在某个情况下处于不变性</li><li>访问时无需加锁</li></ul><p>volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参考 <code>java.util.concurrent.atomic</code> 包下的类，比如 AtomicInteger。</p><h3 id="并发包-JUC"><a href="#并发包-JUC" class="headerlink" title="并发包 JUC"></a>并发包 JUC</h3><h4 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h4><p>atomic 原子类：具有原子性操作特征的类<br>主要的类分为以下 4 种</p><ul><li>基本类型原子类</li><li>数组类型原子类</li><li>引用类型原子类</li><li>对象的属性修改类型原子类：如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</li></ul><p>Atomic 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 允许一个或多个线程等待某些操作完成</p><p><strong>常用方法</strong></p><ul><li>public CountDownLatch(int count)// 初始化一个指定计数器的CountDownLatch对象</li><li>public void await() throws InterruptedException// 让当前线程等待</li><li>public void countDown() // 计数器进行减1</li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier 线程的集合点</p><p><strong>常用方法</strong></p><ul><li>public CyclicBarrier(int parties， Runnable barrierAction)// 用于在线程到达屏障时，优先执行 barrierAction ，方便处理更复杂的业务场景</li><li>public int await() // 每个线程调用 await() 告诉 CyclicBarrier 已到达集合点，然后当前线程被阻塞</li></ul><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore 控制资源的线程访问数量 ，是 Java 版本的信号量实现</p><p><strong>常用方法</strong></p><ul><li>public Semaphore(int permits) // permits 表示许可线程的数量</li><li>public void acquire() throws InterruptedException// 表示获取许可</li><li>public void release()// 表示释放许可</li></ul><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>Exchanger 交换者，是一个用于线程间协作的工具类</p><p><strong>常用方法</strong></p><ul><li>public Exchanger() //</li><li>public V exchange(V x) // x，交换的元素</li></ul><h3 id="CAS-机制-compare-and-swap"><a href="#CAS-机制-compare-and-swap" class="headerlink" title="CAS 机制(compare and swap)"></a>CAS 机制(compare and swap)</h3><p>引入：如金融管理系统，当某个员工需要读取用户的数据，并在读出的用户数据基础上进行修改时（如修改用户手机号，或者余额），如果采用悲观锁机制，也就意味着在整个操作过程中（从读取数据、开始修改、提交修改、还要加上中途未进行操作的时间），而数据记录始终处于加锁状态（高并发情况下将无法操作此记录），而乐观锁在一定程度上解决了这个问题，乐观锁大多是基于<code>数据版本（ version ）记录机制</code>或者 <code>CAS</code> 来实现的，在操作数据时，将版本号一同读出，之后更新时，变更版本号（加1）。如果旧值与它在 Atomic 对象中的内存值不一致，那么这个操作将失败—意味着某个其他方法的任务已经于此操作执行期间修改了这个对象，一致则更新记录，否则就认为此数据已被更新过，认为数据已过期，不予更新，此时我们的数据为未锁定状态。</p><p><strong>CAS 机制概要：</strong></p><p>此机制有三个主要操作数：内存值 V 、旧期望值 A 、修改值 B<br>首先拿旧期望值 A 和 内存值 V 比较，如果相同，则使内存值 V 更新为修改值 B。如果不同则证明内存值 V 在并发情况下已被其他线程修改，则不做任何修改。</p><p>我们来看一下原子包下常用的 AtomicInteger 类的 getAndIncrement() 自增操作，探究一下 CAS</p><p><strong>Jdk 源码实现部分</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一：调用 getAndIncrement() 查看源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// U 是 Unsafe 类的引用，Unsafe 类用于执行低级、不安全操作的方法的集合 </span></span><br><span class="line">  <span class="comment">//Unsafe 类绝大部分方法都是 native 修饰的，这种方法实现于 openJdk 的 hotspot/share/vm/prims/unsafe.cpp</span></span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>， VALUE， <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* getAndAddInt()：</span></span><br><span class="line"><span class="comment">      传入参数</span></span><br><span class="line"><span class="comment">      this：当前方法调用对象</span></span><br><span class="line"><span class="comment">      VALUE：由 U.objectFieldOffset() 返回的对象字段偏移量</span></span><br><span class="line"><span class="comment">      1：传入的 delta 增量为 1 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二：getAndAddInt()  @HotSpotIntrinsicCandidate 注解 表明此方法在 HotSpot（JVM） 中有一套高效的实现，此实现基于 CPU 指令</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o， <span class="keyword">long</span> offset， <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 无论怎样先获取当前变量的最新值，getIntVolatile 是本地方法，jdk不开源，要 openjdk 才能查看</span></span><br><span class="line">        v = getIntVolatile(o， offset);</span><br><span class="line">      <span class="comment">//进入 比较交换阶段</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o， offset， v， v + delta));</span><br><span class="line">       <span class="comment">/* weakCompareAndSetInt()：</span></span><br><span class="line"><span class="comment">        传入参数</span></span><br><span class="line"><span class="comment">        o：当前方法调用对象</span></span><br><span class="line"><span class="comment">        offset：字段偏移量</span></span><br><span class="line"><span class="comment">        v：当前变量的最新值</span></span><br><span class="line"><span class="comment">        v + delta：最新值 + 1 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三：weakCompareAndSetInt() 源码，将操作转移给本地方法 compareAndSetInt()</span></span><br><span class="line"> <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o， <span class="keyword">long</span> offset，</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected，</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o， offset， expected， x);</span><br><span class="line">      <span class="comment">/* compareAndSetInt()：</span></span><br><span class="line"><span class="comment">        传入参数</span></span><br><span class="line"><span class="comment">        o：当前方法调用对象</span></span><br><span class="line"><span class="comment">        offset：字段偏移量</span></span><br><span class="line"><span class="comment">        expected：期望值</span></span><br><span class="line"><span class="comment">        x：想要修改的值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//四：compareAndSetInt() 源码，又是本地方法！跟踪不了了...转 openjdk</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates Java variable to &#123;<span class="doctag">@code</span> x&#125; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &#123;<span class="doctag">@code</span> expected&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//注释大意：如果当前变量值与期望值 expected 相等，则将其原子更新为 x</span></span><br><span class="line"> <span class="comment">// 怎么实现原子更新的呢？通过查看 OpenJdk 部分了解</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o， <span class="keyword">long</span> offset，</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected，</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><em>以下 OpenJdk 部分参考文章</em>：<a href="https://www.cnblogs.com/jiuya/p/10368129.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiuya/p/10368129.html</a></p><p><strong>compareAndSetInt() 的 OpenJdk 实现部分</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一：来到 unsafe类的底层实现中</span></span><br><span class="line">UNSAFE_ENTRY（jboolean，Unsafe_CompareAndSetInt（JNIEnv * env，jobject unsafe，jobject obj，jlong​​ offset，jint e，jint x））&#123;</span><br><span class="line">  oop p = JNIHandles :: resolve（obj）;</span><br><span class="line">  jint * addr =（jint *）index_oop_from_field_offset_long（p，offset）;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>（jint）（Atomic :: cmpxchg（x，addr，e））== e;</span><br><span class="line">&#125; UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">//二：跟踪到 Atomic :: cmpxchg 方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp， 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint exchange_value， <span class="keyword">volatile</span> jint* dest， jint compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx， dest</span><br><span class="line">    mov ecx， exchange_value</span><br><span class="line">    mov eax， compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx]， ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面源代码所示，CAS 底层用嵌入的汇编实现的， CPU指令是 cmpxchg，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。如果程序是在多处理器上运行，就为 cmpxchg 指令加上 lock 前缀( lock cmpxchg )。反之，如果程序是在单处理器上运行，就省略 lock 前缀(单处理器自身会维护单处理器内的顺序一致性，不需要 lock 前缀提供的内存屏障效果)。 lock 前缀的作用说明：1、禁止该指令与之前和之后的读和写指令重排序，2、把写缓冲区中的所有数据刷新到内存中。</p><p>总的来说，Atomic 实现了高效无锁(底层还是用到互斥锁，不过底层处理比 Java 层处理要快很多)与线程安全( volatile 变量特性)，CAS 一般适用于计数；多线程编程也适用，多个线程执行 AtomicXXX 类下面的方法，当某个线程执行的时候具有排他性，在执行方法中不会被打断，直至当前线程完成才会执行其他的线程。</p><p>CAS 的缺点 (乐观锁缺点)</p><ul><li>ABA问题：内存对象从 A 变成 B 在变成 A ，CAS 会当成没有变化，进而去更新值，实际是有变化的。（解决办法使用 JUC 下的AtomicStampedReference 提供的版本机制 ）</li><li>多个线程同时自旋情况下开销大、一直和预期值不对的情况下，会一直循环。</li><li>只能保证单个共享变量的原子操作。</li></ul><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><hr><h3 id="线程安全性委托"><a href="#线程安全性委托" class="headerlink" title="线程安全性委托"></a>线程安全性委托</h3><p>Delegated</p><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>为什么要使用线程池?</p><ul><li>降低频繁创建线程而产生的一系列消耗，从而提高对资源的利用率</li><li>线程池可以提高线程的可管理性，方便资源分配和性能调优</li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>jdk1.5 以后可以使用 java.util.concurrent 下的 Interface Executor 执行器管理线程对象<br>常见实现类： ThreadPoolExecutor ， ScheduledThreadPoolExecutor ，都支持 Runnable 和 Callable 接口的实现</p><p>结构体系：<br><img data-src="https://s2.ax1x.com/2020/01/13/l7lXZD.png" alt="Executor的执行相关接口"></p><p>简单使用步骤：</p><ul><li>创建线程池，指定容量：使用并发包内的 Executors 线程工厂类调用<code>静态工厂方法 newFixedThreadPool(int nThreads)</code> ，生成指定容量的线程池</li><li>创建任务并提交至线程池：两种方法，实现 Runnable 或者实现 Callable 接口，重写 run() / call()，通过线程池对象调用 submit() 传入接口实现类对象，提交任务</li><li>销毁线程池（）：shutdown()<br>弊端：容易造成 OOM</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 接口以及 Future 接口的实现类 FutureTask 类都可以用于获取异步执行的结果</p><p>当我们把 Runnable接口 或 Callable 接口 的实现类提交到线程池中时(submit())会返回一个 Future 对象，此对象就是异步执行的结果集</p><p>Future<v>中定义的方法</v></p><ul><li>get()：获取结果（可能会等待）</li><li>get(long timeout， TimeUnit unit)：获取结果，但只等待指定的时间</li><li>cancel(boolean mayInterruptIfRunning)：取消当前任务</li><li>isDone()：判断任务是否已完成</li></ul><p>Future 的增强：CompletableFuture 类</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><em>摘取自:</em> <a href="https://snailclimb.gitee.io/javaguide/#/?id=java" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/?id=java</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>什么是线程和进程?</li></ul><p>进程：系统资源分配最小基本单位，一个程序可以拥有多个进程，windows 下一般为 .exe 文件<br>线程：系统资源调度最小基本单位，当我们创建启动 java 文件时，就会有多条线程运行，其中最主要的就是主线程</p><ul><li>请简要描述线程与进程的关系，区别及优缺点？</li></ul><p>进程内可以拥有多条线程，进程包含线程</p><p>进程：具有独立的地址空间，但是开销大<br>线程：更具有健壮性，调度成本低，但是容易造成线程死锁</p><ul><li><p>说说并发与并行的区别?<br>并行：多个事件在同一个时间点发生<br>并发：多个事件在同一个时间段内发生</p></li><li><p>为什么要使用多线程呢?</p><ul><li>更好的利用 cpu 资源</li><li>并发编程基础</li></ul></li><li><p>使用多线程可能带来什么问题?</p><ul><li>内存泄漏</li><li>死锁</li></ul></li><li><p>说说线程的生命周期和状态?</p><ul><li>新建状态</li><li>运行状态</li><li>无限等待状态</li><li>计时等待状态</li><li>阻塞状态</li><li>终止状态</li></ul></li><li><p>什么是上下文切换?<br>资源任务的从保存再到加载的过程就是一次上下文切换</p></li><li><p>什么是线程死锁?如何避免死锁?</p></li></ul><p>当拥有线程1 持有 A 锁的情况下，试图获取 B 锁，而在同时线程2 已持有 B 锁，正试图获取 A 锁，此时两个线程都不释放自己的锁，造成了永久堵塞，形成死锁<br>在访问对方资源时释放自己的锁，避免出现环形资源请求的情况</p><ul><li><p>说说 sleep() 方法和 wait() 方法区别和共同点?<br>区别: 前者会自动恢复，执行后不会释放对象锁，而后者不会自动恢复，必须被唤醒，但会释放对象锁。<br>共同点：两个方法都会主动放弃 cup 的使用权。</p></li><li><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<br>start() 会将调用线程添加至线程工作组，并通知 JVM 即将启动，当获取到 cpu 时将会使线程进入运行状态，自动执行 run()方法，而直接执行 run() 方法将会在 mian 线程中执行，就像是执行普通方法一样，并不是新建的线程中执行。</p></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>synchronized 关键字:<br>① 说一说自己对于 synchronized 关键字的了解；</p><p>synchronized 是一种重量级锁，用它可以修饰代码块和方法，被修饰的代码块叫同步代码块，进入代码块时，需要获取指定对象实例的锁；被修饰的方法称为同步方法，进入方法时，需要获取当前对象实例的锁；当修饰静态方法时，进入静态方法时，需要获取当前类对象的锁。总而言之，被同步的资源在同一时刻只能被一个线程访问，体现了资源的互斥性。</p><p>② 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;</p><p>在使用多线程编程时，通常需要对一部分资源实现同步操作时，可以使用 synchronized 对需要同步的代码块/方法修饰，并加上相同锁对象，实现对此资源的互斥访问<br>主要分为三种用法：</p><ul><li>修饰代码块：进入此代码块时，需要获取指定对象锁</li><li>修饰成员方法：进入此方法时，需要获取当前对象实例锁</li><li>修饰静态成员方法：进入此方法时，需要获取当前类对象锁<ul><li>当线程 A 访问对象实例的非静态 synchronized 方法时，线程 B 正在访问同个对象实例所属类的静态 synchronized 方法，此时是允许的，并不会产生互斥动作，因为线程 A 占用的是对象实例锁，而线程 B 占用的是对象实例所属类对象的锁</li></ul></li></ul><p><strong>synchronized 关键字的底层原理</strong></p><p><code>synchronized</code>底层原理涉及到了 JVM 层面，当<code>synchronized</code>修饰代码块时，会在编译成字节码文件时，在代码块开始处插入<code>monitorenter</code>（监视器进入）结束处插入<code>monitorexit</code>（监视器退出）两个字节码指令，当修饰方法时，会在生成方法处使用<code>ACC_SYNCHRONIZED</code>来标识此方法是同步方法，从而在执行时相关的同步调用。</p><p>④ 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗；</p><p>⑤ 谈谈 synchronized 和 ReentrantLock 的区别。</p><p>volatile 关键字：<br>① 讲一下 Java 内存模型；<br>② 说说 synchronized 关键字和 volatile 关键字的区别。</p><p>ThreadLocal：<br>① 简介；<br>② 原理；<br>③ 内存泄露问题。</p><p>线程池：<br>① 为什么要用线程池？；<br>② 实现 Runnable 接口和 Callable 接口的区别；<br>③ 执行 execute() 方法和 submit() 方法的区别是什么呢？；<br>④ 如何创建线程池。</p><p>Atomic 原子类:<br>① 介绍一下 Atomic 原子类；<br>② JUC 包中的原子类是哪 4 类?；<br>③ 讲讲 AtomicInteger 的使用；<br>④ 能不能给我简单介绍一下 AtomicInteger 类的原理。</p><p>java 线程之间的通信由内存模型JMM（Java Memory Model）控制。<br>（1）JMM决定一个线程对变量的写入何时对另一个线程可见。<br>（2）线程之间共享变量存储在主内存中<br>（3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。<br>（4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE03-泛型和异常</title>
    <url>/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE03-%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是一种未知的数据类型，只支持引用数据类型</p><p><strong>原始类型</strong> 就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型。无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。</p><ul><li>定义在类上的泛型，使用类的时候会确定泛型的类型</li><li>定义在方法上的泛型，会在使用方法的时候确定泛型<br>在调用泛型方法时，可以指定泛型，也可以不指定泛型。<ul><li>在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object<br>在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类</li><li>定义在接口上的泛型，需要使用接口的时候确定泛型</li></ul></li></ul><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>泛型通配符:不知道使用什么类型来接收的时候，此时可以使用?，?表示未知通配符。一旦使用泛型的通配符后，只能使用Object类中的继承方法，集合中元素自身方法无法使用</p><h3 id="泛型受限"><a href="#泛型受限" class="headerlink" title="泛型受限"></a>泛型受限</h3><p>泛型的上限：</p><ul><li><p>格式： 类型名称 &lt;? extends 类 &gt; 对象名称</p></li><li><p>意义： 只能接收该类型及其子类，上限为此父类</p><p>泛型的下限：</p></li><li><p>格式： 类型名称 &lt;? super 类 &gt; 对象名称</p></li><li><p>意义： 只能接收该类型及其父类型，下限为此子类</p></li></ul><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>Java中的泛型是伪泛型，基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，通过编译器编译的时候去掉泛型，然后尽量查找出掉擦除后的错误。</p><h2 id="异常-Exception"><a href="#异常-Exception" class="headerlink" title="异常 Exception"></a>异常 Exception</h2><p>其中 RuntimeException 和 Error 的其子类都是属于 uncheckexception（空指针/类型转换/数组越界/数学异常）</p><p>Exception类中除了 RuntimeException之外的异常（IO/SQL异常） 都是属于 checked-exception</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE02-容器</title>
    <url>/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE02-%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><strong>容器</strong>基本的类型是 Lst、Set、 Queue 和 Map，这些基本对象类型也称为集合类,Java 类库中使用了 <code>Collection</code> 这个名字来指代该类库中的一个特殊子集（Lst、Set、 Queue）, Collection+Map</p><p><img data-src="https://s2.ax1x.com/2020/01/13/l7lV81.png" alt="整理的含抽象类和遗留构件的容器图"></p><p><img data-src="https://s2.ax1x.com/2020/02/03/1U9UtH.png" alt="不含抽象类和遗留构件的容器图-Thinking In java"></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h4><p>数组和集合两者区别：</p><ul><li>数组一旦实例化，其长度 <code>length</code> 是固定的，而集合的长度 <code>size</code> 是可变的</li><li>数组可以存储所有引用类型和基本类型，集合中只能存储引用数据类型</li><li>数组中存储的元素类型是一致的，集合可以不一致（不指定泛型时）</li></ul><h5 id="集合通用实现"><a href="#集合通用实现" class="headerlink" title="集合通用实现"></a>集合通用实现</h5><table><thead><tr><th>接口</th><th>哈希表</th><th>可变长数组</th><th>平衡树</th><th>链表</th><th>哈希表+链表</th></tr></thead><tbody><tr><td>Set</td><td>HashSet</td><td>-</td><td>TreeSet</td><td>-</td><td>LinkedHashSet</td></tr><tr><td>List</td><td>-</td><td>ArrayList</td><td>-</td><td>LinkedList</td><td>-</td></tr><tr><td>Deque</td><td>-</td><td>ArrayDeque</td><td>-</td><td>LinkedList</td><td>-</td></tr><tr><td>Map</td><td>HashMap</td><td>-</td><td>TreeMap</td><td>-</td><td>LinkedHashMap</td></tr></tbody></table><p>所有的新实现都含有实现了 fail-fast (快速失败) 的迭代器，它检测无效的并发修改，并且快速而干净地报出失败</p><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection 是所有单列集合（List、Set、Queue）的父接口</p><p>所有的继承(实现)类/接口都拥有这些方法（未完全列出）</p><ul><li>public boolean add(E e)：将指定元素添加至当前集合</li><li>public void clear()：清空集合所有元素</li><li>public boolean remove(E e): 从当前集合移除指定元素</li><li>public boolean contains(Object obj): 判断当前集合中是否包含指定对象</li><li>public boolean isEmpty(): 判断当前集合是否为空</li><li>public int size(): 返回集合长度</li><li>public Object[] toArray(): 把集合中的元素，存储到数组</li></ul><h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><p>Collection 接口继承了 Iterable 接口 ，接口中抽象方法 <code>Iterator&lt;E&gt; iterator();</code> 要求所有 Collection 的实现类实现此方法，通过集合实例.iterator() 获取迭代器，遍历集合内元素</p><ul><li>public E next()：获取迭代的下一个元素。</li><li>public boolean hasNext()：如果仍有元素可以迭代，则返回 true。</li><li>public void remove()：移除此次迭代的元素（ ForEach 中要删除集合内元素只能用迭代器的这个方法）</li></ul><p><strong>特性</strong></p><p>1.迭代器只能使用一次，当元素被迭代遍历一次后，再次使用 <code>next()</code> 获取元素时将会抛出 <code>NoSuchElementException</code> （无下文异常），有点类似数组下标访问越界</p><p>2.（ *fail-fast 机制 ）在对 java.util 包下的 <code>Collection</code>集合进行遍历时，不能使用集合通用的 add()、remove()、clear() 等方法进行增删，若要删除必须使用迭代器的 remove() ，否则将会抛出 <code>ConcurrentModificationException</code>(并发修改异常)，引发多线程时的数据不安全问题（此时建议用并发构建块 java.util.concurrent ），java.util.concurrent 包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">iteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"A"</span>);</span><br><span class="line">        coll.add(<span class="string">"B"</span>);</span><br><span class="line">        coll.add(<span class="string">"C"</span>);</span><br><span class="line">        println(<span class="string">"迭代前："</span> + coll);</span><br><span class="line">        Iterator&lt;String&gt; iter = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            String next = iter.next();</span><br><span class="line">            println(next);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"c"</span>.equalsIgnoreCase(next)) &#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"迭代后："</span> + coll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output</span></span><br><span class="line"><span class="comment">迭代前：[A， B， C]</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">迭代后：[A， B]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3.java.util 包下的所有 <code>Collection</code> 集合都继承了 <code>Iterable</code> 接口的 fail-fast （快速失败）属性。 java.util.concurrent 包下面的所有的类都是 fail-safe （安全失败）的，遍历拷贝，不报异常。</p><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>增强型 for 循环，用于遍历数组、集合，底层实现为迭代器,格式：for( 元素数据类型 变量名 : 数组名\集合名 ){ … }</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>java.util.List 接口继承自 Collection 接口，将实现了 <code>List</code> 接口的类统称为 List 集合。<br>主要的三个实现类：1. ArrayList 2. LinkedList 3. Vector（不常用）</p><p>常用方法</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* public void add(int index， E element)：将指定的元素，添加到该集合中的指定位置</span><br><span class="line">* public E remove(int index)：移除列表中指定位置的元素， 返回移除的元素</span><br><span class="line">* public E set(int index， E element):用指定元素替换集合中指定位置的元素，返回替换前的元素</span><br><span class="line">* public E get(int index)：获取集合中指定位置的元素</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List list1 = <span class="keyword">null</span>;              <span class="comment">// 创建的是 null 集合</span></span><br><span class="line">      <span class="comment">// list1.add("1");                 // 执行时将抛出 NullPointerException</span></span><br><span class="line">      List list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 创建一个空集合(size() = 0)</span></span><br><span class="line">      println(list1);</span><br><span class="line">      println(list2);</span><br><span class="line">      <span class="comment">/** Output:</span></span><br><span class="line"><span class="comment">       * null</span></span><br><span class="line"><span class="comment">       * []</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>特点：有索引，查询块，增删慢</strong><br>底层为 Object[] ，初始容量为 10，超过则按 1.5 倍增长</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>特点：无索引，查询慢，增删快</strong><br>底层为双向链表( JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p><h5 id="Vector（不常用，被淘汰）"><a href="#Vector（不常用，被淘汰）" class="headerlink" title="Vector（不常用，被淘汰）"></a>Vector（不常用，被淘汰）</h5><p><strong>特点：方法同步的( Synchronized )，线程安全的</strong><br>底层为 Object[]，初始容量为 10，超过则翻倍增长 (由于同步会影响其性能)</p><h5 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h5><p>java.util.RandomAccess 随机访问标志接口 ，内部无任何方法（标志接口）<br>ArrayList 实现了此接口，表明 ArrayList 具有快速随机访问功能</p><div class="note primary"><p>实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach，<br>未实现 RandomAccess 接口的list，优先选择 iterator 遍历（foreach 遍历底层也是通过 iterator 实现的）</p></div><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>java.util.Set 接口继承自Collection接口，将实现了 <code>Set</code> 接口的类统称为 Set 集合。主要的三个实现类： 1. HashSet 2. TreeSet 3. LinkedHashSet</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p><strong>特点：无索引，元素唯一，存取无序</strong></p><p>允许空键 null ，基于 <code>HashMap</code> 实现，底层通过 <code>HashMap</code> 来保存元素来修改集合元素，除了 clone()、writeObject()、readObject() 是 <code>HashSet</code>自己实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><p><strong>通过重写存储对象中的 hashCode 和 equals 方法保证元素唯一性</strong></p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p><strong>特点：无索引，元素唯一，存取有序</strong><br>继承自 <code>HashSet</code>，由链表结构保证元素存取有序</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>特点：无索引，元素唯一，存取有序</strong><br>红黑树(自平衡的排序二叉树)</p><p><strong>自然排序：</strong> TreeSet() 将默认调用升序排序<br><strong>比较器排序：</strong> TreeSet(Comparator&lt;? super E&gt; comparator)</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>Map 在《Thinking in Java》一书中被称之为 <code>映射表</code>，基本思想是维护键-值（对）<br><strong>Map 不是 Collection 的子接口，不具有迭代器和 Collection 的通用方法</strong></p><p>java.util 包下的 Map 接口，用来保存具有映射关系的数据： key 和 value，称为键值对。Map 中键必须唯一，值可以重复，它们都可以使任何引用类型的数据 。通过指定的 key 可以取出对应的 value 。HashMap 支持 null 键，TreeMap 不支持。</p><p>Map接口定义了如下常用的方法：</p><ul><li><p>public V put(K key， V value): 添加键值对到 Map。返回被替换的值</p></li><li><p>public V get(Object key)：根据指定的键，获取对应值</p></li><li><p>public int size()：返回键值对数量</p></li><li><p>public V remove(Object key): 把指定的键所对应的键值对元素，在Map集合中删除，返回被删除元素的值</p></li><li><p>public Set<k>keySet(): 获取Map集合中所有的键，存储到 <code>Set</code></k></p></li><li><p>public Collection<v>values​()：获取Map集合中所有的值，存储到 <code>Collection</code></v></p></li><li><p>public Set&lt;Map.Entry&lt;K，V&gt;&gt; entrySet(): 获取到Map集合中所有的 键值对对象 的集合(Set集合) ，遍历效率比 keySet 高<br>Map集合中的元素是键值对，键值对是2个对象<br>键值对对象是一个对象<br>键值对对象: 其实就是把键值对 包装成对象 这个对象就叫做键值对对象<br>键值对对象类型: Entry类型</p></li><li><p>public boolean containKey(Object key):判断该集合中是否有此键</p></li><li><p>public boolean containValue(Object value):判断该集合中是否有此值</p></li><li><p>public void clear()：清空 Map</p></li></ul><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>HashMap 是 Map基于哈希表的 Map接口实现，其底层就是一个数组结构，数组中的每一项又是一个链表，插入和查询的开销是固定的，可以通过构造器设置容量和负载因子，以调整 HashMap性能，允许空键 null（有且只有一个） 和空值 null。两个重要参数：初始容量(创建哈希表时的容量)和负载因子(哈希表的容量自动增加之前，允许哈希表获得的满容量的度量)，当哈希表中的条目数目超过了负载因子和当前容量的乘积时，哈希表被重置（即，内部数据结构被重建），使得哈希表的桶数大约是桶数的两倍。 一般来说，默认加载因子（0.75）在时间和空间成本之间提供了一个很好的折衷。</p><p><strong>特点：查询快，元素唯一，存取无序</strong></p><p>JDK7 及之前为数组+链表<br><strong>JDK8 及之后引入红黑树，当链表超过设定设定阈值 8 时，将链表转为红黑树（转之前先检查数组容量是否到达设定阈值 64 ，没有到达则扩容数组，否则转红黑树）</strong>：也就是当 Hash 冲突时会形成 Node 链表，在链表长度超过 8 ，Node 数组超过 64 时会将链表结构转换为红黑树</p><p>为啥要大于8才转，为啥不直接用红黑树？？？</p><p>HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，如果这个时候就没有必要转为树。</p><p>还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p>官方文档：</p><blockquote><p>Replaces all linked nodes in bin at index for given hash unless table is too small， in which case resizes instead.</p></blockquote><p>红黑树：自平衡排序二叉树（防止二叉树退化成线性结构）</p><ul><li>节点是红色或黑色</li><li>根节点必须是黑色</li><li>每个红色节点的两个子节点都是黑色</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ul><div class="note danger"><p>用自定义类作为 HashMap 的 key 时，必须重写 equals()和 hashCode()方法</p></div><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p><strong>特点：查询快，元素唯一，存取有序</strong><br>继承自 HashMap ，由双向链表维护元素的存取有序</p><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p><strong>特点：可排序，查询快，元素唯一，存取有序</strong><br>红黑树(自平衡的排序二叉树)</p><p><strong>自然排序(升序)：</strong> TreeMap()<br><strong>比较器排序(实现 Comparator 接口)：</strong> TreeMap(Comparator&lt;? super K&gt; comparator)</p><h5 id="Hashtable-不常用，淘汰"><a href="#Hashtable-不常用，淘汰" class="headerlink" title="Hashtable (不常用，淘汰)"></a>Hashtable (不常用，淘汰)</h5><p><strong>特点：方法同步的( Synchronized )，线程安全的</strong><br>数组+链表组成</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="comparable-与-comparator-区别"><a href="#comparable-与-comparator-区别" class="headerlink" title="comparable 与 comparator 区别"></a>comparable 与 comparator 区别</h4><p>comparable 与 comparator 区别</p><ul><li>java.lang Interface Comparable<t>内部方法只有一个 int compareTo(T o) ， 当对自定义对象（非系统类实例）进行排序时，需重写。</t></li><li>java.util.interface Comparator<t>使用时必须重写 int compare(T o1， T o2) 方法;<ul><li>当o2 - o1，降序</li><li>当o1 - o2，升序</li></ul></t></li></ul><h4 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals()"></a>== 与 equals()</h4><ul><li>==: 基本类型比较<strong>值</strong>，引用类型比较<strong>地址</strong>。</li><li>equals():<ul><li>类未重写 equals()，则等价于通过 “==” 比较这两个对象。</li><li>类已重写 equals()，则按照比较规则来比较两个对象。（一般重写规则为<code>比较内容</code>）</li><li>通常需要一起重写 hashCode()</li></ul></li></ul><h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h4><ul><li><p>哈希表（散列表）：在 Java 中，哈希表用的是链表+数组实现的，每个链表称之为桶。通过给定的关键字的值直接访问到具体对应的值的一个数据结构，哈希表存储的是键值对(key-value)。</p></li><li><p>hashCode()：返回一个 int 整数（哈希码），用于确定对象在哈希表中的存储地址。hashCode() 的值只有在哈希表内才有用</p></li><li><p>hashCode（）与 equals（）的相关规定</p><ul><li>根据 equals(Object) 方法两个对象为<code>true</code>，两个对象的hashCode值必须相同</li><li>两个对象的 hashCode 值可以相同，且 equals(Object) 方法两个对象可以为<code>false</code></li><li>equals() 如果被重写过，则 hashCode() 也必须被重写</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul></li></ul><h4 id="Set（Key-和-Value-相同）如何保证元素不重复"><a href="#Set（Key-和-Value-相同）如何保证元素不重复" class="headerlink" title="Set（Key 和 Value 相同）如何保证元素不重复"></a>Set（Key 和 Value 相同）如何保证元素不重复</h4><ul><li>当 Set 集合存储元素时，通过 hashCode() 计算其元素的 hash 值</li><li>根据 hash 值查询哈希表内是否有相等的 hash 值</li><li>若没有，则添加此键值对</li><li>若有，则产生哈希冲突，在此元素位置创建一个链表</li><li>再调用 equals() 进行内容比较，判断该位置元素的 Key 是否于 要存入的元素 Key 相同</li><li>结果为 ture，不存储（两个对象 Key 相同，且哈希值相等）</li><li>结果为 false，将此键值对添加至链表尾（两个对象 Key 不同，但哈希值相等）</li></ul><h4 id="Map（Key-和-Value-不同）如何保证元素不重复"><a href="#Map（Key-和-Value-不同）如何保证元素不重复" class="headerlink" title="Map（Key 和 Value 不同）如何保证元素不重复"></a>Map（Key 和 Value 不同）如何保证元素不重复</h4><ul><li>Map 存储元素时，先通过 hashCode()计算 key对应哈希值 h</li><li>不存在: 若没有此 h对应的 key，则添加此元素到哈希表</li><li>存在: 如果 h对应的 key有一个，则直接覆盖，若有多个则调用 equals()进行内容比较，找到为 true的key，进行覆盖</li></ul><p>使用数组存放哈希值<br>使用链表存放产生冲突的哈希值<br>当链表超过设定设定阈值 8 时，将链表转为红黑树</p><h4 id="处理哈希冲突（哈希碰撞）"><a href="#处理哈希冲突（哈希碰撞）" class="headerlink" title="处理哈希冲突（哈希碰撞）"></a>处理哈希冲突（哈希碰撞）</h4><p>常见处理哈希冲突方法有：开放地址法、再哈希法、链地址法</p><p>HashMap采用的是链地址法（拉链法）：散列到同一位置的元素，不是继续往下探测，而是在这个位置添加一个链表，这些元素则都放到这一个链表上。<br><strong>JDK8 后当链表超过设定设定阈值 8 时，将链表转为红黑树（自平衡防止二叉树退化），优化搜索时间。</strong></p><p>官方文档：</p><blockquote><p>The bin count threshold for using a tree rather than list for a bin. Bins are converted to trees when adding an element to a bin with at least this many nodes. The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage.</p></blockquote><h4 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h4><p>如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。那么我们可以创建时指定容量，JDK会默认帮我们计算一个相对合理的值当做初始容量。所谓合理值，其实是找到第一个比用户传入的值大的2的幂。比如你<code>new HashMap(7)</code>，jdk会帮我们创建容量为8的Map,在元素个数达到 8*0.75 = 6的时候就会进行一次扩容。</p><p>扩容必须满足两个条件</p><p><strong>存放新值的时候当前已有元素必须大于阈值</strong><br><strong>存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值计算出的数组索引位置已经存在同哈希值）</strong></p><p>HashMap在添加值的时候，它默认能存储16个键值对，直到你使用这个HashMap时，它才会给HashMap分配16个键值对的存储空间，（负载因子为0.75,阈值为12），当16个键值对已经存储满了，我们在添加第17个键值对的时候才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。<br>HashMap也有可能存储更多的键值对，最多可以存储26个键值对，我们来算一下：存储的前11个值全部发生hash碰撞，存到数组的同一个位置中，（这时元素个数小于阈值12，不会扩容），之后存入15个值全部分散到数组剩下的15个位置中，（这时元素个数大于等于阈值，但是每次存入元素并没有发生hash碰撞，不会扩容），11+15=26，当我们存入第27个值得时候满足以上两个条件，HashMap才会发生扩容.</p><h3 id="Collections-Arrays-工具类"><a href="#Collections-Arrays-工具类" class="headerlink" title="Collections/Arrays 工具类"></a>Collections/Arrays 工具类</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>public static<t>boolean addAll(Collection&lt;? super T&gt; c， T… elements) 将所有指定元素添加到指定 Collection 中。</t></li><li>public static void shuffle(List&lt;?&gt; list)：打乱集合顺序。</li><li>public static<t>void sort(List<t>list)：将集合中元素按照默认规则排序。<br>默认规则:要求集合中元素所属的类必须实现Comparable接口，重写compareTo方法，在该放中定义排序规则</t></t></li><li>public static<t>void sort(List<t>list，Comparator<t>omparator):将集合中元素按照指定规则排序。</t></t></t></li></ul><h4 id="数组转为-List-的三种方式"><a href="#数组转为-List-的三种方式" class="headerlink" title="数组转为 List 的三种方式"></a>数组转为 List 的三种方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//方式一：有内部类适配器模式创建，不能进行集合修改 （有很大缺陷） </span></span><br><span class="line"><span class="comment">//注意：1.传入数组必须为引用类型数组 2.此方法创建的 List 不能使用 add()\remove()等修改集合的方法</span></span><br><span class="line">List list1 = Arrays.asList(<span class="string">"aaa"</span>， <span class="string">"aa"</span>， <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//方式二：最简便的方式（推荐）</span></span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"sss"</span>， <span class="string">"ss"</span>， <span class="string">"s"</span>));</span><br><span class="line"><span class="comment">//方式三：使用 java8 的 Stream </span></span><br><span class="line"></span><br><span class="line">String[] arr = &#123;<span class="string">"ddd"</span>， <span class="string">"dd"</span>， <span class="string">"d"</span>&#125;;</span><br><span class="line">List list3 = Stream.of(arr).collect(Collectors.toList());       <span class="comment">// Stream.of(arr) 得到数组流</span></span><br><span class="line"><span class="comment">//List list4 = Arrays.stream(arr).collect(Collectors.toList()); // Arrays.stream(arr) 得到数组流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list4 = Arrays.stream(arr1).boxed().collect(Collectors.toList()); <span class="comment">// IntStream 流的自动装箱 boxed()        </span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"list1:%s\n"</span>， list1);</span><br><span class="line">printf(<span class="string">"list2:%s\n"</span>， list2);</span><br><span class="line">printf(<span class="string">"list3:%s\n"</span>， list3);</span><br><span class="line">printf(<span class="string">"list4:%s\n"</span>， list4);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">    list1:[aaa， aa， a]</span></span><br><span class="line"><span class="comment">    list2:[sss， ss， s]</span></span><br><span class="line"><span class="comment">    list3:[ddd， dd， d]</span></span><br><span class="line"><span class="comment">    list4:[1，2，3]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="List-转为数组-toArray-，-利用-Collections-reverse-反转集合"><a href="#List-转为数组-toArray-，-利用-Collections-reverse-反转集合" class="headerlink" title="List 转为数组 toArray() ， 利用 Collections.reverse() 反转集合"></a>List 转为数组 toArray() ， 利用 Collections.reverse() 反转集合</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse()</span></span><br><span class="line">printf(<span class="string">"翻转前：%s\n"</span>， list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">printf(<span class="string">"翻转后：%s\n"</span>， list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用集合的 toArray() </span></span><br><span class="line"><span class="comment">//一：实参指定转换的数组类型，new String[0]</span></span><br><span class="line">Integer[] iArr = (Integer[])list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//二</span></span><br><span class="line">Integer[] iArr2 = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">list.toArray(iArr2);</span><br><span class="line"></span><br><span class="line">print(<span class="string">"数组元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iArr.length; i++) &#123;</span><br><span class="line">    printf(<span class="string">"%d\t"</span>， iArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  翻转前：[1， 2， 3， 4]</span></span><br><span class="line"><span class="comment">  翻转后：[4， 3， 2， 1]</span></span><br><span class="line"><span class="comment">  数组元素：4	3	2	1	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>SE01-OO编程思想</title>
    <url>/sr/post/2019-11-26-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-26-SE01-OO%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="OO编程思想"><a href="#OO编程思想" class="headerlink" title="OO编程思想"></a>OO编程思想</h2><div class="note info"><p>万物皆对象。以对象为中心，以消息为驱动。</p></div><p><strong>类（class）</strong> ：类是一个模板，它描述一类对象的行为和属性(状态)，对应程序中的方法和数据。<br><strong>实例化（instance）</strong>：由类转换为（构造）对象的过程<br><strong>对象（object）</strong>：每个对象都是某个类的一个实例，它具有<strong>行为、状态、和标识</strong>三个主要特性<br><strong>实例域（filed）</strong>：对象中的数据<br><strong>方法（method）</strong>：方法签名（方法名、参数类型）、返回值、方法体<br><strong>构造器（constructor）</strong>：随着 <code>new</code> 关键字的出现而调用，用于初始化成员属性，实例化一个类<br><strong>重载（overload）</strong>：发生在同一个类中，编译器检查（重载解析）<br>在只有返回值不同或者访问修饰符不同的情况下无法构成重载</p><div class="note primary"><p>必要条件：<strong>方法名相同，同一个类中</strong></p></div><div class="note default"><p>次要条件：（必须满足其一）</p><ul><li>参数类型不同</li><li>参数个数不同</li><li>参数顺序不同</li></ul></div><p><strong>重写（override）</strong>：发生在子父类中，使用<code>@Override</code>检查<br>父类某个方法访问修饰符为 <code>private</code> ，则子类无法重写此方法</p><div class="note primary"><p>必要条件：<strong>方法名、参数类型和个数相同，发生在子父类中</strong></p></div><div class="note default"><p>次要条件：（可选）</p><ul><li>访问修饰符范围大于等于父类</li><li>返回值类型小于等于父类</li><li>抛出的异常范围小于等于父类</li></ul></div><div class="note info"><p>在 Java1.4 及以前，子类方法如果要<strong>重写</strong>父类中的某个方法，必须具有完全相同的方法签名，包括返回值也必须完全一样。<br>Java 5.0 中新增了协变返回类型，它允许子类中重写父类方法的返回类型为<code>父类的返回类型的某个子类类型</code></p></div><p><strong>封装</strong>：java 中通过控制类成员的访问权限，隐藏其对象的属性和实现细节，仅向外提供 public 的 getXXX() 和 setXXX()，形成<code>&quot;类&quot;</code>的过程<br><strong>继承</strong>：利用继承(is-a)技术，可以基于一个已存在的类来构造一个新类，在其之上进行扩展<br>好处：</p><ul><li>提高<strong>代码的复用性</strong>（减少代码冗余，相同代码重复利用）</li><li>使类与类之间产生了联系</li><li>子类继承父类，就可以直接得到父类的成员变量和方法</li></ul><p>注意：并不是父类的所有内容都可以给子类继承的：<br><strong>子类不能继承父类的构造器，因为子类有自己的构造器</strong><br><strong>子类可以继承父类的 protected 成员并且可以直接访问</strong><br><strong>子类可以继承父类的 private 成员</strong></p><ul><li>private 成员变量：无法直接访问，可以通过 getXXX() / setXXX() 访问父类的 private 成员变量。</li><li>private 成员方法：无法访问、无法调用。（可间接调用）</li></ul><p>判断什么时候使用继承的先决条件：<strong>先看是否需要子类转型为父类</strong>，如果必须向上转型，则继承是必须的，否则可以使用组合代替继承。如果多个类中有相同的属性和行为，并且这多个类向上抽象可以看出是同一类事物，那么就可以使用继承来提高代码的复用性</p><p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障</p><p><strong>组合</strong>：表示两个对象之间是整体和部分的<em>强关联关系</em>，部分与整体的生命周期相同(例如：人与大脑的关系)</p><p>常见实现方式：A类的构造方法里创建B类的对象，也就是说，当A类的一个对象产生时，B类的对象随之产生，当A类的这个对象消亡时，它所包含的B类的对象也随之消亡</p><p><strong>聚合</strong>：表示两个对象之间是整体和部分的<em>弱关联关系</em>，部分的生命周期可以超越整体(例如：计算机与外设的关系)</p><p>常见实现方式：A类的对象在创建时不会立即创建B类的对象，而是等待一个外界的对象传给它，传给它的这个对象不是A类创建的</p><div class="note info"><p>is-a: 这种事物(绵羊)是那种事物(羊)中的一个种类。Java 中体现形式为子父类之间的继承关系</p><p>has-a:这种事物(羊毛)隶属于那种事物(绵羊)，是它的一个部分、部件。Java 中体现形式一个类中包含了其他类的组合（聚合）关系</p></div><p><strong>抽象类</strong>：抽象类体现了程序设计的模板思想，我们将包含一个、零个或多个抽象方法的类称为抽象类。抽象类除了不能被实例化以外，其他功能于普通类一样（<strong>注意：抽象类拥有构造器</strong>）</p><div class="note info"><p>抽象方法：当父类方法被子类重写时，方法体的存在没有意义，可以将方法改为抽象方法。此方法仅有声明没有方法体，以分号结尾。<br>a.任何子类都必须重写所有的父类抽象方法，否则它被声明为抽象类<br>b.抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类<br>c.构造器， static 修饰的方法不能声明为抽象方法</p></div><p><strong>接口</strong>：接口不能被实例化，它是<code>抽象类</code>更具抽象化的产物，接口描述的是某类事物的功能扩展，它是一种数据类型，主要用于明确类中的方法名、参数列表、返回类型</p><p>接口中的任何域都自动是 public static final 修饰的<br></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span>/<span class="keyword">default</span> <span class="class"><span class="keyword">interface</span> 接口名</span>&#123;</span><br><span class="line">  <span class="comment">//常量（jdk7+） 默认用 public static final 修饰 可以省略</span></span><br><span class="line">  <span class="comment">//抽象方法（jdk7+） 默认用 public abstract 修饰 可以省略</span></span><br><span class="line">  <span class="comment">//默认方法（jdk8+） 使用 default 修饰 不可以省略</span></span><br><span class="line">  <span class="comment">//静态方法（jdk8+） 使用 static 修饰 不可以省略  默认权限修饰符为 public 可以省略</span></span><br><span class="line">  <span class="comment">//私有方法（jdk9） 使用 private 修饰 不可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li>单继承：一个类只能直接继承一个父类</li><li>多继承：一个接口可以继承多个接口</li><li>多实现：一个类实现多个接口</li></ul><p>接口、抽象类区别：</p><p>0.接口的实现类不能访问接口的 static 方法，而子类可以访问父类的static 方法</p><p>1.接口的方法默认是 public ，Java 8 之前的接口中不能有默认方法，而抽象类可以有非抽象的方法。</p><p>2.接口中除了 static 、 final 变量，不能有其他变量，而抽象类中则不一定。</p><p>3.一个类可以实现多个接口，但只能继承一个抽象类。接口自己本身可以通过 extends 关键字继承多个接口。</p><p>4.接口方法默认修饰符是 public，抽象方法可以有 public、 protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</p><p>5.从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</p><p>注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p><p><strong>多态</strong>：构成多态三个必要条件：<strong>继承/实现</strong>、<strong>方法重写</strong>、<strong>父类引用指向子类对象</strong></p><p>利：提高代码复用性，降低冗余，提高程序扩展性，降低耦合<br>弊：无法通过父类引用操作子类特有成员</p><p>多态下同名成员访问特点：</p><ul><li>访问成员变量时：访问的是父类的成员变量，不能访问子类特有成员</li><li>访问成员方法时：访问的是子类的成员方法，可以通过 super 关键字</li></ul><p>常见应用场景：</p><ul><li>变量多态：子类对象赋值给父类引用类型</li><li>形参多态：方法的形参类型为父类类型，那么该方法可以接收该父类对象以及该父类的所有子类对象</li><li>返回值多态：方法的返回值类型为父类类型，那么就可以返回该父类对象以及该父类的所有子类对象</li></ul><div class="note info"><p>向上转型：由子类（导出类）转型为父类（基类） <code>较专用</code> —–&gt; <code>较通用</code><br>向下转型：可以解决多态的弊端：无法通过父类引用操作子类特有成员<br><strong>每次向下转型前必须已经是父类类型</strong>，通常搭配 <code>instanceof</code>避免类型转换异常–ClassCastException</p></div><p><strong>静态绑定</strong>：由编译器在编译阶段确定在程序运行时，到底调用的是子类还是父类中的方法的过程<br>静态绑定的方法包括：构造器、 static 方法、final 方法（ private 方法隐式属于 final 方法）、 super 调用的方法(包括父类构造器和父类成员方法)</p><p><strong>动态绑定</strong>：编译器在编译阶段不能确定，只能通过在运行时根据实际类型而不是引用类型来调用相关方法，即取决于我们新创建了什么样的对象，除了上述静态绑定的 4 种情况外，Java 中的由对象调用的方法都采用动态绑定</p><p><strong>内部类</strong>（静态/成员/局部/匿名内部类）：定义在类中方法外的类，比如：A 类的定义放在 B 类的定义内部，A 类就是一个内部类</p><ul><li>内部类中拥有外部类所有元素（包括 private 成员 ）的访问权（不用实例化）</li><li>外部类可以通过在非静态域中实例化内部类，使用内部类对象来访问内部类成员</li><li>当内部类拥有 static 成员时，此内部类必须为 static 类</li><li>在其他类中创建内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名().new 内部类名()；</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 外部类 Out</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> s = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Out</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Out</span><span class="params">(<span class="keyword">int</span> a， <span class="keyword">int</span> b， <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类 In</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">In</span> </span>&#123;</span><br><span class="line">        Out o = <span class="keyword">new</span> Out(<span class="number">10</span>， <span class="number">20</span>， <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printf(<span class="string">"通过内部类访问外部类的 public 成员:%d\n"</span>， o.a = <span class="number">100</span>);</span><br><span class="line">            printf(<span class="string">"通过内部类访问外部类的 protected 成员:%d\n"</span>， o.b = <span class="number">200</span>);</span><br><span class="line">            printf(<span class="string">"通过内部类访问外部类的 private 成员:%d\n"</span>， o.c = <span class="number">300</span>);</span><br><span class="line">            printf(<span class="string">"通过内部类访问外部类的 static 成员:%d\n"</span>， o.s = <span class="number">400</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建内部类对象</span></span><br><span class="line">        Out.In outIn = <span class="keyword">new</span> Out().<span class="keyword">new</span> In();</span><br><span class="line">        printf(<span class="string">"内部类：%s\n"</span>， outIn);</span><br><span class="line">        outIn.test1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** output：</span></span><br><span class="line"><span class="comment">     * 内部类：Out$In@65b3120a</span></span><br><span class="line"><span class="comment">     * 通过内部类访问外部类的 public 成员:100</span></span><br><span class="line"><span class="comment">     * 通过内部类访问外部类的 protected 成员:200</span></span><br><span class="line"><span class="comment">     * 通过内部类访问外部类的 private 成员:300</span></span><br><span class="line"><span class="comment">     * 通过内部类访问外部类的 static 成员:400</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>匿名内部类</strong>：本质是<strong>一个带有具体实现的</strong> 父类(父接口)的 <strong>匿名</strong> 继承(实现)类对象</p><ul><li><code>继承了某个类的匿名子类的匿名对象</code></li><li><code>实现了某接口的匿名实现类的匿名对象</code></li></ul></li><li><p><strong>静态内部类</strong></p></li></ul><p><strong>常见关键字</strong></p><ul><li><p>final 修饰场景：<code>数据、方法、类</code></p><ul><li><p><code>final 数据</code>：该变量的引用不可改变</p><ul><li>常用于修饰基本类型，修饰引用类型时，final 使其引用一旦被初始化，就无法改为引用其他对象，但其对象自身是可以被修改的</li><li>Java 允许 final 以声明的方式修饰参数，意味着不能在方法里修改引用所指向的对象(可以读参数，不可以修改参数)</li></ul></li><li><p><code>final 方法</code>：该方法不可被重写</p><ul><li>用于使方法行为保持不变，禁止覆盖（还有一个作用相当于c中的内联）</li><li>类中的所有 private 方法隐式的指定为 final</li></ul></li><li><p><code>final 类</code>：该类不可被继承</p><ul><li>用于禁止继承该类，此类中所有方法都隐式指定为 final</li></ul></li><li><p>final、finally、finalize</p></li></ul><p>1.final— 修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。<br>2.finally —异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。<br>3.finalize —方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。</p></li><li><p>static 修饰场景：<code>数据/方法、代码块、静态导入、内部类</code></p><ul><li><code>static 数据/方法</code>：static 修饰的数据和方法属于类，不属于类的某个对象，通过类名调用，常用于创建工具方法。调用格式：类名.静态变量名 / 类名.静态方法名()</li><li><code>static 代码块</code>：静态代码块定义在<code>类中方法外</code>， 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)，执行次数只有一次，不随 new 的对象增加而增加，常用于加载配置信息， 或用来一次性地对静态成员变量进行赋值。。</li><li><code>static 静态导入</code>：通过在 import 关键字后加 static，使调用某个类时无需书写类名即可调用该类中的静态资源</li><li><code>static 内部类</code>：<ul><li>成员内部类</li><li>匿名内部类</li></ul></li></ul></li></ul><div class="note danger"><p>static final常量</p><p>1.常量必须声明同时初始化。<br>2.由类名点来访问、不能被改变。<br>3.建议：所有字母都大写。<br>4.编译器在编译时被自动替换为具体的值，效率高。</p></div><ul><li><p>this 用于表示<code>引用类的当前实例本身</code></p><ul><li>this.成员变量：用于区分成员变量与局部变量</li><li>this.成员方法：不常用</li><li>this()：调用该类的其他构造器</li></ul></li><li><p>super 用于表示<code>该类的父类引用</code></p><ul><li>从子类中访问父类的变量和方法</li><li>调用父类构造器（须在子类构造器首行）</li></ul></li></ul><p>注意：</p><ul><li>this、super 都不能在 static 方法内使用</li><li>方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tk1</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">new</span> A(<span class="number">1</span>) &#123;&#125;.method(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      println(<span class="keyword">this</span>.num); <span class="comment">// 1</span></span><br><span class="line">      println(num);      <span class="comment">// 10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>访问权限修饰符</strong></p><ul><li>公有访问修饰符——-<code>public</code>：<strong>所有类可见</strong>，使用对象：类、接口、变量、方法</li><li>受保护访问修饰符—<code>protected</code>：<strong>同一包内的类和所有子类可见</strong>。使用对象：变量、方法</li><li>默认访问修饰符——-<code>default</code>：<strong>同一包内可见</strong>，不使用任何修饰符。使用对象：类、接口、变量、方法</li><li>私有访问修饰符——-<code>private</code>：<strong>同一类内可见</strong>，使用对象：变量、方法</li></ul><p>注意：<br>a. private 和 protected 不能修饰外部类，可以用来修饰内部类<br>b.父类 protected 成员是包内可见的，并且对子类可见<br>c.若子类与父类非同包，那么在子类中，可以通过创建子类实例来访问父类 protected 方法，而不能通过创建父类实例来访问父类的 protected 方法<br>d.类的访问控制只能是 public 和 defult，public 修饰的可以被任何一个类调用，默认访问控制的类只能被同一个包中的类使用</p><p><strong>Java中的深拷贝(深复制)和浅拷贝(浅复制)</strong></p><p>深拷贝(深复制)和浅拷贝(浅复制)是两个比较通用的概念，尤其在C++语言中，若不弄懂，则会在delete的时候出问题，但是我们在这幸好用的是Java。虽然java自动管理对象的回收，但对于深拷贝(深复制)和浅拷贝(浅复制)，我们还是要给予足够的重视，因为有时这两个概念往往会给我们带来不小的困惑。</p><p>浅拷贝是指拷贝对象时仅仅拷贝对象本身（包括对象中的基本变量），而不拷贝对象包含的引用指向的对象。深拷贝不仅拷贝对象本身，而且拷贝对象包含的引用指向的所有对象。举例来说更加清楚：对象A1中包含对B1的引用，B1中包含对C1的引用。浅拷贝A1得到A2，A2 中依然包含对B1的引用，B1中依然包含对C1的引用。深拷贝则是对浅拷贝的递归，深拷贝A1得到A2，A2中包含对B2（B1的copy）的引用，B2 中包含对C2（C1的copy）的引用。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>基础学习</category>
        <category>SE</category>
      </categories>
      <tags>
        <tag>note</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA</title>
    <url>/sr/post/2019-11-26-%E6%9D%82%E9%A1%B9-%E9%A1%B9%E7%9B%AE%E5%B7%A5%E5%85%B7-2019-11-26-IDEA/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>光标放置变量上，ctrl + alt + F 快速声明成员变量</li><li>光标放置变量上，ctrl + shift + U 大小写切换</li></ul><h2 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h2><ul><li><p><code>live template</code> 定义代码模板：配置快捷键在工作界面快速录入代码模板</p></li><li><p><code>File Header</code> 对定义新建类模板：配置模板 IDEA 中在创建类时会自动给添加注释</p></li><li><p><code>Postfix Conpletion</code> 后缀模板：添加小圆点后面的快捷输出至列表，类似于 变量.var 那种操作</p></li><li><p><code>alt + 鼠标左键</code> 开启光标多选：鼠标按住垂直上下拉</p></li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li>rainbow brack 彩虹括号</li><li>Alibaba Java Coding Guidelines 阿里巴巴代码规约</li><li>Translation 翻译</li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo</title>
    <url>/sr/post/2019-11-11-%E6%9D%82%E9%A1%B9-%E5%BB%BA%E7%AB%99-Hexo/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><p>注：安装环境为 win10 x64、git、node ( 默认 git 已提前装好，主站配置文件不能错)</p><h2 id="1-下载安装node"><a href="#1-下载安装node" class="headerlink" title="1.下载安装node"></a>1.下载安装node</h2><ul><li><p>浏览器输入<code>nodejs.cn</code>，跳转官网选择对应win10安装包，64位</p></li><li><p>双击打开安装，可修改安装路径，安装完成后命令行输入检查</p></li></ul><blockquote><p>node -v #查看node版本</p></blockquote><blockquote><p>npm -v #查看包管理器版本</p></blockquote><h2 id="2-安装镜像源"><a href="#2-安装镜像源" class="headerlink" title="2.安装镜像源"></a>2.安装镜像源</h2><blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote><blockquote><p>cnpm #查看已是否全局配置</p></blockquote><h2 id="3-下载hexo"><a href="#3-下载hexo" class="headerlink" title="3.下载hexo"></a>3.下载hexo</h2><blockquote><p>cnpm install -g hexo-cli</p></blockquote><blockquote><p>hexo -v #查看hexo信息</p></blockquote><p>到了这步环境就已经搭好了~，输入 exit 退出命令行</p><h2 id="4-创建本地博客"><a href="#4-创建本地博客" class="headerlink" title="4.创建本地博客"></a>4.创建本地博客</h2><ul><li><p>新建文件夹，此文件夹就是你的 blog 保存路径，进入文件夹，地址栏输入 cmd –&gt; 回车</p></li><li><p>执行下面的语句，初始化blog，执行 git 的 clone 操作，前提是需要将 git 配置到环境变量</p></li></ul><blockquote><p>hexo init</p></blockquote><p>建议连上vpn克隆，或者修改 hosts，初始化失败的话输入 npm install</p><ul><li>预览博客：浏览器地址栏输入 <code>localhost:4000</code></li></ul><blockquote><p>hexo s</p></blockquote><ul><li>新建博客：将在<code>\source\_posts</code>下创建一篇新的blog(随便写点)</li></ul><blockquote><p>hexo n “blogName”</p></blockquote><ul><li>清除缓存并生成静态文件：重新生成blog，刷新一下 <code>localhost:4000</code> 就可以看到啦</li></ul><blockquote><p>hexo clean</p></blockquote><blockquote><p>hexo g</p></blockquote><h2 id="托管至Github"><a href="#托管至Github" class="headerlink" title="托管至Github"></a>托管至Github</h2><ul><li><p>新建一个代码仓库，强制要求名字格式为<br><code>你的登录名.github.io</code></p></li><li><p>安装git部署插件，blog存放路径下打开命令行输入<br><code>cnpm install -save hexo-deployer-git</code></p></li><li><p>修改blog存放路径下的 <code>_config.yml文件</code>，双击打开，到最底部删除最后一个引号，配置以下三个属性，保存即可<br>注意：属性的冒号后面要接空格</p><blockquote><p>type: git<br>repo: 此处将新建的代码仓库中的 https 链接复制过来<br>branch: master</p></blockquote></li><li><p>系统级别签名<br>git config –global user.name “你的目标用户名”<br>git config –global user.email “你的目标邮箱名”</p></li><li><p>命令行输入<code>hexo d</code> 开始推送静态文件，若出现 <em>ERROR 报错： Deployer not found: git</em> ，代表第二步安装部署插件安装失败，再次输入<code>cnpm install --save hexo-deployer-git</code>即可（出现的 <em>WARN</em> 忽略），此步可能需要登录 GitHub ，按提示输入即可</p></li></ul><h2 id="6-克隆主题"><a href="#6-克隆主题" class="headerlink" title="6.克隆主题"></a>6.克隆主题</h2><blockquote><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</p></blockquote><ul><li>修改blog存放路径下的 <code>_config.yml 文件</code>，找到<code>theme</code>属性将值改为 yilia 即可</li></ul><h2 id="7-更新blog推送步骤"><a href="#7-更新blog推送步骤" class="headerlink" title="7.更新blog推送步骤"></a>7.更新blog推送步骤</h2><p>将blog放置于 <code>source\_posts</code>目录下，依次输入</p><blockquote><p>hexo clean<br>hexo g -d</p></blockquote><p>学习hexo更多命令：<a href="https://hexo.io/zh-cn/docs/commands" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/commands</a></p><h2 id="主题配置相关插件"><a href="#主题配置相关插件" class="headerlink" title="主题配置相关插件"></a>主题配置相关插件</h2><h3 id="安装渲染器"><a href="#安装渲染器" class="headerlink" title="安装渲染器"></a>安装渲染器</h3><blockquote><p>cnpm install hexo-renderer-pug hexo-renderer-stylus –save</p></blockquote><h3 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h3><blockquote><p>cnpm install hexo-offline –save</p></blockquote><h3 id="字數統計"><a href="#字數統計" class="headerlink" title="字數統計"></a>字數統計</h3><blockquote><p>npm install hexo-wordcount –save 若安装失败 hexo g 时则会报错<br>!()[]<br>解决：<code>cnpm i --save hexo-wordcount</code></p></blockquote><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><p>依次输入</p><blockquote><p>cnpm install hexo-generator-index-pin-top –save<br>cnpm uninstall hexo-generator-index –save</p></blockquote><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>_posts 下打开 Git bash ：hexo new “文章名”</p><h3 id="插件修复"><a href="#插件修复" class="headerlink" title="插件修复"></a>插件修复</h3><p>检查hexo相关插件：cnpm ls –depth 0<br>安装缺失的插件：cnpm install hexo-generator-archive –save<br>修复：cnpm audit fixc</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/sr/post/2019-10-01-%E6%9D%82%E9%A1%B9-%E5%BB%BA%E7%AB%99-Hello-World/</url>
    <content><![CDATA[<!-- build time:Mon May 10 2021 22:39:44 GMT+0000 (Coordinated Universal Time) --><blockquote class="blockquote-center"><p>此段为引用文本</p></blockquote><p>MarkDown 语法兼容大部分 HTML</p><center>居中文字</center><div class="note danger"><p>警告 (红色)</p></div><div class="note default"><p>默认 (灰色)</p></div><div class="note primary"><p>主要 (紫色)</p></div><div class="note success"><p>成功 (绿色)</p></div><div class="note info"><p>生成 (蓝色))</p></div><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a><a href="#QuickStart">快速入门</a></h2><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post.Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="QuickStart"><a href="#QuickStart" class="headerlink" title="QuickStart"></a>QuickStart</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><h2 id="next6-7之后，配置-config-yml的摘要-预览失效问题"><a href="#next6-7之后，配置-config-yml的摘要-预览失效问题" class="headerlink" title="next6/7之后，配置_config.yml的摘要/预览失效问题"></a>next6/7之后，配置<code>_config.yml</code>的摘要/预览失效问题</h2><p>解决方法：使用<code>&lt;!-- more --&gt;</code>标签包裹你不需要在首页展示的内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里放摘要</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">...</span><br><span class="line">这里放正文</span><br><span class="line">...</span><br><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure><p>还可以这样</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里放摘要</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">...</span><br><span class="line">这里放正文</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>配置后，敲个本地调试命令<code>hexo s</code>，浏览器输入<code>http://localhost:4000/</code>即可看到此时首页只显示摘要，而不显示后面的内容了。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>杂项</category>
        <category>建站</category>
      </categories>
  </entry>
</search>
