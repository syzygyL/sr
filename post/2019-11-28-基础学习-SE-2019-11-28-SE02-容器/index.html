<!-- build time:Mon May 10 2021 22:39:49 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/sr/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/sr/images/yelp32.png"><link rel="icon" type="image/png" sizes="16x16" href="/sr/images/yelp16.png"><link rel="mask-icon" href="/sr/images/logo.svg" color="#222"><link rel="stylesheet" href="/sr/css/main.css"><link rel="stylesheet" href="/sr/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://xming1001.github.io/sr").hostname,root:"/sr/",scheme:"Pisces",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!0,preload:!0},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="容器容器基本的类型是 Lst、Set、 Queue 和 Map，这些基本对象类型也称为集合类,Java 类库中使用了 Collection 这个名字来指代该类库中的一个特殊子集（Lst、Set、 Queue）, Collection+Map集合集合概述数组和集合两者区别：数组一旦实例化，其长度 length 是固定的，而集合的长度 size 是可变的数组可以存储所有引用类型和基本类型，集合中只能存"><meta property="og:type" content="article"><meta property="og:title" content="SE02-容器"><meta property="og:url" content="https://xming1001.github.io/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE02-%E5%AE%B9%E5%99%A8/index.html"><meta property="og:site_name" content="Xm"><meta property="og:description" content="容器容器基本的类型是 Lst、Set、 Queue 和 Map，这些基本对象类型也称为集合类,Java 类库中使用了 Collection 这个名字来指代该类库中的一个特殊子集（Lst、Set、 Queue）, Collection+Map集合集合概述数组和集合两者区别：数组一旦实例化，其长度 length 是固定的，而集合的长度 size 是可变的数组可以存储所有引用类型和基本类型，集合中只能存"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2020/01/13/l7lV81.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/03/1U9UtH.png"><meta property="article:published_time" content="2019-11-28T12:02:20.000Z"><meta property="article:modified_time" content="2021-05-10T22:39:23.772Z"><meta property="article:author" content="min"><meta property="article:tag" content="note"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.ax1x.com/2020/01/13/l7lV81.png"><link rel="canonical" href="https://xming1001.github.io/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE02-%E5%AE%B9%E5%99%A8/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>SE02-容器 | Xm</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://github.com/xming1001" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#70B7FD;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/sr/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Xm</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">沉醉负白首，舒怀成大观<br>醒，亦在人间；梦，亦在人间~</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-去首页"><a href="/sr/" rel="section"><i class="fa fa-fw fa-home"></i>去首页</a></li><li class="menu-item menu-item-分类树"><a href="/sr/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类树</a></li><li class="menu-item menu-item-关于我"><a href="/sr/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于我</a></li><li class="menu-item menu-item-时间轴"><a href="/sr/archives/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>时间轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜本站</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xming1001.github.io/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE02-%E5%AE%B9%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s2.ax1x.com/2019/12/30/lla7HU.gif"><meta itemprop="name" content="min"><meta itemprop="description" content="欢迎瓜友~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Xm"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SE02-容器</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-28 12:02:20" itemprop="dateCreated datePublished" datetime="2019-11-28T12:02:20+00:00">2019-11-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-05-10 22:39:23" itemprop="dateModified" datetime="2021-05-10T22:39:23+00:00">2021-05-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/sr/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">基础学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/sr/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/SE/" itemprop="url" rel="index"><span itemprop="name">SE</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p><strong>容器</strong>基本的类型是 Lst、Set、 Queue 和 Map，这些基本对象类型也称为集合类,Java 类库中使用了 <code>Collection</code> 这个名字来指代该类库中的一个特殊子集（Lst、Set、 Queue）, Collection+Map</p><p><img data-src="https://s2.ax1x.com/2020/01/13/l7lV81.png" alt="整理的含抽象类和遗留构件的容器图"></p><p><img data-src="https://s2.ax1x.com/2020/02/03/1U9UtH.png" alt="不含抽象类和遗留构件的容器图-Thinking In java"></p><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h4><p>数组和集合两者区别：</p><ul><li>数组一旦实例化，其长度 <code>length</code> 是固定的，而集合的长度 <code>size</code> 是可变的</li><li>数组可以存储所有引用类型和基本类型，集合中只能存储引用数据类型</li><li>数组中存储的元素类型是一致的，集合可以不一致（不指定泛型时）</li></ul><h5 id="集合通用实现"><a href="#集合通用实现" class="headerlink" title="集合通用实现"></a>集合通用实现</h5><table><thead><tr><th>接口</th><th>哈希表</th><th>可变长数组</th><th>平衡树</th><th>链表</th><th>哈希表+链表</th></tr></thead><tbody><tr><td>Set</td><td>HashSet</td><td>-</td><td>TreeSet</td><td>-</td><td>LinkedHashSet</td></tr><tr><td>List</td><td>-</td><td>ArrayList</td><td>-</td><td>LinkedList</td><td>-</td></tr><tr><td>Deque</td><td>-</td><td>ArrayDeque</td><td>-</td><td>LinkedList</td><td>-</td></tr><tr><td>Map</td><td>HashMap</td><td>-</td><td>TreeMap</td><td>-</td><td>LinkedHashMap</td></tr></tbody></table><p>所有的新实现都含有实现了 fail-fast (快速失败) 的迭代器，它检测无效的并发修改，并且快速而干净地报出失败</p><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection 是所有单列集合（List、Set、Queue）的父接口</p><p>所有的继承(实现)类/接口都拥有这些方法（未完全列出）</p><ul><li>public boolean add(E e)：将指定元素添加至当前集合</li><li>public void clear()：清空集合所有元素</li><li>public boolean remove(E e): 从当前集合移除指定元素</li><li>public boolean contains(Object obj): 判断当前集合中是否包含指定对象</li><li>public boolean isEmpty(): 判断当前集合是否为空</li><li>public int size(): 返回集合长度</li><li>public Object[] toArray(): 把集合中的元素，存储到数组</li></ul><h5 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h5><p>Collection 接口继承了 Iterable 接口 ，接口中抽象方法 <code>Iterator&lt;E&gt; iterator();</code> 要求所有 Collection 的实现类实现此方法，通过集合实例.iterator() 获取迭代器，遍历集合内元素</p><ul><li>public E next()：获取迭代的下一个元素。</li><li>public boolean hasNext()：如果仍有元素可以迭代，则返回 true。</li><li>public void remove()：移除此次迭代的元素（ ForEach 中要删除集合内元素只能用迭代器的这个方法）</li></ul><p><strong>特性</strong></p><p>1.迭代器只能使用一次，当元素被迭代遍历一次后，再次使用 <code>next()</code> 获取元素时将会抛出 <code>NoSuchElementException</code> （无下文异常），有点类似数组下标访问越界</p><p>2.（ *fail-fast 机制 ）在对 java.util 包下的 <code>Collection</code>集合进行遍历时，不能使用集合通用的 add()、remove()、clear() 等方法进行增删，若要删除必须使用迭代器的 remove() ，否则将会抛出 <code>ConcurrentModificationException</code>(并发修改异常)，引发多线程时的数据不安全问题（此时建议用并发构建块 java.util.concurrent ），java.util.concurrent 包下的容器都是fail-safe的，可以在多线程下并发使用，并发修改。同时也可以在foreach中进行add/remove 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">iteratorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(<span class="string">"A"</span>);</span><br><span class="line">        coll.add(<span class="string">"B"</span>);</span><br><span class="line">        coll.add(<span class="string">"C"</span>);</span><br><span class="line">        println(<span class="string">"迭代前："</span> + coll);</span><br><span class="line">        Iterator&lt;String&gt; iter = coll.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            String next = iter.next();</span><br><span class="line">            println(next);</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"c"</span>.equalsIgnoreCase(next)) &#123;</span><br><span class="line">                iter.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">"迭代后："</span> + coll);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output</span></span><br><span class="line"><span class="comment">迭代前：[A， B， C]</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">B</span></span><br><span class="line"><span class="comment">C</span></span><br><span class="line"><span class="comment">迭代后：[A， B]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>3.java.util 包下的所有 <code>Collection</code> 集合都继承了 <code>Iterable</code> 接口的 fail-fast （快速失败）属性。 java.util.concurrent 包下面的所有的类都是 fail-safe （安全失败）的，遍历拷贝，不报异常。</p><h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><p>增强型 for 循环，用于遍历数组、集合，底层实现为迭代器,格式：for( 元素数据类型 变量名 : 数组名\集合名 ){ … }</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>java.util.List 接口继承自 Collection 接口，将实现了 <code>List</code> 接口的类统称为 List 集合。<br>主要的三个实现类：1. ArrayList 2. LinkedList 3. Vector（不常用）</p><p>常用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* public void add(int index， E element)：将指定的元素，添加到该集合中的指定位置</span><br><span class="line">* public E remove(int index)：移除列表中指定位置的元素， 返回移除的元素</span><br><span class="line">* public E set(int index， E element):用指定元素替换集合中指定位置的元素，返回替换前的元素</span><br><span class="line">* public E get(int index)：获取集合中指定位置的元素</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List list1 = <span class="keyword">null</span>;              <span class="comment">// 创建的是 null 集合</span></span><br><span class="line">      <span class="comment">// list1.add("1");                 // 执行时将抛出 NullPointerException</span></span><br><span class="line">      List list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 创建一个空集合(size() = 0)</span></span><br><span class="line">      println(list1);</span><br><span class="line">      println(list2);</span><br><span class="line">      <span class="comment">/** Output:</span></span><br><span class="line"><span class="comment">       * null</span></span><br><span class="line"><span class="comment">       * []</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p><strong>特点：有索引，查询块，增删慢</strong><br>底层为 Object[] ，初始容量为 10，超过则按 1.5 倍增长</p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p><strong>特点：无索引，查询慢，增删快</strong><br>底层为双向链表( JDK1.6 之前为循环链表，JDK1.7 取消了循环)</p><h5 id="Vector（不常用，被淘汰）"><a href="#Vector（不常用，被淘汰）" class="headerlink" title="Vector（不常用，被淘汰）"></a>Vector（不常用，被淘汰）</h5><p><strong>特点：方法同步的( Synchronized )，线程安全的</strong><br>底层为 Object[]，初始容量为 10，超过则翻倍增长 (由于同步会影响其性能)</p><h5 id="RandomAccess"><a href="#RandomAccess" class="headerlink" title="RandomAccess"></a>RandomAccess</h5><p>java.util.RandomAccess 随机访问标志接口 ，内部无任何方法（标志接口）<br>ArrayList 实现了此接口，表明 ArrayList 具有快速随机访问功能</p><div class="note primary"><p>实现了 RandomAccess 接口的list，优先选择普通 for 循环 ，其次 foreach，<br>未实现 RandomAccess 接口的list，优先选择 iterator 遍历（foreach 遍历底层也是通过 iterator 实现的）</p></div><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>java.util.Set 接口继承自Collection接口，将实现了 <code>Set</code> 接口的类统称为 Set 集合。主要的三个实现类： 1. HashSet 2. TreeSet 3. LinkedHashSet</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p><strong>特点：无索引，元素唯一，存取无序</strong></p><p>允许空键 null ，基于 <code>HashMap</code> 实现，底层通过 <code>HashMap</code> 来保存元素来修改集合元素，除了 clone()、writeObject()、readObject() 是 <code>HashSet</code>自己实现之外，其他方法都是直接调用 <code>HashMap</code> 中的方法。</p><p><strong>通过重写存储对象中的 hashCode 和 equals 方法保证元素唯一性</strong></p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p><strong>特点：无索引，元素唯一，存取有序</strong><br>继承自 <code>HashSet</code>，由链表结构保证元素存取有序</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p><strong>特点：无索引，元素唯一，存取有序</strong><br>红黑树(自平衡的排序二叉树)</p><p><strong>自然排序：</strong> TreeSet() 将默认调用升序排序<br><strong>比较器排序：</strong> TreeSet(Comparator&lt;? super E&gt; comparator)</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><p>Map 在《Thinking in Java》一书中被称之为 <code>映射表</code>，基本思想是维护键-值（对）<br><strong>Map 不是 Collection 的子接口，不具有迭代器和 Collection 的通用方法</strong></p><p>java.util 包下的 Map 接口，用来保存具有映射关系的数据： key 和 value，称为键值对。Map 中键必须唯一，值可以重复，它们都可以使任何引用类型的数据 。通过指定的 key 可以取出对应的 value 。HashMap 支持 null 键，TreeMap 不支持。</p><p>Map接口定义了如下常用的方法：</p><ul><li><p>public V put(K key， V value): 添加键值对到 Map。返回被替换的值</p></li><li><p>public V get(Object key)：根据指定的键，获取对应值</p></li><li><p>public int size()：返回键值对数量</p></li><li><p>public V remove(Object key): 把指定的键所对应的键值对元素，在Map集合中删除，返回被删除元素的值</p></li><li><p>public Set<k>keySet(): 获取Map集合中所有的键，存储到 <code>Set</code></k></p></li><li><p>public Collection<v>values​()：获取Map集合中所有的值，存储到 <code>Collection</code></v></p></li><li><p>public Set&lt;Map.Entry&lt;K，V&gt;&gt; entrySet(): 获取到Map集合中所有的 键值对对象 的集合(Set集合) ，遍历效率比 keySet 高<br>Map集合中的元素是键值对，键值对是2个对象<br>键值对对象是一个对象<br>键值对对象: 其实就是把键值对 包装成对象 这个对象就叫做键值对对象<br>键值对对象类型: Entry类型</p></li><li><p>public boolean containKey(Object key):判断该集合中是否有此键</p></li><li><p>public boolean containValue(Object value):判断该集合中是否有此值</p></li><li><p>public void clear()：清空 Map</p></li></ul><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>HashMap 是 Map基于哈希表的 Map接口实现，其底层就是一个数组结构，数组中的每一项又是一个链表，插入和查询的开销是固定的，可以通过构造器设置容量和负载因子，以调整 HashMap性能，允许空键 null（有且只有一个） 和空值 null。两个重要参数：初始容量(创建哈希表时的容量)和负载因子(哈希表的容量自动增加之前，允许哈希表获得的满容量的度量)，当哈希表中的条目数目超过了负载因子和当前容量的乘积时，哈希表被重置（即，内部数据结构被重建），使得哈希表的桶数大约是桶数的两倍。 一般来说，默认加载因子（0.75）在时间和空间成本之间提供了一个很好的折衷。</p><p><strong>特点：查询快，元素唯一，存取无序</strong></p><p>JDK7 及之前为数组+链表<br><strong>JDK8 及之后引入红黑树，当链表超过设定设定阈值 8 时，将链表转为红黑树（转之前先检查数组容量是否到达设定阈值 64 ，没有到达则扩容数组，否则转红黑树）</strong>：也就是当 Hash 冲突时会形成 Node 链表，在链表长度超过 8 ，Node 数组超过 64 时会将链表结构转换为红黑树</p><p>为啥要大于8才转，为啥不直接用红黑树？？？</p><p>HashMap在JDK1.8及以后的版本中引入了红黑树结构，若桶中链表元素个数大于等于8时，链表转换成树结构；若桶中链表元素个数小于等于6时，树结构还原成链表。因为红黑树的平均查找长度是log(n)，长度为8的时候，平均查找长度为3，如果继续使用链表，平均查找长度为8/2=4，这才有转换为树的必要。链表长度如果是小于等于6，6/2=3，虽然速度也很快的，如果这个时候就没有必要转为树。</p><p>还有选择6和8，中间有个差值7可以有效防止链表和树频繁转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p>官方文档：</p><blockquote><p>Replaces all linked nodes in bin at index for given hash unless table is too small， in which case resizes instead.</p></blockquote><p>红黑树：自平衡排序二叉树（防止二叉树退化成线性结构）</p><ul><li>节点是红色或黑色</li><li>根节点必须是黑色</li><li>每个红色节点的两个子节点都是黑色</li><li>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</li></ul><div class="note danger"><p>用自定义类作为 HashMap 的 key 时，必须重写 equals()和 hashCode()方法</p></div><h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><p><strong>特点：查询快，元素唯一，存取有序</strong><br>继承自 HashMap ，由双向链表维护元素的存取有序</p><h5 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h5><p><strong>特点：可排序，查询快，元素唯一，存取有序</strong><br>红黑树(自平衡的排序二叉树)</p><p><strong>自然排序(升序)：</strong> TreeMap()<br><strong>比较器排序(实现 Comparator 接口)：</strong> TreeMap(Comparator&lt;? super K&gt; comparator)</p><h5 id="Hashtable-不常用，淘汰"><a href="#Hashtable-不常用，淘汰" class="headerlink" title="Hashtable (不常用，淘汰)"></a>Hashtable (不常用，淘汰)</h5><p><strong>特点：方法同步的( Synchronized )，线程安全的</strong><br>数组+链表组成</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="comparable-与-comparator-区别"><a href="#comparable-与-comparator-区别" class="headerlink" title="comparable 与 comparator 区别"></a>comparable 与 comparator 区别</h4><p>comparable 与 comparator 区别</p><ul><li>java.lang Interface Comparable<t>内部方法只有一个 int compareTo(T o) ， 当对自定义对象（非系统类实例）进行排序时，需重写。</t></li><li>java.util.interface Comparator<t>使用时必须重写 int compare(T o1， T o2) 方法;<ul><li>当o2 - o1，降序</li><li>当o1 - o2，升序</li></ul></t></li></ul><h4 id="与-equals"><a href="#与-equals" class="headerlink" title="== 与 equals()"></a>== 与 equals()</h4><ul><li>==: 基本类型比较<strong>值</strong>，引用类型比较<strong>地址</strong>。</li><li>equals():<ul><li>类未重写 equals()，则等价于通过 “==” 比较这两个对象。</li><li>类已重写 equals()，则按照比较规则来比较两个对象。（一般重写规则为<code>比较内容</code>）</li><li>通常需要一起重写 hashCode()</li></ul></li></ul><h4 id="hashCode-与-equals"><a href="#hashCode-与-equals" class="headerlink" title="hashCode() 与 equals()"></a>hashCode() 与 equals()</h4><ul><li><p>哈希表（散列表）：在 Java 中，哈希表用的是链表+数组实现的，每个链表称之为桶。通过给定的关键字的值直接访问到具体对应的值的一个数据结构，哈希表存储的是键值对(key-value)。</p></li><li><p>hashCode()：返回一个 int 整数（哈希码），用于确定对象在哈希表中的存储地址。hashCode() 的值只有在哈希表内才有用</p></li><li><p>hashCode（）与 equals（）的相关规定</p><ul><li>根据 equals(Object) 方法两个对象为<code>true</code>，两个对象的hashCode值必须相同</li><li>两个对象的 hashCode 值可以相同，且 equals(Object) 方法两个对象可以为<code>false</code></li><li>equals() 如果被重写过，则 hashCode() 也必须被重写</li><li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ul></li></ul><h4 id="Set（Key-和-Value-相同）如何保证元素不重复"><a href="#Set（Key-和-Value-相同）如何保证元素不重复" class="headerlink" title="Set（Key 和 Value 相同）如何保证元素不重复"></a>Set（Key 和 Value 相同）如何保证元素不重复</h4><ul><li>当 Set 集合存储元素时，通过 hashCode() 计算其元素的 hash 值</li><li>根据 hash 值查询哈希表内是否有相等的 hash 值</li><li>若没有，则添加此键值对</li><li>若有，则产生哈希冲突，在此元素位置创建一个链表</li><li>再调用 equals() 进行内容比较，判断该位置元素的 Key 是否于 要存入的元素 Key 相同</li><li>结果为 ture，不存储（两个对象 Key 相同，且哈希值相等）</li><li>结果为 false，将此键值对添加至链表尾（两个对象 Key 不同，但哈希值相等）</li></ul><h4 id="Map（Key-和-Value-不同）如何保证元素不重复"><a href="#Map（Key-和-Value-不同）如何保证元素不重复" class="headerlink" title="Map（Key 和 Value 不同）如何保证元素不重复"></a>Map（Key 和 Value 不同）如何保证元素不重复</h4><ul><li>Map 存储元素时，先通过 hashCode()计算 key对应哈希值 h</li><li>不存在: 若没有此 h对应的 key，则添加此元素到哈希表</li><li>存在: 如果 h对应的 key有一个，则直接覆盖，若有多个则调用 equals()进行内容比较，找到为 true的key，进行覆盖</li></ul><p>使用数组存放哈希值<br>使用链表存放产生冲突的哈希值<br>当链表超过设定设定阈值 8 时，将链表转为红黑树</p><h4 id="处理哈希冲突（哈希碰撞）"><a href="#处理哈希冲突（哈希碰撞）" class="headerlink" title="处理哈希冲突（哈希碰撞）"></a>处理哈希冲突（哈希碰撞）</h4><p>常见处理哈希冲突方法有：开放地址法、再哈希法、链地址法</p><p>HashMap采用的是链地址法（拉链法）：散列到同一位置的元素，不是继续往下探测，而是在这个位置添加一个链表，这些元素则都放到这一个链表上。<br><strong>JDK8 后当链表超过设定设定阈值 8 时，将链表转为红黑树（自平衡防止二叉树退化），优化搜索时间。</strong></p><p>官方文档：</p><blockquote><p>The bin count threshold for using a tree rather than list for a bin. Bins are converted to trees when adding an element to a bin with at least this many nodes. The value must be greater than 2 and should be at least 8 to mesh with assumptions in tree removal about conversion back to plain bins upon shrinkage.</p></blockquote><h4 id="HashMap扩容机制"><a href="#HashMap扩容机制" class="headerlink" title="HashMap扩容机制"></a>HashMap扩容机制</h4><p>如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。那么我们可以创建时指定容量，JDK会默认帮我们计算一个相对合理的值当做初始容量。所谓合理值，其实是找到第一个比用户传入的值大的2的幂。比如你<code>new HashMap(7)</code>，jdk会帮我们创建容量为8的Map,在元素个数达到 8*0.75 = 6的时候就会进行一次扩容。</p><p>扩容必须满足两个条件</p><p><strong>存放新值的时候当前已有元素必须大于阈值</strong><br><strong>存放新值的时候当前存放数据发生hash碰撞（当前key计算的hash值计算出的数组索引位置已经存在同哈希值）</strong></p><p>HashMap在添加值的时候，它默认能存储16个键值对，直到你使用这个HashMap时，它才会给HashMap分配16个键值对的存储空间，（负载因子为0.75,阈值为12），当16个键值对已经存储满了，我们在添加第17个键值对的时候才会发生扩容现象，因为前16个值，每个值在底层数组中分别占据一个位置，并没有发生hash碰撞。<br>HashMap也有可能存储更多的键值对，最多可以存储26个键值对，我们来算一下：存储的前11个值全部发生hash碰撞，存到数组的同一个位置中，（这时元素个数小于阈值12，不会扩容），之后存入15个值全部分散到数组剩下的15个位置中，（这时元素个数大于等于阈值，但是每次存入元素并没有发生hash碰撞，不会扩容），11+15=26，当我们存入第27个值得时候满足以上两个条件，HashMap才会发生扩容.</p><h3 id="Collections-Arrays-工具类"><a href="#Collections-Arrays-工具类" class="headerlink" title="Collections/Arrays 工具类"></a>Collections/Arrays 工具类</h3><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li>public static<t>boolean addAll(Collection&lt;? super T&gt; c， T… elements) 将所有指定元素添加到指定 Collection 中。</t></li><li>public static void shuffle(List&lt;?&gt; list)：打乱集合顺序。</li><li>public static<t>void sort(List<t>list)：将集合中元素按照默认规则排序。<br>默认规则:要求集合中元素所属的类必须实现Comparable接口，重写compareTo方法，在该放中定义排序规则</t></t></li><li>public static<t>void sort(List<t>list，Comparator<t>omparator):将集合中元素按照指定规则排序。</t></t></t></li></ul><h4 id="数组转为-List-的三种方式"><a href="#数组转为-List-的三种方式" class="headerlink" title="数组转为 List 的三种方式"></a>数组转为 List 的三种方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//方式一：有内部类适配器模式创建，不能进行集合修改 （有很大缺陷） </span></span><br><span class="line"><span class="comment">//注意：1.传入数组必须为引用类型数组 2.此方法创建的 List 不能使用 add()\remove()等修改集合的方法</span></span><br><span class="line">List list1 = Arrays.asList(<span class="string">"aaa"</span>， <span class="string">"aa"</span>， <span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//方式二：最简便的方式（推荐）</span></span><br><span class="line">List list2 = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"sss"</span>， <span class="string">"ss"</span>， <span class="string">"s"</span>));</span><br><span class="line"><span class="comment">//方式三：使用 java8 的 Stream </span></span><br><span class="line"></span><br><span class="line">String[] arr = &#123;<span class="string">"ddd"</span>， <span class="string">"dd"</span>， <span class="string">"d"</span>&#125;;</span><br><span class="line">List list3 = Stream.of(arr).collect(Collectors.toList());       <span class="comment">// Stream.of(arr) 得到数组流</span></span><br><span class="line"><span class="comment">//List list4 = Arrays.stream(arr).collect(Collectors.toList()); // Arrays.stream(arr) 得到数组流</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>， <span class="number">2</span>， <span class="number">3</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; list4 = Arrays.stream(arr1).boxed().collect(Collectors.toList()); <span class="comment">// IntStream 流的自动装箱 boxed()        </span></span><br><span class="line"></span><br><span class="line">printf(<span class="string">"list1:%s\n"</span>， list1);</span><br><span class="line">printf(<span class="string">"list2:%s\n"</span>， list2);</span><br><span class="line">printf(<span class="string">"list3:%s\n"</span>， list3);</span><br><span class="line">printf(<span class="string">"list4:%s\n"</span>， list4);</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*output</span></span><br><span class="line"><span class="comment">    list1:[aaa， aa， a]</span></span><br><span class="line"><span class="comment">    list2:[sss， ss， s]</span></span><br><span class="line"><span class="comment">    list3:[ddd， dd， d]</span></span><br><span class="line"><span class="comment">    list4:[1，2，3]</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h4 id="List-转为数组-toArray-，-利用-Collections-reverse-反转集合"><a href="#List-转为数组-toArray-，-利用-Collections-reverse-反转集合" class="headerlink" title="List 转为数组 toArray() ， 利用 Collections.reverse() 反转集合"></a>List 转为数组 toArray() ， 利用 Collections.reverse() 反转集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse()</span></span><br><span class="line">printf(<span class="string">"翻转前：%s\n"</span>， list);</span><br><span class="line">Collections.reverse(list);</span><br><span class="line">printf(<span class="string">"翻转后：%s\n"</span>， list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用集合的 toArray() </span></span><br><span class="line"><span class="comment">//一：实参指定转换的数组类型，new String[0]</span></span><br><span class="line">Integer[] iArr = (Integer[])list.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//二</span></span><br><span class="line">Integer[] iArr2 = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">list.toArray(iArr2);</span><br><span class="line"></span><br><span class="line">print(<span class="string">"数组元素："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iArr.length; i++) &#123;</span><br><span class="line">    printf(<span class="string">"%d\t"</span>， iArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  翻转前：[1， 2， 3， 4]</span></span><br><span class="line"><span class="comment">  翻转后：[4， 3， 2， 1]</span></span><br><span class="line"><span class="comment">  数组元素：4	3	2	1	</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></div><div><div><div style="text-align:center;color:#1b9af7;font-size:14px">----------本文结束&nbsp<i class="fa fa-hourglass-end"></i>&nbsp感谢您的阅读----------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/sr/tags/note/" rel="tag"><i class="fa fa-tag"></i>note</a></div><div class="post-nav"><div class="post-nav-item"><a href="/sr/post/2019-11-26-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-26-SE01-OO%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/" rel="prev" title="SE01-OO编程思想"><i class="fa fa-chevron-left"></i> SE01-OO编程思想</a></div><div class="post-nav-item"><a href="/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE03-%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%BC%82%E5%B8%B8/" rel="next" title="SE03-泛型和异常">SE03-泛型和异常 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#容器"><span class="nav-number">1.</span> <span class="nav-text">容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合"><span class="nav-number">1.1.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#集合概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">集合概述</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#集合通用实现"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">集合通用实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Collection"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Iterator"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#foreach"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">foreach</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">1.1.2.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ArrayList"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">ArrayList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">LinkedList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Vector（不常用，被淘汰）"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Vector（不常用，被淘汰）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RandomAccess"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">RandomAccess</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">1.1.3.</span> <span class="nav-text">Set</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashSet"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">HashSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashSet"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">LinkedHashSet</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeSet"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">TreeSet</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">1.2.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#HashMap"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedHashMap"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">LinkedHashMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TreeMap"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Hashtable-不常用，淘汰"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">Hashtable (不常用，淘汰)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他"><span class="nav-number">1.3.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#comparable-与-comparator-区别"><span class="nav-number">1.3.1.</span> <span class="nav-text">comparable 与 comparator 区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与-equals"><span class="nav-number">1.3.2.</span> <span class="nav-text">&#x3D;&#x3D; 与 equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#hashCode-与-equals"><span class="nav-number">1.3.3.</span> <span class="nav-text">hashCode() 与 equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set（Key-和-Value-相同）如何保证元素不重复"><span class="nav-number">1.3.4.</span> <span class="nav-text">Set（Key 和 Value 相同）如何保证元素不重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Map（Key-和-Value-不同）如何保证元素不重复"><span class="nav-number">1.3.5.</span> <span class="nav-text">Map（Key 和 Value 不同）如何保证元素不重复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理哈希冲突（哈希碰撞）"><span class="nav-number">1.3.6.</span> <span class="nav-text">处理哈希冲突（哈希碰撞）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HashMap扩容机制"><span class="nav-number">1.3.7.</span> <span class="nav-text">HashMap扩容机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections-Arrays-工具类"><span class="nav-number">1.4.</span> <span class="nav-text">Collections&#x2F;Arrays 工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法"><span class="nav-number">1.4.1.</span> <span class="nav-text">常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组转为-List-的三种方式"><span class="nav-number">1.4.2.</span> <span class="nav-text">数组转为 List 的三种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List-转为数组-toArray-，-利用-Collections-reverse-反转集合"><span class="nav-number">1.4.3.</span> <span class="nav-text">List 转为数组 toArray() ， 利用 Collections.reverse() 反转集合</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="min" src="https://s2.ax1x.com/2019/12/30/lla7HU.gif"><p class="site-author-name" itemprop="name">min</p><div class="site-description" itemprop="description">欢迎瓜友~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts" id="showPosts"><a href="/sr/archives"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories" id="showCategory"><a href="/sr/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags" id="showTag"><a href="/sr/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xming1001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xming1001" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xming1001@163.com" title="E-Mail → mailto:xming1001@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><script type="text/javascript" charset="utf-8" src="/sr/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/sr/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/IDEA/" rel="tag">IDEA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/MyBatis/" rel="tag">MyBatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/NoSQL/" rel="tag">NoSQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/SQL/" rel="tag">SQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/SVN/" rel="tag">SVN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Travis-CI/" rel="tag">Travis CI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/note/" rel="tag">note</a><span class="tag-list-count">52</span></li></ul></canvas></div></div><div><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright"><a href="https://xming1001.github.io/sr/" class="fa fa-yelp" id="jump"></a><span id="timeDate" style="color:rgba(241,241,241,.8)">载入天数...</span> <span id="times" style="color:rgba(241,241,241,.8)">载入时分秒...</span><script>function createtime(){var n=new Date("10/01/2019 8:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML=" Xm 的小站已运行了 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div style="color:rgba(241,241,241,.8)"><a href="https://xming1001.github.io/sr/" class="fa fa-yelp" style="color:rgba(241,241,241,.8)"></a> 小站总访客数：<span id="busuanzi_value_site_uv"></span>&nbsp人 <a href="https://xming1001.github.io/sr/" class="fa fa-yelp" style="color:rgba(241,241,241,.8)"></a> 小站总访问量：<span id="busuanzi_value_site_pv"></span>&nbsp次</div></div></div></footer></div><script src="/sr/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.9.0/lozad.min.js"></script><script src="/sr/lib/velocity/velocity.min.js"></script><script src="/sr/lib/velocity/velocity.ui.min.js"></script><script src="/sr/js/utils.js"></script><script src="/sr/js/motion.js"></script><script src="/sr/js/schemes/pisces.js"></script><script src="/sr/js/next-boot.js"></script><script src="/sr/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: '0VbITUQA3fmK0vbokUBDF7KN-gzGzoHsz',
      appKey: 'X3MeRhUqCp8hYNQMr9OKyHmY',
      placeholder: "欢迎交流讨论...",
      avatar: 'robohash',
      meta: guest,
      pageSize: '5' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html><script type="text/javascript" src="/sr/js/clicklove.js"></script><!-- rebuild by neat -->