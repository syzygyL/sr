<!-- build time:Mon May 10 2021 22:39:49 GMT+0000 (Coordinated Universal Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/sr/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/sr/images/yelp32.png"><link rel="icon" type="image/png" sizes="16x16" href="/sr/images/yelp16.png"><link rel="mask-icon" href="/sr/images/logo.svg" color="#222"><link rel="stylesheet" href="/sr/css/main.css"><link rel="stylesheet" href="/sr/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/themes/blue/pace-theme-minimal.min.css"><script src="//cdnjs.cloudflare.com/ajax/libs/pace/1.0.2/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://xming1001.github.io/sr").hostname,root:"/sr/",scheme:"Pisces",version:"7.6.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!0,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!0,mediumzoom:!1,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!0,preload:!0},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="写在前面并行：两个或多个事件在同一时刻发生 （同时执行）并发：两个或多个事件在同一时间段发生（不一定同时执行）进程：是系统资源分配的基本单位，当应用程序启动时，就有一个或多个进程启动特点：拥有独立地址空间，开销大线程：是系统资源调度的基本单位，当我们创建一个 java 程序并加载类文件时就已经开启了一个 main 线程特点：多个线程共享进程的堆和方法区资源，每个线程独立拥有虚拟机栈、程序计数器和本"><meta property="og:type" content="article"><meta property="og:title" content="SE04-多线程"><meta property="og:url" content="https://xming1001.github.io/sr/post/2019-12-01-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-01-SE04-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="Xm"><meta property="og:description" content="写在前面并行：两个或多个事件在同一时刻发生 （同时执行）并发：两个或多个事件在同一时间段发生（不一定同时执行）进程：是系统资源分配的基本单位，当应用程序启动时，就有一个或多个进程启动特点：拥有独立地址空间，开销大线程：是系统资源调度的基本单位，当我们创建一个 java 程序并加载类文件时就已经开启了一个 main 线程特点：多个线程共享进程的堆和方法区资源，每个线程独立拥有虚拟机栈、程序计数器和本"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2020/01/13/l7lXZD.png"><meta property="article:published_time" content="2019-12-01T10:20:03.000Z"><meta property="article:modified_time" content="2021-05-10T22:39:23.772Z"><meta property="article:author" content="min"><meta property="article:tag" content="note"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.ax1x.com/2020/01/13/l7lXZD.png"><link rel="canonical" href="https://xming1001.github.io/sr/post/2019-12-01-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-01-SE04-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>SE04-多线程 | Xm</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://github.com/xming1001" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#70B7FD;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/sr/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Xm</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">沉醉负白首，舒怀成大观<br>醒，亦在人间；梦，亦在人间~</p></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-去首页"><a href="/sr/" rel="section"><i class="fa fa-fw fa-home"></i>去首页</a></li><li class="menu-item menu-item-分类树"><a href="/sr/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类树</a></li><li class="menu-item menu-item-关于我"><a href="/sr/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于我</a></li><li class="menu-item menu-item-时间轴"><a href="/sr/archives/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>时间轴</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜本站</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="reading-progress-bar"></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://xming1001.github.io/sr/post/2019-12-01-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-01-SE04-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="https://s2.ax1x.com/2019/12/30/lla7HU.gif"><meta itemprop="name" content="min"><meta itemprop="description" content="欢迎瓜友~"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Xm"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">SE04-多线程</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-01 10:20:03" itemprop="dateCreated datePublished" datetime="2019-12-01T10:20:03+00:00">2019-12-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2021-05-10 22:39:23" itemprop="dateModified" datetime="2021-05-10T22:39:23+00:00">2021-05-10</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/sr/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">基础学习</span> </a></span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/sr/categories/%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/SE/" itemprop="url" rel="index"><span itemprop="name">SE</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><strong>并行</strong>：两个或多个事件在<strong>同一时刻</strong>发生 （同时执行）</p><p><strong>并发</strong>：两个或多个事件在<strong>同一时间段</strong>发生（不一定同时执行）</p><p><strong>进程</strong>：是<code>系统资源分配的基本单位</code>，当应用程序启动时，就有一个或多个进程启动<br>特点：拥有独立地址空间，开销大</p><p><strong>线程</strong>：是<code>系统资源调度的基本单位</code>，当我们创建一个 java 程序并加载类文件时就已经开启了一个 main 线程<br>特点：多个线程共享进程的堆和方法区资源，每个线程独立拥有<code>虚拟机栈</code>、程序计数器和本地方法栈，这些开销相较于进程要小得多</p><p>学习完应该要懂得：</p><p>多线程基础（Thread、Runnable）<br>线程状态<br>什么是原子性，CAS算法大致原理<br>了解volatile如何保证内存可见性<br>AtomicXXX类的使用<br>synchronized键字及使用位置<br>Lock锁的使用，与synchronized的区别<br>线程间通信（传统线程技术的wait、notify或者JDK1.5后condition的await和siganl）</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>JVM 允许多个线程并发执行，默认启动 main 和 垃圾回收 两条线程。线程具有优先级，但在初始化时线程优先级都是相同的。线程可能会有守护（后台）线程。<br>导致线程终止的几种情况：</p><ul><li>正常终止：执行完 run()</li><li>意外终止：<ul><li>线程在执行任务时抛出了未捕获异常</li><li>被某线程的 Thread 实例调用了 stop() 强行终止</li><li>执行了 exit()</li></ul></li></ul><p><strong>Java 中线程的生命周期和状态</strong></p><ul><li><strong>新建状态( NEW )</strong>： new 语句创建的线程，未调用 start()</li><li><strong>无限等待状态( WAITING )</strong>：从新建状态后调用 start() 之前或正在运行的线程调用 wait() 之后</li><li><strong>运行状态( RUNNABLE )</strong>：调用 start() 之后，先进入就绪状态（ Java 将<strong>就绪</strong>和<strong>运行</strong>统称为 运行状态）<ul><li>调用 start() ，获取到了 cpu 时间片和锁之后</li><li>处于计时等待的线程计时时间到获取了锁</li><li>处于无限等待的线程被唤醒</li><li>处于阻塞状态的线程获取到了锁</li></ul></li><li><strong>阻塞状态( BLOCKED )</strong>：<ul><li>等待阻塞：线程被唤醒或 wait​(long timeout) 时间到，未获取到锁之后</li><li>同步阻塞：正在运行的程调用同步方法时，未获取到同步锁之后</li><li>其他阻塞：正在运行的线程执行完 sleep() 、 join()（线程加入方法）或者发出了 I/O 请求后</li></ul></li><li><strong>超时等待状态（ TIMED_WAITING ）</strong>：sleep​(long millis) 或者 wait​(long timeout) 被调用后</li><li><strong>死亡状态（ TERMINATED ）</strong>：也称为终止状态。当线程执行完 run() 之后，或遇到未捕获的异常时退出 run() ，进入死亡状态</li></ul><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><p>主要通过调用 Thread 类的构造方法</p><ul><li><p>一：继承 Thread 类重写 run()，然后创建子类对象，然后调用 start 方法运行线程</p></li><li><p>二：实现 Runnable 接口实现 run()，创建 Thread对象(用实现接口的对象作为参数，实例化 Thread)，然后调用此对象的 start 方法运行线程</p></li><li><p>三：实现 Callable 接口实现 call()，通过 submit()传入线程池，运行线程</p></li><li><p>四：线程池</p></li></ul><div class="note info"><p>在《阿里巴巴java开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。而线程池不允许使用Executors去创建，而要通过ThreadPoolExecutor方式，这一方面是由于jdk中Executor框架虽然提供了如newFixedThreadPool()、newSingleThreadExecutor()、newCachedThreadPool()等创建线程池的方法，但都有其局限性，不够灵活；另外由于前面几种方法内部也是通过ThreadPoolExecutor方式实现，使用ThreadPoolExecutor有助于大家明确线程池的运行规则，创建符合自己的业务场景需要的线程池，避免资源耗尽的风险</p></div><h3 id="启动创建相关方法区别"><a href="#启动创建相关方法区别" class="headerlink" title="启动创建相关方法区别"></a>启动创建相关方法区别</h3><p>run() 和 start() 的区别</p><ul><li>run()：线程将要执行的任务，方法体为任务代码，直接调用相当于调用普通方法，不会在创建的线程中执行，而是在 main 线程中执行</li><li>start()：调用此方法将执行线程必须的初始化操作，并将线程添加至线程组通知线程组此线程即将启动，准备运行线程的环境，最终将调用 JVM 执行 run()</li></ul><p>sleep() 和 wait() 有什么区别</p><ul><li>若所在线程拥有某个对象锁 ，wait() 执行后会释放此锁，而 sleep() 不会释放</li><li>sleep() 无需手动唤醒，wait() 需要被其他线程调用同一对象的 notify() 或者 notifyAll() 才能唤醒（或者设置超时等待自动唤醒）</li><li>sleep() 用于暂时停止执行，wait() 常用于线程间通信</li></ul><p>Runnable 接口和 Callable 接口的区别</p><ul><li>线程创建方式区别： Runnable 接口支持 Thread 和 Executors ，而 Callable 仅支持 Executors</li><li>返回值区别： Runnable 接口中的 run() 无返回值，而 Callable 接口中的 call() 返回泛型 V</li><li>异常处理机制：Runnable 接口不能抛出异常，但 Callable 可以</li></ul><p>execute() 和 submit() 的区别</p><ul><li>execute() 提交任务后没有返回值， submit() 提交后返回 Future 对象</li><li>execute() 只能接收 Runnable ，而 submit() 可以接收 Runnable 和 Callable</li></ul><h3 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h3><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被其他线程占用并堵塞了的资源</p><p>产生的必要条件，想要避免/打破死锁只要破坏后面三个条件即可</p><ul><li><p><strong>互斥条件</strong>：在某段时间内某资源只由一个线程占用（互斥排他，一般无法破除）</p></li><li><p><strong>请求与保持条件</strong>：某个线程至少保持有一个资源占用，它又提出了对新的资源请求，但原有资源保持而不释放（一次获取所有资源，设计前期就要避免）</p></li><li><p><strong>不剥夺条件</strong>：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有在使用完后才由自己释放资源（加入超时）</p></li><li><p><strong>环路等待条件</strong>：n个线程之间形成资源请求环形链，n1–&gt;n2，n2–&gt;n3，n3–&gt;n1。（按顺序获取）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个锁</span></span><br><span class="line">    <span class="keyword">static</span> Object LockA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">static</span> Object LockB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 匿名内部类创建 A 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String tName = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.LockA) &#123;</span><br><span class="line">                    <span class="comment">//此处需消耗一下资源（sleep也可以），不加不会出现死锁</span></span><br><span class="line">                    printf(<span class="string">"%s已获取 LockA，正在获取LockB...\n"</span>， tName);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LockB) &#123;</span><br><span class="line">                        printf(<span class="string">"%s已终止\n"</span>， tName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">"A线程"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 匿名内部类创建 B 线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                String tName = Thread.currentThread().getName();</span><br><span class="line">                <span class="keyword">synchronized</span> (DeadLock.LockB) &#123;</span><br><span class="line">                    <span class="comment">//此处需消耗一下资源（sleep也可以），不加不会出现死锁</span></span><br><span class="line">                    printf(<span class="string">"%s已获取 LockB，正在获取LockA...\n"</span>， tName);</span><br><span class="line">                    <span class="keyword">synchronized</span> (DeadLock.LockA) &#123;</span><br><span class="line">                        printf(<span class="string">"%s已终止\n"</span>， tName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;， <span class="string">"B线程"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待唤醒机制"><a href="#等待唤醒机制" class="headerlink" title="等待唤醒机制"></a>等待唤醒机制</h3><p>等待唤醒机制原则就是：<strong>当条件不满足时，线程进入无限等待状态；当条件满足时，唤醒线程，继续执行任务</strong></p><p>当正在运行的线程通过锁对象 A ，调用 wait() 时进入无限等待状态， 此时会释放掉锁对象并放弃 cpu 使用权，只有在被同一个锁对象调用 notify() 后，并获取到锁对象时才会重新进入运行状态。</p><p>notify() 随机唤醒此锁对象上的一个等待线程<br>notifyAll() 唤醒此锁对象上的所有等待线程</p><p>wait() 和 notify() 用于多线程协调运行：</p><ul><li>在 synchronized 内部可以调用 wait() 使线程进入等待状态</li><li>必须在已获得的锁对象上调用 wait()</li><li>在 synchronized 内部可以调用 notify() 或 notifyAll() 唤醒其他等待线程</li><li>必须在已获得的锁对象上调用 notify() 或 notifyAll()</li><li>被唤醒的线程需要重新获得锁后才能继续运行</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>什么是线程安全：当程序中有多个线程在访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也无需额外的同步操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。</p><p>线程安全问题将是 Java 并发编程中最首要解决的问题，因为它将直接导致运行出来的结果和预期值不一致，解决线程安全，本质上就是让线程同步，实际上就是线程间的通信</p><h2 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h2><h3 id="同步代码块-amp-同步方法"><a href="#同步代码块-amp-同步方法" class="headerlink" title="同步代码块&amp;同步方法"></a>同步代码块&amp;同步方法</h3><p>synchronized 是 <strong>重量级锁</strong>，底层原理属于 JVM 层面，它解决对各线程之间访问资源的同步问题，体现了资源的互斥性</p><ul><li>当 synchronized 关键字修饰代码块时，此代码块就是同步代码块，进入此代码块时，需要获取<strong>给定对象的锁</strong>，可以是类对象 (类名.class)</li><li>当 synchronized 关键字修饰成员方法时，此方法就是同步方法，进入此方法时，需要获取<strong>当前实例对象的锁</strong></li><li>当 synchronized 关键字修饰静态方法时，访问静态 synchronized 方法时需获取<strong>当前类对象的锁</strong> (多线程下，静态方法操作静态成员时，可能会出现线程安全问题)</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>锁是用于通过多个线程控制对共享资源的访问的工具，通常，锁提供对共享资源的独占访问：即一次只能有一个线程可以获取锁，并且对共享资源的所有访问都要求首先获取锁。 但是，某些锁可能允许并发访问共享资源，例如 ReadWriteLock 的读取锁。<br>Java 中的 java.util.concurrent.locks 下的 Interface Lock 接口，它提供比 synchronized 更广泛、更灵活的锁操作，其主要的实现类是 <code>ReentrantLock</code></p><p>主要方法：</p><ul><li>void lock​() //获得锁</li><li>void unlock​() // 尝试释放此锁</li></ul><p>代码实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">        count += n;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//保证锁被释放</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态</p><p>JDK 1.6 之后的锁优化:</p><ul><li>偏向锁</li><li>轻量级锁</li><li>自旋锁</li><li>自适应锁</li><li>锁消除</li><li>锁粗化</li></ul><h3 id="原子性、可见性"><a href="#原子性、可见性" class="headerlink" title="原子性、可见性"></a>原子性、可见性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>执行某一个操作时，此操作不可在向下细分，一步到位。原子性主要表现在对共享变量的操作中，多线程中若某个操作若不是原子性的，就会被其他线程打断操作，导致操作失效。</p><p>Java 的默认原子操作：</p><ul><li>Atomic包下的类操作</li><li>基本类型赋值( long 和 double 看系统而定)，引用类型赋值</li></ul><p>解决办法：<br>使用原子类（ CAS 机制：比较并交换）</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>由于当下的 Java 内存模型下，每个线程读取 a 变量时会将此变量拷贝一份到自己的工作内存（本地内存：可能是机器的寄存器），以后对 a 变量的操作都是这份副本变量，导致了副本变量对其他线程而言都是不可见的，会出现某个线程已经修改了 a 变量的值，而另一个线程还在继续使用原来的旧的 a 变量副本，最终出现数据结果的不一致。</p><p>解决办法：<br>使用<code>volatile</code>关键字指示该变量为易变的，当修饰变量发生修改时，所有线程的都会收到通知（令拷贝副本失效），以保证可见性，使每次使用都是从主内存中读取到最新值，但它<strong>不保证原子性</strong>。<br>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><p>volatile 保证：</p><ul><li>一旦写入修改，任何访问此字段的线程都会是最新数据</li><li>写入前，会保证所有在此之前该发生的副作用都会执行完</li><li>防止指令重排序</li></ul><p>使用 volatile 关键字需要考虑的情况：</p><ul><li>当修改变量时无需参考当前的变量值</li><li>该变量时可变的，不会在某个情况下处于不变性</li><li>访问时无需加锁</li></ul><p>volatile 的一个重要作用就是和 CAS 结合，保证了原子性，详细的可以参考 <code>java.util.concurrent.atomic</code> 包下的类，比如 AtomicInteger。</p><h3 id="并发包-JUC"><a href="#并发包-JUC" class="headerlink" title="并发包 JUC"></a>并发包 JUC</h3><h4 id="java-util-concurrent-atomic"><a href="#java-util-concurrent-atomic" class="headerlink" title="java.util.concurrent.atomic"></a>java.util.concurrent.atomic</h4><p>atomic 原子类：具有原子性操作特征的类<br>主要的类分为以下 4 种</p><ul><li>基本类型原子类</li><li>数组类型原子类</li><li>引用类型原子类</li><li>对象的属性修改类型原子类：如果需要原子更新某个类里的某个字段时，需要用到对象的属性修改类型原子类。</li></ul><p>Atomic 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h4><p>CountDownLatch 允许一个或多个线程等待某些操作完成</p><p><strong>常用方法</strong></p><ul><li>public CountDownLatch(int count)// 初始化一个指定计数器的CountDownLatch对象</li><li>public void await() throws InterruptedException// 让当前线程等待</li><li>public void countDown() // 计数器进行减1</li></ul><h4 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h4><p>CyclicBarrier 线程的集合点</p><p><strong>常用方法</strong></p><ul><li>public CyclicBarrier(int parties， Runnable barrierAction)// 用于在线程到达屏障时，优先执行 barrierAction ，方便处理更复杂的业务场景</li><li>public int await() // 每个线程调用 await() 告诉 CyclicBarrier 已到达集合点，然后当前线程被阻塞</li></ul><h4 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h4><p>Semaphore 控制资源的线程访问数量 ，是 Java 版本的信号量实现</p><p><strong>常用方法</strong></p><ul><li>public Semaphore(int permits) // permits 表示许可线程的数量</li><li>public void acquire() throws InterruptedException// 表示获取许可</li><li>public void release()// 表示释放许可</li></ul><h4 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h4><p>Exchanger 交换者，是一个用于线程间协作的工具类</p><p><strong>常用方法</strong></p><ul><li>public Exchanger() //</li><li>public V exchange(V x) // x，交换的元素</li></ul><h3 id="CAS-机制-compare-and-swap"><a href="#CAS-机制-compare-and-swap" class="headerlink" title="CAS 机制(compare and swap)"></a>CAS 机制(compare and swap)</h3><p>引入：如金融管理系统，当某个员工需要读取用户的数据，并在读出的用户数据基础上进行修改时（如修改用户手机号，或者余额），如果采用悲观锁机制，也就意味着在整个操作过程中（从读取数据、开始修改、提交修改、还要加上中途未进行操作的时间），而数据记录始终处于加锁状态（高并发情况下将无法操作此记录），而乐观锁在一定程度上解决了这个问题，乐观锁大多是基于<code>数据版本（ version ）记录机制</code>或者 <code>CAS</code> 来实现的，在操作数据时，将版本号一同读出，之后更新时，变更版本号（加1）。如果旧值与它在 Atomic 对象中的内存值不一致，那么这个操作将失败—意味着某个其他方法的任务已经于此操作执行期间修改了这个对象，一致则更新记录，否则就认为此数据已被更新过，认为数据已过期，不予更新，此时我们的数据为未锁定状态。</p><p><strong>CAS 机制概要：</strong></p><p>此机制有三个主要操作数：内存值 V 、旧期望值 A 、修改值 B<br>首先拿旧期望值 A 和 内存值 V 比较，如果相同，则使内存值 V 更新为修改值 B。如果不同则证明内存值 V 在并发情况下已被其他线程修改，则不做任何修改。</p><p>我们来看一下原子包下常用的 AtomicInteger 类的 getAndIncrement() 自增操作，探究一下 CAS</p><p><strong>Jdk 源码实现部分</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一：调用 getAndIncrement() 查看源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// U 是 Unsafe 类的引用，Unsafe 类用于执行低级、不安全操作的方法的集合 </span></span><br><span class="line">  <span class="comment">//Unsafe 类绝大部分方法都是 native 修饰的，这种方法实现于 openJdk 的 hotspot/share/vm/prims/unsafe.cpp</span></span><br><span class="line">    <span class="keyword">return</span> U.getAndAddInt(<span class="keyword">this</span>， VALUE， <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* getAndAddInt()：</span></span><br><span class="line"><span class="comment">      传入参数</span></span><br><span class="line"><span class="comment">      this：当前方法调用对象</span></span><br><span class="line"><span class="comment">      VALUE：由 U.objectFieldOffset() 返回的对象字段偏移量</span></span><br><span class="line"><span class="comment">      1：传入的 delta 增量为 1 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二：getAndAddInt()  @HotSpotIntrinsicCandidate 注解 表明此方法在 HotSpot（JVM） 中有一套高效的实现，此实现基于 CPU 指令</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o， <span class="keyword">long</span> offset， <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 无论怎样先获取当前变量的最新值，getIntVolatile 是本地方法，jdk不开源，要 openjdk 才能查看</span></span><br><span class="line">        v = getIntVolatile(o， offset);</span><br><span class="line">      <span class="comment">//进入 比较交换阶段</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!weakCompareAndSetInt(o， offset， v， v + delta));</span><br><span class="line">       <span class="comment">/* weakCompareAndSetInt()：</span></span><br><span class="line"><span class="comment">        传入参数</span></span><br><span class="line"><span class="comment">        o：当前方法调用对象</span></span><br><span class="line"><span class="comment">        offset：字段偏移量</span></span><br><span class="line"><span class="comment">        v：当前变量的最新值</span></span><br><span class="line"><span class="comment">        v + delta：最新值 + 1 </span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//三：weakCompareAndSetInt() 源码，将操作转移给本地方法 compareAndSetInt()</span></span><br><span class="line"> <span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSetInt</span><span class="params">(Object o， <span class="keyword">long</span> offset，</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> expected，</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetInt(o， offset， expected， x);</span><br><span class="line">      <span class="comment">/* compareAndSetInt()：</span></span><br><span class="line"><span class="comment">        传入参数</span></span><br><span class="line"><span class="comment">        o：当前方法调用对象</span></span><br><span class="line"><span class="comment">        offset：字段偏移量</span></span><br><span class="line"><span class="comment">        expected：期望值</span></span><br><span class="line"><span class="comment">        x：想要修改的值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//四：compareAndSetInt() 源码，又是本地方法！跟踪不了了...转 openjdk</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates Java variable to &#123;<span class="doctag">@code</span> x&#125; if it is currently</span></span><br><span class="line"><span class="comment"> * holding &#123;<span class="doctag">@code</span> expected&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This operation has memory semantics of a &#123;<span class="doctag">@code</span> volatile&#125; read</span></span><br><span class="line"><span class="comment"> * and write.  Corresponds to C11 atomic_compare_exchange_strong.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//注释大意：如果当前变量值与期望值 expected 相等，则将其原子更新为 x</span></span><br><span class="line"> <span class="comment">// 怎么实现原子更新的呢？通过查看 OpenJdk 部分了解</span></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSetInt</span><span class="params">(Object o， <span class="keyword">long</span> offset，</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> expected，</span></span></span><br><span class="line"><span class="function"><span class="params">                                             <span class="keyword">int</span> x)</span></span>;</span><br></pre></td></tr></table></figure><p><em>以下 OpenJdk 部分参考文章</em>：<a href="https://www.cnblogs.com/jiuya/p/10368129.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiuya/p/10368129.html</a></p><p><strong>compareAndSetInt() 的 OpenJdk 实现部分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一：来到 unsafe类的底层实现中</span></span><br><span class="line">UNSAFE_ENTRY（jboolean，Unsafe_CompareAndSetInt（JNIEnv * env，jobject unsafe，jobject obj，jlong​​ offset，jint e，jint x））&#123;</span><br><span class="line">  oop p = JNIHandles :: resolve（obj）;</span><br><span class="line">  jint * addr =（jint *）index_oop_from_field_offset_long（p，offset）;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>（jint）（Atomic :: cmpxchg（x，addr，e））== e;</span><br><span class="line">&#125; UNSAFE_END</span><br><span class="line"></span><br><span class="line"><span class="comment">//二：跟踪到 Atomic :: cmpxchg 方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_IF_MP(mp) __asm cmp mp， 0  \</span></span><br><span class="line">                       __asm je L0      \</span><br><span class="line">                       __asm _emit <span class="number">0xF0</span> \</span><br><span class="line">                       __asm L0:</span><br><span class="line">  </span><br><span class="line"><span class="keyword">inline</span> jint     Atomic::cmpxchg    (jint exchange_value， <span class="keyword">volatile</span> jint* dest， jint compare_value) &#123;</span><br><span class="line">  <span class="comment">// alternative for InterlockedCompareExchange</span></span><br><span class="line">  <span class="keyword">int</span> mp = os::is_MP();</span><br><span class="line">  __asm &#123;</span><br><span class="line">    mov edx， dest</span><br><span class="line">    mov ecx， exchange_value</span><br><span class="line">    mov eax， compare_value</span><br><span class="line">    LOCK_IF_MP(mp)</span><br><span class="line">    cmpxchg dword ptr [edx]， ecx</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面源代码所示，CAS 底层用嵌入的汇编实现的， CPU指令是 cmpxchg，程序会根据当前处理器的类型来决定是否为 cmpxchg 指令添加 lock 前缀。如果程序是在多处理器上运行，就为 cmpxchg 指令加上 lock 前缀( lock cmpxchg )。反之，如果程序是在单处理器上运行，就省略 lock 前缀(单处理器自身会维护单处理器内的顺序一致性，不需要 lock 前缀提供的内存屏障效果)。 lock 前缀的作用说明：1、禁止该指令与之前和之后的读和写指令重排序，2、把写缓冲区中的所有数据刷新到内存中。</p><p>总的来说，Atomic 实现了高效无锁(底层还是用到互斥锁，不过底层处理比 Java 层处理要快很多)与线程安全( volatile 变量特性)，CAS 一般适用于计数；多线程编程也适用，多个线程执行 AtomicXXX 类下面的方法，当某个线程执行的时候具有排他性，在执行方法中不会被打断，直至当前线程完成才会执行其他的线程。</p><p>CAS 的缺点 (乐观锁缺点)</p><ul><li>ABA问题：内存对象从 A 变成 B 在变成 A ，CAS 会当成没有变化，进而去更新值，实际是有变化的。（解决办法使用 JUC 下的AtomicStampedReference 提供的版本机制 ）</li><li>多个线程同时自旋情况下开销大、一直和预期值不对的情况下，会一直循环。</li><li>只能保证单个共享变量的原子操作。</li></ul><h3 id="线程封闭"><a href="#线程封闭" class="headerlink" title="线程封闭"></a>线程封闭</h3><hr><h3 id="线程安全性委托"><a href="#线程安全性委托" class="headerlink" title="线程安全性委托"></a>线程安全性委托</h3><p>Delegated</p><hr><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>为什么要使用线程池?</p><ul><li>降低频繁创建线程而产生的一系列消耗，从而提高对资源的利用率</li><li>线程池可以提高线程的可管理性，方便资源分配和性能调优</li></ul><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p>jdk1.5 以后可以使用 java.util.concurrent 下的 Interface Executor 执行器管理线程对象<br>常见实现类： ThreadPoolExecutor ， ScheduledThreadPoolExecutor ，都支持 Runnable 和 Callable 接口的实现</p><p>结构体系：<br><img data-src="https://s2.ax1x.com/2020/01/13/l7lXZD.png" alt="Executor的执行相关接口"></p><p>简单使用步骤：</p><ul><li>创建线程池，指定容量：使用并发包内的 Executors 线程工厂类调用<code>静态工厂方法 newFixedThreadPool(int nThreads)</code> ，生成指定容量的线程池</li><li>创建任务并提交至线程池：两种方法，实现 Runnable 或者实现 Callable 接口，重写 run() / call()，通过线程池对象调用 submit() 传入接口实现类对象，提交任务</li><li>销毁线程池（）：shutdown()<br>弊端：容易造成 OOM</li></ul><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future 接口以及 Future 接口的实现类 FutureTask 类都可以用于获取异步执行的结果</p><p>当我们把 Runnable接口 或 Callable 接口 的实现类提交到线程池中时(submit())会返回一个 Future 对象，此对象就是异步执行的结果集</p><p>Future<v>中定义的方法</v></p><ul><li>get()：获取结果（可能会等待）</li><li>get(long timeout， TimeUnit unit)：获取结果，但只等待指定的时间</li><li>cancel(boolean mayInterruptIfRunning)：取消当前任务</li><li>isDone()：判断任务是否已完成</li></ul><p>Future 的增强：CompletableFuture 类</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><em>摘取自:</em> <a href="https://snailclimb.gitee.io/javaguide/#/?id=java" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/?id=java</a></p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ul><li>什么是线程和进程?</li></ul><p>进程：系统资源分配最小基本单位，一个程序可以拥有多个进程，windows 下一般为 .exe 文件<br>线程：系统资源调度最小基本单位，当我们创建启动 java 文件时，就会有多条线程运行，其中最主要的就是主线程</p><ul><li>请简要描述线程与进程的关系，区别及优缺点？</li></ul><p>进程内可以拥有多条线程，进程包含线程</p><p>进程：具有独立的地址空间，但是开销大<br>线程：更具有健壮性，调度成本低，但是容易造成线程死锁</p><ul><li><p>说说并发与并行的区别?<br>并行：多个事件在同一个时间点发生<br>并发：多个事件在同一个时间段内发生</p></li><li><p>为什么要使用多线程呢?</p><ul><li>更好的利用 cpu 资源</li><li>并发编程基础</li></ul></li><li><p>使用多线程可能带来什么问题?</p><ul><li>内存泄漏</li><li>死锁</li></ul></li><li><p>说说线程的生命周期和状态?</p><ul><li>新建状态</li><li>运行状态</li><li>无限等待状态</li><li>计时等待状态</li><li>阻塞状态</li><li>终止状态</li></ul></li><li><p>什么是上下文切换?<br>资源任务的从保存再到加载的过程就是一次上下文切换</p></li><li><p>什么是线程死锁?如何避免死锁?</p></li></ul><p>当拥有线程1 持有 A 锁的情况下，试图获取 B 锁，而在同时线程2 已持有 B 锁，正试图获取 A 锁，此时两个线程都不释放自己的锁，造成了永久堵塞，形成死锁<br>在访问对方资源时释放自己的锁，避免出现环形资源请求的情况</p><ul><li><p>说说 sleep() 方法和 wait() 方法区别和共同点?<br>区别: 前者会自动恢复，执行后不会释放对象锁，而后者不会自动恢复，必须被唤醒，但会释放对象锁。<br>共同点：两个方法都会主动放弃 cup 的使用权。</p></li><li><p>为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<br>start() 会将调用线程添加至线程工作组，并通知 JVM 即将启动，当获取到 cpu 时将会使线程进入运行状态，自动执行 run()方法，而直接执行 run() 方法将会在 mian 线程中执行，就像是执行普通方法一样，并不是新建的线程中执行。</p></li></ul><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>synchronized 关键字:<br>① 说一说自己对于 synchronized 关键字的了解；</p><p>synchronized 是一种重量级锁，用它可以修饰代码块和方法，被修饰的代码块叫同步代码块，进入代码块时，需要获取指定对象实例的锁；被修饰的方法称为同步方法，进入方法时，需要获取当前对象实例的锁；当修饰静态方法时，进入静态方法时，需要获取当前类对象的锁。总而言之，被同步的资源在同一时刻只能被一个线程访问，体现了资源的互斥性。</p><p>② 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗;</p><p>在使用多线程编程时，通常需要对一部分资源实现同步操作时，可以使用 synchronized 对需要同步的代码块/方法修饰，并加上相同锁对象，实现对此资源的互斥访问<br>主要分为三种用法：</p><ul><li>修饰代码块：进入此代码块时，需要获取指定对象锁</li><li>修饰成员方法：进入此方法时，需要获取当前对象实例锁</li><li>修饰静态成员方法：进入此方法时，需要获取当前类对象锁<ul><li>当线程 A 访问对象实例的非静态 synchronized 方法时，线程 B 正在访问同个对象实例所属类的静态 synchronized 方法，此时是允许的，并不会产生互斥动作，因为线程 A 占用的是对象实例锁，而线程 B 占用的是对象实例所属类对象的锁</li></ul></li></ul><p><strong>synchronized 关键字的底层原理</strong></p><p><code>synchronized</code>底层原理涉及到了 JVM 层面，当<code>synchronized</code>修饰代码块时，会在编译成字节码文件时，在代码块开始处插入<code>monitorenter</code>（监视器进入）结束处插入<code>monitorexit</code>（监视器退出）两个字节码指令，当修饰方法时，会在生成方法处使用<code>ACC_SYNCHRONIZED</code>来标识此方法是同步方法，从而在执行时相关的同步调用。</p><p>④ 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗；</p><p>⑤ 谈谈 synchronized 和 ReentrantLock 的区别。</p><p>volatile 关键字：<br>① 讲一下 Java 内存模型；<br>② 说说 synchronized 关键字和 volatile 关键字的区别。</p><p>ThreadLocal：<br>① 简介；<br>② 原理；<br>③ 内存泄露问题。</p><p>线程池：<br>① 为什么要用线程池？；<br>② 实现 Runnable 接口和 Callable 接口的区别；<br>③ 执行 execute() 方法和 submit() 方法的区别是什么呢？；<br>④ 如何创建线程池。</p><p>Atomic 原子类:<br>① 介绍一下 Atomic 原子类；<br>② JUC 包中的原子类是哪 4 类?；<br>③ 讲讲 AtomicInteger 的使用；<br>④ 能不能给我简单介绍一下 AtomicInteger 类的原理。</p><p>java 线程之间的通信由内存模型JMM（Java Memory Model）控制。<br>（1）JMM决定一个线程对变量的写入何时对另一个线程可见。<br>（2）线程之间共享变量存储在主内存中<br>（3）每个线程有一个私有的本地内存，里面存储了读/写共享变量的副本。<br>（4）JMM通过控制每个线程的本地内存之间的交互，来为程序员提供内存可见性保证。</p></div><div><div><div style="text-align:center;color:#1b9af7;font-size:14px">----------本文结束&nbsp<i class="fa fa-hourglass-end"></i>&nbsp感谢您的阅读----------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/sr/tags/note/" rel="tag"><i class="fa fa-tag"></i>note</a></div><div class="post-nav"><div class="post-nav-item"><a href="/sr/post/2019-11-28-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-11-28-SE03-%E6%B3%9B%E5%9E%8B%E5%92%8C%E5%BC%82%E5%B8%B8/" rel="prev" title="SE03-泛型和异常"><i class="fa fa-chevron-left"></i> SE03-泛型和异常</a></div><div class="post-nav-item"><a href="/sr/post/2019-12-02-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0-SE-2019-12-02-SE05-Lambda%E5%92%8CStream/" rel="next" title="SE05-Lambda和Stream">SE05-Lambda和Stream <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#写在前面"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-number">2.</span> <span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程创建"><span class="nav-number">2.1.</span> <span class="nav-text">线程创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动创建相关方法区别"><span class="nav-number">2.2.</span> <span class="nav-text">启动创建相关方法区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程运行原理"><span class="nav-number">2.3.</span> <span class="nav-text">线程运行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-number">2.4.</span> <span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#等待唤醒机制"><span class="nav-number">2.5.</span> <span class="nav-text">等待唤醒机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全"><span class="nav-number">2.6.</span> <span class="nav-text">线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#解决线程安全问题"><span class="nav-number">3.</span> <span class="nav-text">解决线程安全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步代码块-amp-同步方法"><span class="nav-number">3.1.</span> <span class="nav-text">同步代码块&amp;同步方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁"><span class="nav-number">3.2.</span> <span class="nav-text">锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性、可见性"><span class="nav-number">3.3.</span> <span class="nav-text">原子性、可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原子性"><span class="nav-number">3.3.1.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可见性"><span class="nav-number">3.3.2.</span> <span class="nav-text">可见性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发包-JUC"><span class="nav-number">3.4.</span> <span class="nav-text">并发包 JUC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#java-util-concurrent-atomic"><span class="nav-number">3.4.1.</span> <span class="nav-text">java.util.concurrent.atomic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">3.4.2.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">3.4.3.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">3.4.4.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Semaphore"><span class="nav-number">3.4.5.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exchanger"><span class="nav-number">3.4.6.</span> <span class="nav-text">Exchanger</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CAS-机制-compare-and-swap"><span class="nav-number">3.5.</span> <span class="nav-text">CAS 机制(compare and swap)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程封闭"><span class="nav-number">3.6.</span> <span class="nav-text">线程封闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程安全性委托"><span class="nav-number">3.7.</span> <span class="nav-text">线程安全性委托</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程池"><span class="nav-number">4.</span> <span class="nav-text">线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor"><span class="nav-number">4.1.</span> <span class="nav-text">Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Future"><span class="nav-number">4.2.</span> <span class="nav-text">Future</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面试题"><span class="nav-number">5.</span> <span class="nav-text">面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础"><span class="nav-number">5.1.</span> <span class="nav-text">基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进阶"><span class="nav-number">5.2.</span> <span class="nav-text">进阶</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="min" src="https://s2.ax1x.com/2019/12/30/lla7HU.gif"><p class="site-author-name" itemprop="name">min</p><div class="site-description" itemprop="description">欢迎瓜友~</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts" id="showPosts"><a href="/sr/archives"><span class="site-state-item-count">59</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories" id="showCategory"><a href="/sr/categories/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags" id="showTag"><a href="/sr/tags/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xming1001" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xming1001" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:xming1001@163.com" title="E-Mail → mailto:xming1001@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div><script type="text/javascript" charset="utf-8" src="/sr/js/tagcloud.js"></script><script type="text/javascript" charset="utf-8" src="/sr/js/tagcanvas.js"></script><div class="widget-wrap"><div id="myCanvasContainer" class="widget tagcloud"><canvas width="250" height="250" id="resCanvas"><ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Git/" rel="tag">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Hexo/" rel="tag">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/IDEA/" rel="tag">IDEA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Maven/" rel="tag">Maven</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/MyBatis/" rel="tag">MyBatis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/NoSQL/" rel="tag">NoSQL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/SQL/" rel="tag">SQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/SVN/" rel="tag">SVN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/Travis-CI/" rel="tag">Travis CI</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/sr/tags/note/" rel="tag">note</a><span class="tag-list-count">52</span></li></ul></canvas></div></div><div><canvas id="canvas" style="width:60%">当前浏览器不支持canvas，请更换浏览器后再试</canvas></div><script>!function(){function t(t,e){for(var a=0;a<l[e].length;a++)for(var n=0;n<l[e][a].length;n++)1==l[e][a][n]&&(h.beginPath(),h.arc(14*(g+2)*t+2*n*(g+1)+(g+1),2*a*(g+1)+(g+1),g,0,2*Math.PI),h.closePath(),h.fill())}function e(){var t=[],e=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date),a=[];a.push(e[1],e[2],10,e[3],e[4],10,e[5],e[6]);for(var r=c.length-1;r>=0;r--)a[r]!==c[r]&&t.push(r+"_"+(Number(c[r])+1)%10);for(var r=0;r<t.length;r++)n.apply(this,t[r].split("_"));c=a.concat()}function a(){for(var t=0;t<d.length;t++)d[t].stepY+=d[t].disY,d[t].x+=d[t].stepX,d[t].y+=d[t].stepY,(d[t].x>i+g||d[t].y>f+g)&&(d.splice(t,1),t--)}function n(t,e){for(var a=[1,2,3],n=["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"],r=0;r<l[e].length;r++)for(var o=0;o<l[e][r].length;o++)if(1==l[e][r][o]){var h={x:14*(g+2)*t+2*o*(g+1)+(g+1),y:2*r*(g+1)+(g+1),stepX:Math.floor(4*Math.random()-2),stepY:-2*a[Math.floor(Math.random()*a.length)],color:n[Math.floor(Math.random()*n.length)],disY:1};d.push(h)}}function r(){o.height=100;for(var e=0;e<c.length;e++)t(e,c[e]);for(var e=0;e<d.length;e++)h.beginPath(),h.arc(d[e].x,d[e].y,g,0,2*Math.PI),h.fillStyle=d[e].color,h.closePath(),h.fill()}var l=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,0,0,0]]],o=document.getElementById("canvas");if(o.getContext){var h=o.getContext("2d"),f=100,i=700;o.height=f,o.width=i,h.fillStyle="#f00",h.fillRect(10,10,50,50);var c=[],d=[],g=o.height/20-1;!function(){var t=/(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date);c.push(t[1],t[2],10,t[3],t[4],10,t[5],t[6])}(),clearInterval(v);var v=setInterval(function(){e(),a(),r()},50)}}()</script><div class="back-to-top motion-element"><i class="fa fa-arrow-up"></i> <span>0%</span></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright"><a href="https://xming1001.github.io/sr/" class="fa fa-yelp" id="jump"></a><span id="timeDate" style="color:rgba(241,241,241,.8)">载入天数...</span> <span id="times" style="color:rgba(241,241,241,.8)">载入时分秒...</span><script>function createtime(){var n=new Date("10/01/2019 8:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML=" Xm 的小站已运行了 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div style="color:rgba(241,241,241,.8)"><a href="https://xming1001.github.io/sr/" class="fa fa-yelp" style="color:rgba(241,241,241,.8)"></a> 小站总访客数：<span id="busuanzi_value_site_uv"></span>&nbsp人 <a href="https://xming1001.github.io/sr/" class="fa fa-yelp" style="color:rgba(241,241,241,.8)"></a> 小站总访问量：<span id="busuanzi_value_site_pv"></span>&nbsp次</div></div></div></footer></div><script src="/sr/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/lozad.js/1.9.0/lozad.min.js"></script><script src="/sr/lib/velocity/velocity.min.js"></script><script src="/sr/lib/velocity/velocity.ui.min.js"></script><script src="/sr/js/utils.js"></script><script src="/sr/js/motion.js"></script><script src="/sr/js/schemes/pisces.js"></script><script src="/sr/js/next-boot.js"></script><script src="/sr/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: '0VbITUQA3fmK0vbokUBDF7KN-gzGzoHsz',
      appKey: 'X3MeRhUqCp8hYNQMr9OKyHmY',
      placeholder: "欢迎交流讨论...",
      avatar: 'robohash',
      meta: guest,
      pageSize: '5' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: false,
      serverURLs: ''
    });
  }, window.Valine);
});</script></body></html><script type="text/javascript" src="/sr/js/clicklove.js"></script><!-- rebuild by neat -->